SandboxLimitOrderRouter.uniswapV3SwapCallback(int256,int256,bytes) (src/SandboxLimitOrderRouter.sol#89-111) uses arbitrary from in transferFrom: IERC20(tokenIn).safeTransferFrom(_sender,msg.sender,amountIn) (src/SandboxLimitOrderRouter.sol#107)
LimitOrderSwapRouter._swapV2(address,address,address,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#290-337) uses arbitrary from in transferFrom: IERC20(_tokenIn).safeTransferFrom(_sender,_lp,_amountIn) (src/LimitOrderSwapRouter.sol#303)
LimitOrderSwapRouter.uniswapV3SwapCallback(int256,int256,bytes) (src/LimitOrderSwapRouter.sol#447-502) uses arbitrary from in transferFrom: IERC20(tokenIn).safeTransferFrom(_sender,poolAddress,amountIn) (src/LimitOrderSwapRouter.sol#498)
LimitOrderExecutor._transferTokensToContract(LimitOrderBook.LimitOrder) (src/LimitOrderExecutor.sol#653-661) uses arbitrary from in transferFrom: IERC20(order.tokenIn).safeTransferFrom(order.owner,address(this),order.quantity) (src/LimitOrderExecutor.sol#656-660)
LimitOrderExecutor.executeSandboxLimitOrders(SandboxLimitOrderBook.SandboxLimitOrder[],SandboxLimitOrderRouter.SandboxMulticall) (src/LimitOrderExecutor.sol#669-748) uses arbitrary from in transferFrom: IERC20(orders[i].tokenIn).safeTransferFrom(orders[i].owner,sandboxMulticall.transferAddresses[i],fillAmount) (src/LimitOrderExecutor.sol#684-688)
LimitOrderExecutor.executeSandboxLimitOrders(SandboxLimitOrderBook.SandboxLimitOrder[],SandboxLimitOrderRouter.SandboxMulticall) (src/LimitOrderExecutor.sol#669-748) uses arbitrary from in transferFrom: IERC20(orders[i_scope_0].tokenIn).safeTransferFrom(orders[i_scope_0].owner,SANDBOX_LIMIT_ORDER_ROUTER,fillAmount_scope_1) (src/LimitOrderExecutor.sol#711-715)
ConveyorSwapAggregatorTest.uniswapV3SwapCallback(int256,int256,bytes) (src/test/ConveyorSwapAggregator.t.sol#190-212) uses arbitrary from in transferFrom: IERC20(tokenIn).transferFrom(_sender,msg.sender,amountIn) (src/test/ConveyorSwapAggregator.t.sol#208)
ConveyorSwapExecutor.uniswapV3SwapCallback(int256,int256,bytes) (src/ConveyorSwapAggregator.sol#83-105) uses arbitrary from in transferFrom: IERC20(tokenIn).transferFrom(_sender,msg.sender,amountIn) (src/ConveyorSwapAggregator.sol#101)
Reference: https://github.com/trailofbits/slither/wiki/Detector-Documentation#arbitrary-send-erc20

Swap.swapEthForTokenWithUniV2(uint256,address) (src/test/utils/Swap.sol#19-37) sends eth to arbitrary user
	Dangerous calls:
	- amountOut = uniV2Router.swapExactETHForTokens{value: amount}(1,path,msg.sender,(2 ** 256 - 1))[1] (src/test/utils/Swap.sol#29-34)
Swap.swapEthForTokenWithTransferFeesUniV2(uint256,address) (src/test/utils/Swap.sol#40-52) sends eth to arbitrary user
	Dangerous calls:
	- uniV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(1,path,msg.sender,(2 ** 256 - 1)) (src/test/utils/Swap.sol#50)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations

LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190) uses a weak PRNG: "orderIdToLimitOrder[order.orderId].lastRefreshTimestamp = uint32(block.timestamp % (2 ** 32 - 1)) (src/LimitOrderRouter.sol#177-179)" 
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG

LimitOrderExecutorWrapper is re-used:
	- LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
	- LimitOrderExecutorWrapper (src/test/LimitOrderExecutor.t.sol#3119-3265)
	- LimitOrderExecutorWrapper (src/test/SandboxLimitOrderRouter.t.sol#2039-2073)
	- LimitOrderExecutorWrapper (src/test/ConveyorFeeMath.t.sol#179-284)
CheatCodes is re-used:
	- CheatCodes (src/test/LimitOrderRouter.t.sol#19-32)
	- CheatCodes (src/test/ConveyorGasOracle.t.sol#9-36)
	- CheatCodes (src/test/SandboxLimitOrderBook.t.sol#16-41)
	- CheatCodes (src/test/LimitOrderBook.t.sol#17-28)
	- CheatCodes (src/test/SwapRouter.t.sol#23-37)
	- CheatCodes (src/test/LimitOrderQuoter.t.sol#18-37)
	- CheatCodes (src/test/LimitOrderExecutor.t.sol#19-30)
	- CheatCodes (src/test/ConveyorTickMath.t.sol#17-38)
	- CheatCodes (src/test/ConveyorSwapAggregator.t.sol#10-24)
	- CheatCodes (src/test/SandboxLimitOrderRouter.t.sol#20-33)
	- CheatCodes (src/test/ConveyorFeeMath.t.sol#21-25)
LimitOrderRouterWrapper is re-used:
	- LimitOrderRouterWrapper (src/test/LimitOrderRouter.t.sol#1888-1912)
	- LimitOrderRouterWrapper (src/test/LimitOrderExecutor.t.sol#3267-3289)
SandboxLimitOrderBookWrapper is re-used:
	- SandboxLimitOrderBookWrapper (src/test/SandboxLimitOrderBook.t.sol#756-780)
	- SandboxLimitOrderBookWrapper (src/test/SandboxLimitOrderRouter.t.sol#2075-2131)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused

Reentrancy in LimitOrderExecutor._executeTokenToTokenOrder(LimitOrderBook.LimitOrder,LimitOrderSwapRouter.TokenToTokenExecutionPrice) (src/LimitOrderExecutor.sol#575-649):
	External calls:
	- (amountInWethToB,conveyorReward,beaconReward) = _executeSwapTokenToWethOrder(executionPrice.lpAddressAToWeth,order) (src/LimitOrderExecutor.sol#589-596)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (lib/libraries/token/SafeERC20.sol#110)
		- IERC20(_tokenIn).safeTransferFrom(_sender,_lp,_amountIn) (src/LimitOrderSwapRouter.sol#303)
		- IERC20(_tokenIn).safeTransfer(_lp,_amountIn) (src/LimitOrderSwapRouter.sol#306)
		- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
		- amountOutMinAToWeth = ILimitOrderQuoter(LIMIT_ORDER_QUOTER).calculateAmountOutMinAToWeth(lpAddressAToWeth,orderQuantity,order.taxIn,feeIn,tokenIn) (src/LimitOrderExecutor.sol#447-454)
		- IUniswapV2Pair(_lp).swap(amount0Out,amount1Out,_receiver,new bytes(0)) (src/LimitOrderSwapRouter.sol#321-326)
		- IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MIN_SQRT_RATIO + 1,data) (src/LimitOrderSwapRouter.sol#425-433)
		- IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MAX_SQRT_RATIO - 1,data) (src/LimitOrderSwapRouter.sol#425-433)
	- _transferTokensToContract(order) (src/LimitOrderExecutor.sol#603)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (lib/libraries/token/SafeERC20.sol#110)
		- IERC20(order.tokenIn).safeTransferFrom(order.owner,address(this),order.quantity) (src/LimitOrderExecutor.sol#656-660)
		- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
	- amountOutInB = _swap(WETH,order.tokenOut,executionPrice.lpAddressWethToB,order.feeOut,amountInWethToB,order.amountOutMin,order.owner,address(this)) (src/LimitOrderExecutor.sol#633-642)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (lib/libraries/token/SafeERC20.sol#110)
		- IERC20(_tokenIn).safeTransferFrom(_sender,_lp,_amountIn) (src/LimitOrderSwapRouter.sol#303)
		- IERC20(_tokenIn).safeTransfer(_lp,_amountIn) (src/LimitOrderSwapRouter.sol#306)
		- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
		- IUniswapV2Pair(_lp).swap(amount0Out,amount1Out,_receiver,new bytes(0)) (src/LimitOrderSwapRouter.sol#321-326)
		- IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MIN_SQRT_RATIO + 1,data) (src/LimitOrderSwapRouter.sol#425-433)
		- IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MAX_SQRT_RATIO - 1,data) (src/LimitOrderSwapRouter.sol#425-433)
	External calls sending eth:
	- (amountInWethToB,conveyorReward,beaconReward) = _executeSwapTokenToWethOrder(executionPrice.lpAddressAToWeth,order) (src/LimitOrderExecutor.sol#589-596)
		- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
	- _transferTokensToContract(order) (src/LimitOrderExecutor.sol#603)
		- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
	- amountOutInB = _swap(WETH,order.tokenOut,executionPrice.lpAddressWethToB,order.feeOut,amountInWethToB,order.amountOutMin,order.owner,address(this)) (src/LimitOrderExecutor.sol#633-642)
		- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
	State variables written after the call(s):
	- amountOutInB = _swap(WETH,order.tokenOut,executionPrice.lpAddressWethToB,order.feeOut,amountInWethToB,order.amountOutMin,order.owner,address(this)) (src/LimitOrderExecutor.sol#633-642)
		- uniV3AmountOut = 0 (src/LimitOrderSwapRouter.sol#438)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities

ConveyorSwapAggregatorTest.uniswapV3SwapCallback(int256,int256,bytes) (src/test/ConveyorSwapAggregator.t.sol#190-212) ignores return value by IERC20(tokenIn).transferFrom(_sender,msg.sender,amountIn) (src/test/ConveyorSwapAggregator.t.sol#208)
ConveyorSwapAggregatorTest.uniswapV3SwapCallback(int256,int256,bytes) (src/test/ConveyorSwapAggregator.t.sol#190-212) ignores return value by IERC20(tokenIn).transfer(msg.sender,amountIn) (src/test/ConveyorSwapAggregator.t.sol#210)
ConveyorSwapAggregator.swap(address,uint256,address,uint256,ConveyorSwapAggregator.SwapAggregatorMulticall) (src/ConveyorSwapAggregator.sol#32-58) ignores return value by IERC20(tokenIn).transferFrom(msg.sender,swapAggregatorMulticall.tokenInDestination,amountIn) (src/ConveyorSwapAggregator.sol#39-43)
ConveyorSwapExecutor.uniswapV3SwapCallback(int256,int256,bytes) (src/ConveyorSwapAggregator.sol#83-105) ignores return value by IERC20(tokenIn).transferFrom(_sender,msg.sender,amountIn) (src/ConveyorSwapAggregator.sol#101)
ConveyorSwapExecutor.uniswapV3SwapCallback(int256,int256,bytes) (src/ConveyorSwapAggregator.sol#83-105) ignores return value by IERC20(tokenIn).transfer(msg.sender,amountIn) (src/ConveyorSwapAggregator.sol#103)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer

LimitOrderRouter.initialTxGas (src/LimitOrderRouter.sol#71) is never initialized. It is used in:
	- LimitOrderRouter.executeLimitOrders(bytes32[]) (src/LimitOrderRouter.sol#331-419)
	- LimitOrderRouter._calculateExecutionGasConsumed(uint256,uint256,LimitOrderBook.OrderType) (src/LimitOrderRouter.sol#457-478)
SandboxLimitOrderBook.initialTxGas (src/SandboxLimitOrderBook.sol#52) is never initialized. It is used in:
	- SandboxLimitOrderBook.executeOrdersViaSandboxMulticall(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderBook.sol#679-719)
	- SandboxLimitOrderBook._calculateExecutionGasConsumed(uint256,uint256,SandboxLimitOrderBook.OrderType) (src/SandboxLimitOrderBook.sol#1104-1125)
SandboxLimitOrderRouterTest.limitOrderRouter (src/test/SandboxLimitOrderRouter.t.sol#61) is never initialized. It is used in:
	- SandboxLimitOrderRouterTest.initializePreExecutionOwnerBalances(address[],address[],address[]) (src/test/SandboxLimitOrderRouter.t.sol#1323-1346)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables

LimitOrderSwapRouter.getAllPrices(address,address,uint24).spotPrice_scope_0 (src/LimitOrderSwapRouter.sol#761) is a storage variable never initialized
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables

Tick.tickSpacingToMaxLiquidityPerTick(int24) (lib/libraries/Uniswap/Tick.sol#43-50) performs a multiplication on the result of a division:
	- minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing (lib/libraries/Uniswap/Tick.sol#45)
Tick.tickSpacingToMaxLiquidityPerTick(int24) (lib/libraries/Uniswap/Tick.sol#43-50) performs a multiplication on the result of a division:
	- maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing (lib/libraries/Uniswap/Tick.sol#46)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv = (3 * denominator) ^ 2 (lib/libraries/Uniswap/FullMath.sol#88)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv *= 2 - denominator * inv (lib/libraries/Uniswap/FullMath.sol#92)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv *= 2 - denominator * inv (lib/libraries/Uniswap/FullMath.sol#93)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv *= 2 - denominator * inv (lib/libraries/Uniswap/FullMath.sol#94)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv *= 2 - denominator * inv (lib/libraries/Uniswap/FullMath.sol#95)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv *= 2 - denominator * inv (lib/libraries/Uniswap/FullMath.sol#96)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- denominator = denominator / twos (lib/libraries/Uniswap/FullMath.sol#68)
	- inv *= 2 - denominator * inv (lib/libraries/Uniswap/FullMath.sol#97)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (lib/libraries/Uniswap/FullMath.sol#73)
	- result = prod0 * inv (lib/libraries/Uniswap/FullMath.sol#105)
ConveyorMath.div128x128(uint256,uint256) (src/lib/ConveyorMath.sol#200-213) performs a multiplication on the result of a division:
	- hi = xInt * (MAX_128x128 / y) (src/lib/ConveyorMath.sol#207)
ConveyorMath.div128x128(uint256,uint256) (src/lib/ConveyorMath.sol#200-213) performs a multiplication on the result of a division:
	- lo = (xDec * (MAX_128x128 / y)) >> 128 (src/lib/ConveyorMath.sol#208)
ConveyorMath.divuu(uint256,uint256) (src/lib/ConveyorMath.sol#232-294) performs a multiplication on the result of a division:
	- answer = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1) (src/lib/ConveyorMath.sol#265)
	- hi = answer * (y >> 128) (src/lib/ConveyorMath.sol#271)
ConveyorMath.divuu(uint256,uint256) (src/lib/ConveyorMath.sol#232-294) performs a multiplication on the result of a division:
	- answer = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1) (src/lib/ConveyorMath.sol#265)
	- lo = answer * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) (src/lib/ConveyorMath.sol#272)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply

LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) uses a dangerous strict equality:
	- assert(bool)(order0_scope_1.lastRefreshTimestamp == block.timestamp) (src/test/LimitOrderRouter.t.sol#358)
LimitOrderBook._resolveCompletedOrder(bytes32) (src/LimitOrderBook.sol#494-520) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/LimitOrderBook.sol#499)
LimitOrderBook.cancelOrder(bytes32) (src/LimitOrderBook.sol#423-459) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/LimitOrderBook.sol#427)
LimitOrderRouter.executeLimitOrders(bytes32[]) (src/LimitOrderRouter.sol#331-419) uses a dangerous strict equality:
	- orders[i].orderId == bytes32(0) (src/LimitOrderRouter.sol#353)
LimitOrderBook.getLimitOrderById(bytes32) (src/LimitOrderBook.sol#156-168) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/LimitOrderBook.sol#163)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) uses a dangerous strict equality:
	- assert(bool)(orderPostRefresh.lastRefreshTimestamp == block.timestamp) (src/test/SandboxLimitOrderBook.t.sol#242)
SandboxLimitOrderBook._initializePreSandboxExecutionState(bytes32[][],uint128[]) (src/SandboxLimitOrderBook.sol#725-816) uses a dangerous strict equality:
	- currentOrder.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#764)
SandboxLimitOrderBook._resolveCompletedOrder(bytes32) (src/SandboxLimitOrderBook.sol#1248-1275) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#1255)
SandboxLimitOrderBook.cancelOrder(bytes32) (src/SandboxLimitOrderBook.sol#470-506) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#474)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) uses a dangerous strict equality:
	- ! (block.timestamp == lastGasOracleTimestamp) (src/ConveyorGasOracle.sol#48)
SandboxLimitOrderBook.getSandboxLimitOrderById(bytes32) (src/SandboxLimitOrderBook.sol#1367-1378) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#1373)
SandboxLimitOrderBook.updateSandboxLimitOrder(bytes32,uint128,uint128) (src/SandboxLimitOrderBook.sol#400-454) uses a dangerous strict equality:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#407)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities

Contract locking ether found:
	Contract LimitOrderRouterWrapper (src/test/LimitOrderRouter.t.sol#1888-1912) has payable functions:
	 - LimitOrderBook.placeLimitOrder(LimitOrderBook.LimitOrder[]) (src/LimitOrderBook.sol#173-299)
	But does not have a function to withdraw the ether
Contract locking ether found:
	Contract SandboxLimitOrderBookWrapper (src/test/SandboxLimitOrderBook.t.sol#756-780) has payable functions:
	 - SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394)
	But does not have a function to withdraw the ether
Contract locking ether found:
	Contract ConveyorTickMathTest (src/test/ConveyorTickMath.t.sol#40-284) has payable functions:
	 - ConveyorTickMathTest.receive() (src/test/ConveyorTickMath.t.sol#283)
	But does not have a function to withdraw the ether
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether

Reentrancy in SandboxLimitOrderBook.executeOrdersViaSandboxMulticall(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderBook.sol#679-719):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeSandboxLimitOrders(preSandboxExecutionState.sandboxLimitOrders,sandboxMulticall) (src/SandboxLimitOrderBook.sol#695-698)
	State variables written after the call(s):
	- _validateSandboxExecutionAndFillOrders(sandboxMulticall.orderIdBundles,sandboxMulticall.fillAmounts,preSandboxExecutionState) (src/SandboxLimitOrderBook.sol#701-705)
		- delete orderIdToSandboxLimitOrder[orderId] (src/SandboxLimitOrderBook.sol#1259)
		- orderIdToSandboxLimitOrder[orderId].fillPercent += ConveyorMath.fromX64ToX16(ConveyorMath.divUU(amountInFilled,amountInRemaining)) (src/SandboxLimitOrderBook.sol#1198-1201)
		- orderIdToSandboxLimitOrder[orderId].amountInRemaining = order.amountInRemaining - amountInFilled (src/SandboxLimitOrderBook.sol#1203-1205)
		- orderIdToSandboxLimitOrder[orderId].amountOutRemaining = order.amountOutRemaining - amountOutFilled (src/SandboxLimitOrderBook.sol#1207-1209)
		- orderIdToSandboxLimitOrder[orderId].feeRemaining = feeRemaining - uint128(ConveyorMath.mul64U(ConveyorMath.divUU(amountInFilled,amountInRemaining),feeRemaining)) (src/SandboxLimitOrderBook.sol#1216-1223)
Reentrancy in LimitOrderBook.placeLimitOrder(LimitOrderBook.LimitOrder[]) (src/LimitOrderBook.sol#173-299):
	External calls:
	- _checkSufficientGasCreditsForOrderPlacement(orderGroup.length) (src/LimitOrderBook.sol#178)
		- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderBook.sol#307-308)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/LimitOrderBook.sol#334-337)
	State variables written after the call(s):
	- ++ totalOrdersPerAddress[msg.sender] (src/LimitOrderBook.sol#260)
Reentrancy in SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394):
	External calls:
	- _checkSufficientGasCreditsForOrderPlacement(orderGroup.length) (src/SandboxLimitOrderBook.sol#219)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/SandboxLimitOrderBook.sol#1335-1338)
	State variables written after the call(s):
	- ++ totalOrdersPerAddress[msg.sender] (src/SandboxLimitOrderBook.sol#355)
Reentrancy in LimitOrderExecutor.withdrawConveyorFees() (src/LimitOrderExecutor.sol#784-792):
	External calls:
	- IWETH(WETH).withdraw(conveyorBalance) (src/LimitOrderExecutor.sol#786)
	State variables written after the call(s):
	- conveyorBalance = 0 (src/LimitOrderExecutor.sol#790)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1

LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025) uses tx.origin for authorization: assert(bool)(IERC20(WETH).balanceOf(tx.origin) >= txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1012)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207) uses tx.origin for authorization: assert(bool)(IERC20(WETH).balanceOf(tx.origin) >= txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1194)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255) uses tx.origin for authorization: assert(bool)(IERC20(WETH).balanceOf(tx.origin) >= txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1242)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin

ConveyorMath.fromUInt128(uint128) (src/lib/ConveyorMath.sol#41-47) contains a tautology or contradiction:
	- require(bool)(x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) (src/lib/ConveyorMath.sol#43)
ConveyorMath.from128x128(uint256) (src/lib/ConveyorMath.sol#52-58) contains a tautology or contradiction:
	- require(bool)(answer >= 0x0 && answer <= MAX_64x64) (src/lib/ConveyorMath.sol#55)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction

LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) ignores return value by address(WETH).call{value: amountIn}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#743-745)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls

LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#299) is a local variable never initialized
TickBitmap.nextInitializedTickWithinOneWord(mapping(int16 => uint256),int24,int24,bool).bitPos_scope_1 (lib/libraries/Uniswap/TickBitmap.sol#70) is a local variable never initialized
LimitOrderSwapRouter.getAllPrices(address,address,uint24).poolAddress_scope_1 (src/LimitOrderSwapRouter.sol#762) is a local variable never initialized
SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112).amountOut (src/test/SandboxLimitOrderBook.t.sol#414) is a local variable never initialized
LimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32)._spRes (src/LimitOrderSwapRouter.sol#529) is a local variable never initialized
LimitOrderBookTest.testPlaceOrder(uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#141) is a local variable never initialized
SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128).amountOut (src/test/SandboxLimitOrderRouter.t.sol#1138) is a local variable never initialized
LimitOrderQuoter._simulateAToBPriceChange(uint128,uint128,uint128,address,bool).amountOut_scope_0 (src/LimitOrderQuoter.sol#530) is a local variable never initialized
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]).relativeWethValue (src/SandboxLimitOrderBook.sol#243) is a local variable never initialized
LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256).amountOut1 (src/test/LimitOrderBook.t.sol#311) is a local variable never initialized
LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#228) is a local variable never initialized
SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(uint160,uint128,uint256,bool).product_scope_0 (lib/libraries/Uniswap/SqrtPriceMath.sol#50) is a local variable never initialized
SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8).amountOutTokenIn (src/test/SandboxLimitOrderBook.t.sol#335) is a local variable never initialized
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]).tokenAWethSpotPrice (src/SandboxLimitOrderBook.sol#253) is a local variable never initialized
LimitOrderSwapRouter.constructor(bytes32[],address[],bool[]).uniswapV3Factory (src/LimitOrderSwapRouter.sol#150) is a local variable never initialized
SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256).amountOut (src/test/SandboxLimitOrderBook.t.sol#531) is a local variable never initialized
utils.callDataCost(bytes).gasCost (src/test/utils/Utils.sol#12) is a local variable never initialized
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256).amountOut (src/test/SandboxLimitOrderBook.t.sol#498) is a local variable never initialized
LimitOrderBookTest.testFailUpdateOrder_OrderDoesNotExist(uint256,uint256,bytes32).amountOut (src/test/LimitOrderBook.t.sol#426) is a local variable never initialized
SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(uint160,uint128,uint256,bool).product (lib/libraries/Uniswap/SqrtPriceMath.sol#38) is a local variable never initialized
TickBitmap.nextInitializedTickWithinOneWord(mapping(int16 => uint256),int24,int24,bool).wordPos_scope_0 (lib/libraries/Uniswap/TickBitmap.sol#70) is a local variable never initialized
SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128).run (src/test/SandboxLimitOrderRouter.t.sol#1110) is a local variable never initialized
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables

LimitOrderRouterTest.testValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#242-275) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderRouter.t.sol#253)
LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#313)
LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderRouter.t.sol#314)
LimitOrderRouterTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/LimitOrderRouter.t.sol#363-410) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#367)
LimitOrderRouterTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/LimitOrderRouter.t.sol#363-410) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderRouter.t.sol#368)
LimitOrderRouterTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/LimitOrderRouter.t.sol#414-449) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#418)
LimitOrderRouterTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/LimitOrderRouter.t.sol#414-449) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderRouter.t.sol#419)
LimitOrderRouterTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderRouter.t.sol#559-629) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#563)
LimitOrderRouterTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#631-708) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#635)
LimitOrderRouterTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderRouter.t.sol#710-781) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderRouter.t.sol#714)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#783-840) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#787)
LimitOrderRouterTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#842-899) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#846)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderRouter.t.sol#905)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#906)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderRouter.t.sol#967-1027) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderRouter.t.sol#971)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderRouter.t.sol#967-1027) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#972)
LimitOrderRouterTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderRouter.t.sol#1029-1094) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderRouter.t.sol#1033)
LimitOrderRouterTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderRouter.t.sol#1029-1094) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#1034)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#1096-1154) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderRouter.t.sol#1100)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#1096-1154) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#1101)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1156-1213) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1160)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1215-1272) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1219)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1274-1331) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1278)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1333-1390) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1337)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderRouter.t.sol#1392-1434) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1396)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderRouter.t.sol#1436-1478) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1440)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1480-1537) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1484)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1539-1595) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1543)
LimitOrderRouterTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderRouter.t.sol#1597-1641) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#1601)
LimitOrderRouterTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#1643-1690) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#1647)
LimitOrderRouterTest.newMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1692-1750) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderRouter.t.sol#1696)
LimitOrderRouterTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1752-1858) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderRouter.t.sol#1756)
SandboxLimitOrderBookTest.testGetSandboxLimitOrderById() (src/test/SandboxLimitOrderBook.t.sol#132-151) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#133)
SandboxLimitOrderBookTest.testGetSandboxLimitOrderById() (src/test/SandboxLimitOrderBook.t.sol#132-151) ignores return value by swapHelper.swapEthForTokenWithUniV2(100000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#135)
SandboxLimitOrderBookTest.testFailGetSandboxLimitOrderById_OrderDoesNotExist() (src/test/SandboxLimitOrderBook.t.sol#154-156) ignores return value by sandboxLimitOrderBook.getSandboxLimitOrderById(bytes32(0)) (src/test/SandboxLimitOrderBook.t.sol#155)
SandboxLimitOrderBookTest.testGetOrderIds() (src/test/SandboxLimitOrderBook.t.sol#158-199) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#160)
SandboxLimitOrderBookTest.testGetOrderIds() (src/test/SandboxLimitOrderBook.t.sol#158-199) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#162)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#206)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#207)
SandboxLimitOrderBookTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/SandboxLimitOrderBook.t.sol#247-284) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#251)
SandboxLimitOrderBookTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/SandboxLimitOrderBook.t.sol#247-284) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#252)
SandboxLimitOrderBookTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/SandboxLimitOrderBook.t.sol#288-314) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#292)
SandboxLimitOrderBookTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/SandboxLimitOrderBook.t.sol#288-314) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#293)
SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#325-328)
SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) ignores return value by swapHelper.swapEthForTokenWithUniV2(amountIn,swapToken) (src/test/SandboxLimitOrderBook.t.sol#333-396)
SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112) (src/test/SandboxLimitOrderBook.t.sol#401-457) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#406)
SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112) (src/test/SandboxLimitOrderBook.t.sol#401-457) ignores return value by swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#409-455)
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientWalletBalance(uint112) (src/test/SandboxLimitOrderBook.t.sol#459-486) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#465)
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientWalletBalance(uint112) (src/test/SandboxLimitOrderBook.t.sol#459-486) ignores return value by sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#485)
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256) (src/test/SandboxLimitOrderBook.t.sol#488-517) ignores return value by swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#496-516)
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256) (src/test/SandboxLimitOrderBook.t.sol#488-517) ignores return value by sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#515)
SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#523-526)
SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586) ignores return value by swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#529-585)
SandboxLimitOrderBookTest.testUpdateSandboxOrder(uint128,uint128) (src/test/SandboxLimitOrderBook.t.sol#589-636) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#594)
SandboxLimitOrderBookTest.testUpdateSandboxOrder(uint128,uint128) (src/test/SandboxLimitOrderBook.t.sol#589-636) ignores return value by swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#597)
SandboxLimitOrderBookTest.testValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#638-666) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#651)
SandboxLimitOrderBookTest.testFailValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#669-696) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#675)
LimitOrderBookTest.testGetLimitOrderById() (src/test/LimitOrderBook.t.sol#101-127) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#102)
LimitOrderBookTest.testGetLimitOrderById() (src/test/LimitOrderBook.t.sol#101-127) ignores return value by swapHelper.swapEthForTokenWithUniV2(20000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#104)
LimitOrderBookTest.testFailGetLimitOrderById_OrderDoesNotExist() (src/test/LimitOrderBook.t.sol#130-132) ignores return value by orderBook.getLimitOrderById(bytes32(0)) (src/test/LimitOrderBook.t.sol#131)
LimitOrderBookTest.testPlaceOrder(uint256,uint256) (src/test/LimitOrderBook.t.sol#135-177) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#137)
LimitOrderBookTest.testPlaceOrder(uint256,uint256) (src/test/LimitOrderBook.t.sol#135-177) ignores return value by swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#140-176)
LimitOrderBookTest.testGetOrderIds() (src/test/LimitOrderBook.t.sol#179-217) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#181)
LimitOrderBookTest.testGetOrderIds() (src/test/LimitOrderBook.t.sol#179-217) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000,swapToken) (src/test/LimitOrderBook.t.sol#183)
LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256) (src/test/LimitOrderBook.t.sol#220-262) ignores return value by swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#227-261)
LimitOrderBookTest.testFailPlaceOrder_InsufficientWalletBalance() (src/test/LimitOrderBook.t.sol#265-284) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#266)
LimitOrderBookTest.testFailPlaceOrder_InsufficientWalletBalance() (src/test/LimitOrderBook.t.sol#265-284) ignores return value by orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#283)
LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#294)
LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) ignores return value by swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#298-334)
LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) ignores return value by swapHelper.swapEthForTokenWithUniV2(swapAmount1,swapToken1) (src/test/LimitOrderBook.t.sol#309-331)
LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) ignores return value by orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#328)
LimitOrderBookTest.testUpdateOrder(uint128,uint64,uint128,uint128,uint64) (src/test/LimitOrderBook.t.sol#338-386) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#353)
LimitOrderBookTest.testUpdateOrder(uint128,uint64,uint128,uint128,uint64) (src/test/LimitOrderBook.t.sol#338-386) ignores return value by swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#356)
LimitOrderBookTest.testFailUpdateOrder_InsufficientAllowanceForOrderUpdate(uint128,uint64,uint128,uint128) (src/test/LimitOrderBook.t.sol#389-415) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),quantity) (src/test/LimitOrderBook.t.sol#396)
LimitOrderBookTest.testFailUpdateOrder_InsufficientAllowanceForOrderUpdate(uint128,uint64,uint128,uint128) (src/test/LimitOrderBook.t.sol#389-415) ignores return value by swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#399)
LimitOrderBookTest.testFailUpdateOrder_OrderDoesNotExist(uint256,uint256,bytes32) (src/test/LimitOrderBook.t.sol#418-444) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#423)
LimitOrderBookTest.testFailUpdateOrder_OrderDoesNotExist(uint256,uint256,bytes32) (src/test/LimitOrderBook.t.sol#418-444) ignores return value by swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#425-443)
LimitOrderBookTest.testCancelOrder() (src/test/LimitOrderBook.t.sol#447-467) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#448)
LimitOrderBookTest.testCancelOrders() (src/test/LimitOrderBook.t.sol#476-512) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#477)
LimitOrderBookTest.testFailCancelOrders_OrderDoesNotExist(bytes32,bytes32) (src/test/LimitOrderBook.t.sol#515-526) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#519)
LimitOrderBookTest.testGetTotalOrdersValue() (src/test/LimitOrderBook.t.sol#529-547) ignores return value by swapHelper.swapEthForTokenWithUniV2(20000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#530)
LimitOrderBookTest.testGetTotalOrdersValue() (src/test/LimitOrderBook.t.sol#529-547) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#531)
LimitOrderSwapRouter._swapV3(address,address,address,uint24,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#395-441) ignores return value by IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MIN_SQRT_RATIO + 1,data) (src/LimitOrderSwapRouter.sol#425-433)
LimitOrderSwapRouter._swapV3(address,address,address,uint24,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#395-441) ignores return value by IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MAX_SQRT_RATIO - 1,data) (src/LimitOrderSwapRouter.sol#425-433)
SwapRouterTest.testSwapV2_1() (src/test/SwapRouter.t.sol#522-547) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#536)
SwapRouterTest.testSwapV2_1() (src/test/SwapRouter.t.sol#522-547) ignores return value by limitOrderExecutor.swapV2(tokenIn,tokenOut,lp,amountReceived,amountOutMin,receiver,address(this)) (src/test/SwapRouter.t.sol#538-546)
SwapRouterTest.testSwapV2_2() (src/test/SwapRouter.t.sol#549-574) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#563)
SwapRouterTest.testSwapV2_2() (src/test/SwapRouter.t.sol#549-574) ignores return value by limitOrderExecutor.swapV2(tokenIn,tokenOut,lp,amountReceived,amountOutMin,receiver,address(this)) (src/test/SwapRouter.t.sol#565-573)
SwapRouterTest.testSwapV2_3() (src/test/SwapRouter.t.sol#576-602) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#591)
SwapRouterTest.testSwapV2_3() (src/test/SwapRouter.t.sol#576-602) ignores return value by limitOrderExecutor.swapV2(tokenIn,tokenOut,lp,amountReceived,amountOutMin,receiver,address(this)) (src/test/SwapRouter.t.sol#593-601)
SwapRouterTest.testFailSwapV2_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#604-631) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#619)
SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),1000000000000000000) (src/test/SwapRouter.t.sol#644-647)
SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664) ignores return value by limitOrderExecutor.swapV3(_lp,tokenIn,tokenOut,500,1000000000000000000,1,receiver,address(this)) (src/test/SwapRouter.t.sol#654-663)
SwapRouterTest.testSwapV3_2() (src/test/SwapRouter.t.sol#667-692) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#676)
SwapRouterTest.testSwapV3_2() (src/test/SwapRouter.t.sol#667-692) ignores return value by limitOrderExecutor.swapV3(_lp,tokenIn,tokenOut,500,amountReceived,1,receiver,address(this)) (src/test/SwapRouter.t.sol#682-691)
SwapRouterTest.testSwap() (src/test/SwapRouter.t.sol#694-723) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#704)
SwapRouterTest.testSwap() (src/test/SwapRouter.t.sol#694-723) ignores return value by limitOrderExecutor.swap(tokenIn,tokenOut,lp,500,amountReceived,amountInMaximum,receiver,address(this)) (src/test/SwapRouter.t.sol#713-722)
SwapRouterTest.testFailSwap_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#725-755) ignores return value by IERC20(tokenIn).approve(address(limitOrderExecutor),amountReceived) (src/test/SwapRouter.t.sol#735)
LimitOrderExecutorTest.testMinGasCredits() (src/test/LimitOrderExecutor.t.sol#131-167) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#133)
LimitOrderExecutorTest.testMinGasCredits() (src/test/LimitOrderExecutor.t.sol#131-167) ignores return value by swapHelper.swapEthForTokenWithUniV2(2000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#136)
LimitOrderExecutorTest.testFailMinGasCredits() (src/test/LimitOrderExecutor.t.sol#169-205) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#171)
LimitOrderExecutorTest.testFailMinGasCredits() (src/test/LimitOrderExecutor.t.sol#169-205) ignores return value by swapHelper.swapEthForTokenWithUniV2(2000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#174)
LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271) ignores return value by swapHelper.swapEthForTokenWithUniV2(20000000000000000000000,swapToken) (src/test/LimitOrderExecutor.t.sol#210)
LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271) ignores return value by IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#211)
LimitOrderExecutorTest.testExecuteTokenToWethOrderBatch() (src/test/LimitOrderExecutor.t.sol#278-305) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#283)
LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#308-329) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#315)
LimitOrderExecutorTest.testExecuteWethToTokenSingle() (src/test/LimitOrderExecutor.t.sol#332-382) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#343)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#394)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#395)
LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),5000000000000000000000000000) (src/test/LimitOrderExecutor.t.sol#519)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#571)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#572)
LimitOrderExecutorTest.testExecuteTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#683-729) ignores return value by IERC20(USDC).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#688)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#747)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#863)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#911)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) ignores return value by IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#913)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025) ignores return value by IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#985)
LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1032)
LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1034)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1098)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159) ignores return value by IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1100)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207) ignores return value by swapHelperUniV2.swapEthForTokenWithUniV2(10000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1166)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207) ignores return value by IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1168)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255) ignores return value by swapHelperUniV2.swapEthForTokenWithUniV2(10000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1214)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255) ignores return value by IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1216)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1262)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323) ignores return value by IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1264)
LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1329-1358) ignores return value by IERC20(USDC).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1336)
LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#1361-1390) ignores return value by IERC20(USDC).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1368)
LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1393-1421) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1400)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#1547-1617) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1551)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#1619-1696) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1623)
LimitOrderExecutorTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#1698-1769) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1702)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1771-1828) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1775)
LimitOrderExecutorTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1830-1887) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1834)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderExecutor.t.sol#1893)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#1894)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderExecutor.t.sol#1959)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#1960)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderExecutor.t.sol#2017-2082) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderExecutor.t.sol#2021)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderExecutor.t.sol#2017-2082) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2022)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,UNI) (src/test/LimitOrderExecutor.t.sol#2088)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2089)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2144-2201) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2148)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2203-2260) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2207)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2262-2319) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2266)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2321-2378) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2325)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderExecutor.t.sol#2380-2422) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2384)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderExecutor.t.sol#2424-2466) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2428)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2468-2525) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2472)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2527-2583) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#2531)
LimitOrderExecutorTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2743-2849) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2747)
LimitOrderExecutorTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderExecutor.t.sol#2851-2895) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2855)
LimitOrderExecutorTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#2897-2944) ignores return value by swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2901)
LimitOrderExecutorTest.newMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#3030-3088) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#3034)
ConveyorSwapAggregatorTest.testSwapUniv2SingleLP() (src/test/ConveyorSwapAggregator.t.sol#54-88) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000,tokenIn) (src/test/ConveyorSwapAggregator.t.sol#64)
ConveyorSwapAggregatorTest.testSwapUniv2SingleLP() (src/test/ConveyorSwapAggregator.t.sol#54-88) ignores return value by IERC20(tokenIn).approve(address(conveyorSwapAggregator),type()(uint256).max) (src/test/ConveyorSwapAggregator.t.sol#65-68)
ConveyorSwapAggregatorTest.testSwapUniv2MultiLP() (src/test/ConveyorSwapAggregator.t.sol#90-131) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000,tokenIn) (src/test/ConveyorSwapAggregator.t.sol#101)
ConveyorSwapAggregatorTest.testSwapUniv2MultiLP() (src/test/ConveyorSwapAggregator.t.sol#90-131) ignores return value by IERC20(tokenIn).approve(address(conveyorSwapAggregator),type()(uint256).max) (src/test/ConveyorSwapAggregator.t.sol#102-105)
ConveyorSwapAggregatorTest.testSwapUniv3SingleLP() (src/test/ConveyorSwapAggregator.t.sol#133-188) ignores return value by IUniswapV3Pool(lp).swap(address(this),false,500000000000000000000,TickMath.MAX_SQRT_RATIO - 1,abi.encode(false,tokenOut,address(this))) (src/test/ConveyorSwapAggregator.t.sol#146-152)
ConveyorSwapAggregatorTest.testSwapUniv3SingleLP() (src/test/ConveyorSwapAggregator.t.sol#133-188) ignores return value by IERC20(tokenIn).approve(address(conveyorSwapAggregator),type()(uint256).max) (src/test/ConveyorSwapAggregator.t.sol#154-157)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#221)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#223)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#339)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#341)
SandboxLimitOrderRouterTest.testExecuteMulticallOrdersSameOwnerBundleInputToken() (src/test/SandboxLimitOrderRouter.t.sol#541-679) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#548)
SandboxLimitOrderRouterTest.testExecuteMulticallOrdersSameOwnerBundleInputToken() (src/test/SandboxLimitOrderRouter.t.sol#541-679) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#550)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_FillAmountSpecifiedGreaterThanAmountRemaining() (src/test/SandboxLimitOrderRouter.t.sol#726-794) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#735)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_FillAmountSpecifiedGreaterThanAmountRemaining() (src/test/SandboxLimitOrderRouter.t.sol#726-794) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#737)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_SandboxAmountOutRequiredNotSatisfied() (src/test/SandboxLimitOrderRouter.t.sol#796-865) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#805)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_SandboxAmountOutRequiredNotSatisfied() (src/test/SandboxLimitOrderRouter.t.sol#796-865) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#807)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_ConveyorFeesNotPaid() (src/test/SandboxLimitOrderRouter.t.sol#867-934) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#874)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_ConveyorFeesNotPaid() (src/test/SandboxLimitOrderRouter.t.sol#867-934) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#876)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_InvalidTransferAddressArray() (src/test/SandboxLimitOrderRouter.t.sol#936-1006) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#945)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_InvalidTransferAddressArray() (src/test/SandboxLimitOrderRouter.t.sol#936-1006) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#947)
SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1038)
SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1103-1176) ignores return value by swapHelper.swapEthForTokenWithUniV2(daiQuantity,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1136-1173)
SandboxLimitOrderRouterTest.initializeTestBalanceState(uint128) (src/test/SandboxLimitOrderRouter.t.sol#1401-1415) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1414)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1853)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1855)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1868)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1870)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1882)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1884)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1896)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1898)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1910)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1912)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1925)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1927)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1939)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1941)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1954)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1956)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1970)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) ignores return value by IERC20(WETH).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1992)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return

SwapRouterTest.testCalculateV2SpotSushiTest1().forkId (src/test/SwapRouter.t.sol#117) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV2SpotSushiTest2().forkId (src/test/SwapRouter.t.sol#149) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV2SpotSushiTest3().forkId (src/test/SwapRouter.t.sol#172) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV3SpotPrice1().forkId (src/test/SwapRouter.t.sol#192) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV3SpotPrice2().forkId (src/test/SwapRouter.t.sol#213) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV2SpotUni1().forkId (src/test/SwapRouter.t.sol#237) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV2SpotUni2().forkId (src/test/SwapRouter.t.sol#260) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
SwapRouterTest.testCalculateV2SpotUni3().forkId (src/test/SwapRouter.t.sol#283) shadows:
	- SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) (state variable)
LimitOrderExecutorWrapper.hasMinGasCredits(uint256,address,uint256,uint256).gasCreditBalance (src/test/LimitOrderExecutor.t.sol#3190) shadows:
	- LimitOrderExecutor.gasCreditBalance (src/LimitOrderExecutor.sol#42) (state variable)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing

LimitOrderRouter.confirmTransferOwnership() (src/LimitOrderRouter.sol#439-445) should emit an event for: 
	- owner = msg.sender (src/LimitOrderRouter.sol#443) 
LimitOrderExecutor.confirmTransferOwnership() (src/LimitOrderExecutor.sol#795-803) should emit an event for: 
	- owner = msg.sender (src/LimitOrderExecutor.sol#802) 
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control

Swap.constructor(address,address)._WETH (src/test/utils/Swap.sol#13) lacks a zero-check on :
		- WETH = _WETH (src/test/utils/Swap.sol#14)
SandboxLimitOrderRouter.constructor(address,address)._limitOrderExecutor (src/SandboxLimitOrderRouter.sol#49) lacks a zero-check on :
		- LIMIT_ORDER_EXECUTOR = _limitOrderExecutor (src/SandboxLimitOrderRouter.sol#50)
SandboxLimitOrderRouter.constructor(address,address)._sandboxLimitOrderBook (src/SandboxLimitOrderRouter.sol#49) lacks a zero-check on :
		- SANDBOX_LIMIT_ORDER_BOOK = _sandboxLimitOrderBook (src/SandboxLimitOrderRouter.sol#51)
LimitOrderSwapRouter.constructor(bytes32[],address[],bool[]).uniswapV3Factory (src/LimitOrderSwapRouter.sol#150) lacks a zero-check on :
		- UNISWAP_V3_FACTORY = uniswapV3Factory (src/LimitOrderSwapRouter.sol#156)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation

LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderRouter.t.sol#338-339)
LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) has external calls inside a loop: order0_scope_1 = orderBook.getLimitOrderById(orderBatch[i_scope_0]) (src/test/LimitOrderRouter.t.sol#352-353)
LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) has external calls inside a loop: assert(bool)(limitOrderExecutor.gasCreditBalance(address(this)) == gasCreditsBefore - REFRESH_FEE) (src/test/LimitOrderRouter.t.sol#354-357)
LimitOrderRouterTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/LimitOrderRouter.t.sol#363-410) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderRouter.t.sol#394-395)
LimitOrderRouterTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/LimitOrderRouter.t.sol#363-410) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/LimitOrderRouter.t.sol#404-407)
LimitOrderRouterTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/LimitOrderRouter.t.sol#414-449) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderRouter.t.sol#442-443)
LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190) has external calls inside a loop: currentBalance = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).gasCreditBalance(order.owner) (src/LimitOrderRouter.sol#147-148)
LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261) has external calls inside a loop: gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderRouter.sol#223-224)
LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261) has external calls inside a loop: orderOwnerGasCreditBalance = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).gasCreditBalance(order.owner) (src/LimitOrderRouter.sol#235-237)
LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,orderOwnerGasCreditBalance - executorFee) (src/LimitOrderRouter.sol#242-245)
LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,0) (src/LimitOrderRouter.sol#248-251)
LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190) has external calls inside a loop: IERC20(order.tokenIn).balanceOf(order.owner) < order.quantity (src/LimitOrderRouter.sol#160)
LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,currentBalance - REFRESH_FEE) (src/LimitOrderRouter.sol#170-173)
SandboxLimitOrderRouter.sandboxRouterCallback(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderRouter.sol#65-83) has external calls inside a loop: (success) = sandBoxCall.target.call(sandBoxCall.callData) (src/SandboxLimitOrderRouter.sol#73)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) has external calls inside a loop: order0 = sandboxLimitOrderBook.getSandboxLimitOrderById(orderBatch[i]) (src/test/SandboxLimitOrderBook.t.sol#219-222)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) has external calls inside a loop: orderPostRefresh = sandboxLimitOrderBook.getSandboxLimitOrderById(orderBatch[i_scope_0]) (src/test/SandboxLimitOrderBook.t.sol#235-237)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) has external calls inside a loop: assert(bool)(limitOrderExecutor.gasCreditBalance(address(this)) == gasCreditsBefore - REFRESH_FEE) (src/test/SandboxLimitOrderBook.t.sol#238-241)
SandboxLimitOrderBookTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/SandboxLimitOrderBook.t.sol#247-284) has external calls inside a loop: order0 = sandboxLimitOrderBook.getSandboxLimitOrderById(orderBatch[i]) (src/test/SandboxLimitOrderBook.t.sol#265-268)
SandboxLimitOrderBookTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/SandboxLimitOrderBook.t.sol#247-284) has external calls inside a loop: orderType = sandboxLimitOrderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/SandboxLimitOrderBook.t.sol#277-278)
SandboxLimitOrderBookTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/SandboxLimitOrderBook.t.sol#288-314) has external calls inside a loop: order0 = sandboxLimitOrderBook.getSandboxLimitOrderById(orderBatch[i]) (src/test/SandboxLimitOrderBook.t.sol#305-308)
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394) has external calls inside a loop: (spRes) = ILimitOrderSwapRouter(LIMIT_ORDER_EXECUTOR).getAllPrices(newOrder.tokenIn,WETH,500) (src/SandboxLimitOrderBook.sol#248-252)
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394) has external calls inside a loop: tokenInDecimals = IERC20(newOrder.tokenIn).decimals() (src/SandboxLimitOrderBook.sol#270-271)
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394) has external calls inside a loop: minFeeReceived = uint128(ConveyorMath.mul64U(ILimitOrderSwapRouter(LIMIT_ORDER_EXECUTOR).calculateFee(uint128(relativeWethValue),USDC,WETH),relativeWethValue)) (src/SandboxLimitOrderBook.sol#292-302)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has external calls inside a loop: (answer) = IAggregatorV3(gasOracleAddress).latestRoundData() (src/ConveyorGasOracle.sol#49-50)
SandboxLimitOrderBook._cancelSandboxLimitOrderViaExecutor(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#539-581) has external calls inside a loop: orderOwnerGasCreditBalance = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).gasCreditBalance(order.owner) (src/SandboxLimitOrderBook.sol#555-557)
SandboxLimitOrderBook._cancelSandboxLimitOrderViaExecutor(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#539-581) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,orderOwnerGasCreditBalance - executorFee) (src/SandboxLimitOrderBook.sol#562-565)
SandboxLimitOrderBook._cancelSandboxLimitOrderViaExecutor(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#539-581) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,0) (src/SandboxLimitOrderBook.sol#568-571)
SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).gasCreditBalance(order.owner) < REFRESH_FEE (src/SandboxLimitOrderBook.sol#625-627)
SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667) has external calls inside a loop: IERC20(order.tokenIn).balanceOf(order.owner) < order.amountInRemaining (src/SandboxLimitOrderBook.sol#633-634)
SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667) has external calls inside a loop: currentCreditBalance = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).gasCreditBalance(order.owner) (src/SandboxLimitOrderBook.sol#644-645)
SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667) has external calls inside a loop: ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,currentCreditBalance - REFRESH_FEE) (src/SandboxLimitOrderBook.sol#648-651)
LimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32) (src/LimitOrderSwapRouter.sol#509-575) has external calls inside a loop: (reserve0,reserve1) = IUniswapV2Pair(pairAddress).getReserves() (src/LimitOrderSwapRouter.sol#547-548)
LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128) (src/LimitOrderSwapRouter.sol#582-600) has external calls inside a loop: token0Decimals = IERC20(tok0).decimals() (src/LimitOrderSwapRouter.sol#589)
LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128) (src/LimitOrderSwapRouter.sol#582-600) has external calls inside a loop: token1Decimals = IERC20(tok1).decimals() (src/LimitOrderSwapRouter.sol#590)
LimitOrderSwapRouter._calculateV3SpotPrice(address,address,uint24,address) (src/LimitOrderSwapRouter.sol#609-641) has external calls inside a loop: pool = IUniswapV3Factory(_factory).getPool(token0,token1,fee) (src/LimitOrderSwapRouter.sol#618)
LimitOrderSwapRouter._calculateV3SpotPrice(address,address,uint24,address) (src/LimitOrderSwapRouter.sol#609-641) has external calls inside a loop: (sqrtPriceX96) = IUniswapV3Pool(pool).slot0() (src/LimitOrderSwapRouter.sol#624)
ConveyorTickMath.fromSqrtX96(uint160,bool,address,address) (src/lib/ConveyorTickMath.sol#72-100) has external calls inside a loop: decimalShift = int8(IERC20(token0).decimals()) - int8(IERC20(token1).decimals()) (src/lib/ConveyorTickMath.sol#80-81)
LimitOrderExecutorTest.testExecuteTokenToWethOrderBatch() (src/test/LimitOrderExecutor.t.sol#278-305) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToWethOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#288-289)
LimitOrderExecutorTest.testExecuteTokenToWethOrderBatch() (src/test/LimitOrderExecutor.t.sol#278-305) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),tokenToWethOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#299-302)
LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#308-329) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToWethOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#321-322)
LimitOrderExecutorTest.testExecuteWethToTokenSingle() (src/test/LimitOrderExecutor.t.sol#332-382) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#366-367)
LimitOrderExecutorTest.testExecuteWethToTokenSingle() (src/test/LimitOrderExecutor.t.sol#332-382) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderId) (src/test/LimitOrderExecutor.t.sol#376-379)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#462-463)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) has external calls inside a loop: order0_scope_1 = orderBook.getLimitOrderById(orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#473-474)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#476-479)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderId) (src/test/LimitOrderExecutor.t.sol#491-492)
LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559) has external calls inside a loop: order0 = orderBook.getLimitOrderById(tokenToWethOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#525-526)
LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#546)
LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),tokenToWethOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#553-556)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#624-625)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) has external calls inside a loop: order0_scope_1 = orderBook.getLimitOrderById(orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#644-645)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) has external calls inside a loop: order0_scope_3 = orderBook.getLimitOrderById(orderBatch[i_scope_2]) (src/test/LimitOrderExecutor.t.sol#655-656)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#658-661)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderId) (src/test/LimitOrderExecutor.t.sol#669-670)
LimitOrderExecutorTest.testExecuteTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#683-729) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToTokenOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#695-696)
LimitOrderExecutorTest.testExecuteTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#683-729) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#716)
LimitOrderExecutorTest.testExecuteTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#683-729) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),tokenToTokenOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#723-726)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#813-814)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) has external calls inside a loop: order0_scope_1 = orderBook.getLimitOrderById(orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#824-825)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#827-830)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderId) (src/test/LimitOrderExecutor.t.sol#838-839)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903) has external calls inside a loop: order = orderBook.getLimitOrderById(wethToTaxedOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#869-870)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#890)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),wethToTaxedOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#897-900)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#935-936)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) has external calls inside a loop: order0_scope_1 = orderBook.getLimitOrderById(orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#951-952)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#963)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_2]) (src/test/LimitOrderExecutor.t.sol#971-974)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToWethOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#992-993)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025) has external calls inside a loop: assert(bool)(IERC20(WETH).balanceOf(tx.origin) >= txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1012)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),tokenToWethOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1019-1022)
LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1066-1067)
LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1078)
LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1085-1088)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1134-1135)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1146)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1153-1156)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1173-1174)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207) has external calls inside a loop: assert(bool)(IERC20(WETH).balanceOf(tx.origin) >= txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1194)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1201-1204)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1221-1222)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255) has external calls inside a loop: assert(bool)(IERC20(WETH).balanceOf(tx.origin) >= txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1242)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1249-1252)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323) has external calls inside a loop: order0 = orderBook.getLimitOrderById(orderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1298-1299)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323) has external calls inside a loop: assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1310)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1317-1320)
LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1329-1358) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToTokenOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1343-1344)
LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1329-1358) has external calls inside a loop: order_scope_1 = orderBook.getLimitOrderById(tokenToTokenOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1354-1355)
LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#1361-1390) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToTokenOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1375-1376)
LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#1361-1390) has external calls inside a loop: order_scope_1 = orderBook.getLimitOrderById(tokenToTokenOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1386-1387)
LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1393-1421) has external calls inside a loop: order = orderBook.getLimitOrderById(tokenToWethOrderBatch[i]) (src/test/LimitOrderExecutor.t.sol#1406-1407)
LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1393-1421) has external calls inside a loop: order_scope_1 = orderBook.getLimitOrderById(tokenToWethOrderBatch[i_scope_0]) (src/test/LimitOrderExecutor.t.sol#1417-1418)
LimitOrderExecutor.executeTokenToWethOrders(LimitOrderBook.LimitOrder[]) (src/LimitOrderExecutor.sol#334-400) has external calls inside a loop: bestPriceIndex = ILimitOrderQuoter(LIMIT_ORDER_QUOTER).findBestTokenToWethExecutionPrice(executionPrices,orders[i].buy) (src/LimitOrderExecutor.sol#361-365)
LimitOrderExecutor._executeSwapTokenToWethOrder(address,LimitOrderBook.LimitOrder) (src/LimitOrderExecutor.sol#429-488) has external calls inside a loop: amountOutMinAToWeth = ILimitOrderQuoter(LIMIT_ORDER_QUOTER).calculateAmountOutMinAToWeth(lpAddressAToWeth,orderQuantity,order.taxIn,feeIn,tokenIn) (src/LimitOrderExecutor.sol#447-454)
LimitOrderSwapRouter._swapV2(address,address,address,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#290-337) has external calls inside a loop: balanceBefore = IERC20(_tokenOut).balanceOf(_receiver) (src/LimitOrderSwapRouter.sol#318)
LimitOrderSwapRouter._swapV2(address,address,address,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#290-337) has external calls inside a loop: IUniswapV2Pair(_lp).swap(amount0Out,amount1Out,_receiver,new bytes(0)) (src/LimitOrderSwapRouter.sol#321-326)
LimitOrderSwapRouter._swapV2(address,address,address,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#290-337) has external calls inside a loop: amountReceived = IERC20(_tokenOut).balanceOf(_receiver) - balanceBefore (src/LimitOrderSwapRouter.sol#329)
Address.functionCallWithValue(address,bytes,uint256,string) (lib/utils/Address.sol#128-137) has external calls inside a loop: (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
LimitOrderSwapRouter._swapV3(address,address,address,uint24,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#395-441) has external calls inside a loop: IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MIN_SQRT_RATIO + 1,data) (src/LimitOrderSwapRouter.sol#425-433)
LimitOrderSwapRouter._swapV3(address,address,address,uint24,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#395-441) has external calls inside a loop: IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MAX_SQRT_RATIO - 1,data) (src/LimitOrderSwapRouter.sol#425-433)
LimitOrderExecutor.executeTokenToWethOrders(LimitOrderBook.LimitOrder[]) (src/LimitOrderExecutor.sol#334-400) has external calls inside a loop: executionPrices[bestPriceIndex] = ILimitOrderQuoter(LIMIT_ORDER_QUOTER).simulateTokenToWethPriceChange(uint128(orders[i].quantity),executionPrices[bestPriceIndex]) (src/LimitOrderExecutor.sol#382-387)
LimitOrderExecutor.executeTokenToTokenOrders(LimitOrderBook.LimitOrder[]) (src/LimitOrderExecutor.sol#492-570) has external calls inside a loop: bestPriceIndex = ILimitOrderQuoter(LIMIT_ORDER_QUOTER).findBestTokenToTokenExecutionPrice(executionPrices,orders[i].buy) (src/LimitOrderExecutor.sol#533-537)
LimitOrderExecutor.executeTokenToTokenOrders(LimitOrderBook.LimitOrder[]) (src/LimitOrderExecutor.sol#492-570) has external calls inside a loop: executionPrices[bestPriceIndex] = ILimitOrderQuoter(LIMIT_ORDER_QUOTER).simulateTokenToTokenPriceChange(uint128(orders[i].quantity),executionPrices[bestPriceIndex]) (src/LimitOrderExecutor.sol#553-558)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orders[i].orderId) (src/test/SandboxLimitOrderRouter.t.sol#317-318)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orders[i].orderId) (src/test/SandboxLimitOrderRouter.t.sol#440-441)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderBatch() (src/test/SandboxLimitOrderRouter.t.sol#459-538) has external calls inside a loop: orderType = orderBook.addressToOrderIds(orders[i].owner,orders[i].orderId) (src/test/SandboxLimitOrderRouter.t.sol#501-502)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderBatch() (src/test/SandboxLimitOrderRouter.t.sol#459-538) has external calls inside a loop: order = orderBook.getSandboxLimitOrderById(orders[i].orderId) (src/test/SandboxLimitOrderRouter.t.sol#511-514)
SandboxLimitOrderRouterTest.testExecuteMulticallOrdersSameOwnerBundleInputToken() (src/test/SandboxLimitOrderRouter.t.sol#541-679) has external calls inside a loop: orderType = orderBook.addressToOrderIds(address(this),orderIds[i]) (src/test/SandboxLimitOrderRouter.t.sol#668-669)
ConveyorSwapExecutor.executeMulticall(ConveyorSwapAggregator.Call[]) (src/ConveyorSwapAggregator.sol#62-77) has external calls inside a loop: (success) = call.target.call(call.callData) (src/ConveyorSwapAggregator.sol#69)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop

Variable 'SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8).amountOutTokenIn (src/test/SandboxLimitOrderBook.t.sol#335)' in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) potentially used before declaration: order = newSandboxLimitOrder(swapToken,WETH,uint128(amountOutTokenIn),amountOut) (src/test/SandboxLimitOrderBook.t.sol#336-342)
Variable 'SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8).amountOutTokenIn (src/test/SandboxLimitOrderBook.t.sol#335)' in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) potentially used before declaration: sandboxLimitOrderBookWrapper.partialFillSandboxLimitOrder(uint128(amountOutTokenIn / amountInDivisor),amountOut / amountOutDivisor,orderId) (src/test/SandboxLimitOrderBook.t.sol#359-363)
Variable 'SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8).amountOutTokenIn (src/test/SandboxLimitOrderBook.t.sol#335)' in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) potentially used before declaration: assertEq(totalQuantityBefore - totalOrdersQuantityAfter,amountOutTokenIn / amountInDivisor) (src/test/SandboxLimitOrderBook.t.sol#371-374)
Variable 'SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8).amountOutTokenIn (src/test/SandboxLimitOrderBook.t.sol#335)' in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) potentially used before declaration: assertEq(orderPostPartialFill.fillPercent,ConveyorMath.fromX64ToX16(ConveyorMath.divUU(uint128(amountOutTokenIn / amountInDivisor),uint128(amountOutTokenIn)))) (src/test/SandboxLimitOrderBook.t.sol#376-384)
Variable 'SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8).amountOutTokenIn (src/test/SandboxLimitOrderBook.t.sol#335)' in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398) potentially used before declaration: assertEq(orderPostPartialFill.amountInRemaining,(uint128(amountOutTokenIn)) - uint128(amountOutTokenIn / amountInDivisor)) (src/test/SandboxLimitOrderBook.t.sol#386-390)
Variable 'SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112).amountOut (src/test/SandboxLimitOrderBook.t.sol#414)' in SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112) (src/test/SandboxLimitOrderBook.t.sol#401-457) potentially used before declaration: order = newSandboxLimitOrder(swapToken,WETH,uint112(amountOut),uint112(amountOutRemaining)) (src/test/SandboxLimitOrderBook.t.sol#415-421)
Variable 'SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112).amountOut (src/test/SandboxLimitOrderBook.t.sol#414)' in SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112) (src/test/SandboxLimitOrderBook.t.sol#401-457) potentially used before declaration: assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#444-449)
Variable 'SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256).amountOut (src/test/SandboxLimitOrderBook.t.sol#498)' in SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256) (src/test/SandboxLimitOrderBook.t.sol#488-517) potentially used before declaration: order = newSandboxLimitOrder(swapToken,swapToken,uint112(amountOut),uint112(amountOutRemaining)) (src/test/SandboxLimitOrderBook.t.sol#499-504)
Variable 'SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256).amountOut (src/test/SandboxLimitOrderBook.t.sol#531)' in SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586) potentially used before declaration: order = newSandboxLimitOrder(swapToken,WETH,uint112(amountOut),uint112(amountOutRemaining)) (src/test/SandboxLimitOrderBook.t.sol#532-538)
Variable 'SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256).amountOut (src/test/SandboxLimitOrderBook.t.sol#531)' in SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586) potentially used before declaration: assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#556-561)
Variable 'LimitOrderBookTest.testPlaceOrder(uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#141)' in LimitOrderBookTest.testPlaceOrder(uint256,uint256) (src/test/LimitOrderBook.t.sol#135-177) potentially used before declaration: order = newOrder(swapToken,WETH,uint128(executionPrice),uint112(amountOut),uint112(amountOut)) (src/test/LimitOrderBook.t.sol#143-149)
Variable 'LimitOrderBookTest.testPlaceOrder(uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#141)' in LimitOrderBookTest.testPlaceOrder(uint256,uint256) (src/test/LimitOrderBook.t.sol#135-177) potentially used before declaration: assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#168-173)
Variable 'LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#228)' in LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256) (src/test/LimitOrderBook.t.sol#220-262) potentially used before declaration: order = newOrder(swapToken,WETH,uint128(executionPrice),uint128(amountOut),uint128(amountOut)) (src/test/LimitOrderBook.t.sol#230-236)
Variable 'LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#228)' in LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256) (src/test/LimitOrderBook.t.sol#220-262) potentially used before declaration: assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#251-256)
Variable 'LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256).amountOut (src/test/LimitOrderBook.t.sol#299)' in LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) potentially used before declaration: order1 = newOrder(swapToken,WETH,uint128(executionPrice),uint128(amountOut),uint128(amountOut)) (src/test/LimitOrderBook.t.sol#301-307)
Variable 'LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256).amountOut1 (src/test/LimitOrderBook.t.sol#311)' in LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) potentially used before declaration: order2 = newOrder(swapToken1,WETH,uint128(executionPrice1),uint112(amountOut1),uint112(amountOut1)) (src/test/LimitOrderBook.t.sol#312-318)
Variable 'LimitOrderBookTest.testFailUpdateOrder_OrderDoesNotExist(uint256,uint256,bytes32).amountOut (src/test/LimitOrderBook.t.sol#426)' in LimitOrderBookTest.testFailUpdateOrder_OrderDoesNotExist(uint256,uint256,bytes32) (src/test/LimitOrderBook.t.sol#418-444) potentially used before declaration: order = newOrder(swapToken,WETH,uint128(amountOut),uint128(executionPrice),uint128(executionPrice)) (src/test/LimitOrderBook.t.sol#429-435)
Variable 'LimitOrderSwapRouter.getAllPrices(address,address,uint24).poolAddress (src/LimitOrderSwapRouter.sol#743)' in LimitOrderSwapRouter.getAllPrices(address,address,uint24) (src/LimitOrderSwapRouter.sol#725-790) potentially used before declaration: (spotPrice,poolAddress) = _calculateV3SpotPrice(token0,token1,FEE,dexes[i].factoryAddress) (src/LimitOrderSwapRouter.sol#760-768)
Variable 'LimitOrderSwapRouter.getAllPrices(address,address,uint24).spotPrice (src/LimitOrderSwapRouter.sol#742)' in LimitOrderSwapRouter.getAllPrices(address,address,uint24) (src/LimitOrderSwapRouter.sol#725-790) potentially used before declaration: (spotPrice,poolAddress) = _calculateV3SpotPrice(token0,token1,FEE,dexes[i].factoryAddress) (src/LimitOrderSwapRouter.sol#760-768)
Variable 'ConveyorTickMath.simulateAmountOutOnSqrtPriceX96(address,address,address,uint256,int24,uint128,uint24).step (src/lib/ConveyorTickMath.sol#144)' in ConveyorTickMath.simulateAmountOutOnSqrtPriceX96(address,address,address,uint256,int24,uint128,uint24) (src/lib/ConveyorTickMath.sol#110-215) potentially used before declaration: currentState.amountSpecifiedRemaining != 0 (src/lib/ConveyorTickMath.sol#142)
Variable 'SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128).amountOut (src/test/SandboxLimitOrderRouter.t.sol#1138)' in SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1103-1176) potentially used before declaration: validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
Variable 'LimitOrderQuoter._simulateAToBPriceChange(uint128,uint128,uint128,address,bool).amountOut (src/LimitOrderQuoter.sol#519-521)' in LimitOrderQuoter._simulateAToBPriceChange(uint128,uint128,uint128,address,bool) (src/LimitOrderQuoter.sol#478-542) potentially used before declaration: (spotPrice64x64,amountOut) = calculateNextSqrtPriceX96(isTokenToWeth,pool,alphaX) (src/LimitOrderQuoter.sol#528-531)
Variable 'TickBitmap.nextInitializedTickWithinOneWord(mapping(int16 => uint256),int24,int24,bool).bitPos (lib/libraries/Uniswap/TickBitmap.sol#57)' in TickBitmap.nextInitializedTickWithinOneWord(mapping(int16 => uint256),int24,int24,bool) (lib/libraries/Uniswap/TickBitmap.sol#46-83) potentially used before declaration: (wordPos,bitPos) = position(compressed + 1) (lib/libraries/Uniswap/TickBitmap.sol#70)
Variable 'TickBitmap.nextInitializedTickWithinOneWord(mapping(int16 => uint256),int24,int24,bool).wordPos (lib/libraries/Uniswap/TickBitmap.sol#57)' in TickBitmap.nextInitializedTickWithinOneWord(mapping(int16 => uint256),int24,int24,bool) (lib/libraries/Uniswap/TickBitmap.sol#46-83) potentially used before declaration: (wordPos,bitPos) = position(compressed + 1) (lib/libraries/Uniswap/TickBitmap.sol#70)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables

Reentrancy in LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261):
	External calls:
	- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderRouter.sol#223-224)
	State variables written after the call(s):
	- addressToOrderIds[msg.sender][order.orderId] = OrderType.CanceledLimitOrder (src/LimitOrderRouter.sol#232-233)
	- _removeOrderFromSystem(order.orderId) (src/LimitOrderRouter.sol#230)
		- delete orderIdToLimitOrder[orderId] (src/LimitOrderBook.sol#479)
	- _removeOrderFromSystem(order.orderId) (src/LimitOrderRouter.sol#230)
		- -- totalOrdersPerAddress[order.owner] (src/LimitOrderBook.sol#482)
	- _removeOrderFromSystem(order.orderId) (src/LimitOrderRouter.sol#230)
		- totalOrdersQuantity[totalOrdersValueKey] -= quantity (src/LimitOrderBook.sol#544)
Reentrancy in LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,currentBalance - REFRESH_FEE) (src/LimitOrderRouter.sol#170-173)
	State variables written after the call(s):
	- orderIdToLimitOrder[order.orderId].lastRefreshTimestamp = uint32(block.timestamp % (2 ** 32 - 1)) (src/LimitOrderRouter.sol#177-179)
Reentrancy in SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,currentCreditBalance - REFRESH_FEE) (src/SandboxLimitOrderBook.sol#648-651)
	State variables written after the call(s):
	- orderIdToSandboxLimitOrder[order.orderId].lastRefreshTimestamp = uint32(block.timestamp) (src/SandboxLimitOrderBook.sol#655-657)
Reentrancy in SandboxLimitOrderRouterTest._requireConveyorFeeIsPaid(uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1277-1317):
	External calls:
	- cheatCodes.deal(address(limitOrderExecutor),compensationAmount) (src/test/SandboxLimitOrderRouter.t.sol#1282)
	- cheatCodes.prank(address(limitOrderExecutor)) (src/test/SandboxLimitOrderRouter.t.sol#1283)
	- (depositSuccess) = address(WETH).call{value: compensationAmount}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1285-1287)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.ConveyorFeesNotPaid.selector,expectedAccumulatedFees,IERC20(WETH).balanceOf(address(limitOrderExecutor)) - contractBalancePreExecution,expectedAccumulatedFees - ((compensationAmount + contractBalancePreExecution) - contractBalancePreExecution))) (src/test/SandboxLimitOrderRouter.t.sol#1294-1304)
	- (reverted) = address(limitOrderExecutor).call(abi.encodeWithSignature(requireConveyorFeeIsPaid(uint256, uint256),uint256(contractBalancePreExecution),uint256(expectedAccumulatedFees))) (src/test/SandboxLimitOrderRouter.t.sol#1305-1311)
	External calls sending eth:
	- (depositSuccess) = address(WETH).call{value: compensationAmount}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1285-1287)
	State variables written after the call(s):
	- assertTrue(reverted) (src/test/SandboxLimitOrderRouter.t.sol#1312-1315)
		- failed = true (src/test/utils/test.sol#48)
	- assertTrue(! reverted) (src/test/SandboxLimitOrderRouter.t.sol#1312-1315)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderSwapRouter._swapV3(address,address,address,uint24,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#395-441):
	External calls:
	- IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MIN_SQRT_RATIO + 1,data) (src/LimitOrderSwapRouter.sol#425-433)
	- IUniswapV3Pool(_lp).swap(_receiver,_zeroForOne,int256(_amountIn),TickMath.MAX_SQRT_RATIO - 1,data) (src/LimitOrderSwapRouter.sol#425-433)
	State variables written after the call(s):
	- uniV3AmountOut = 0 (src/LimitOrderSwapRouter.sol#438)
Reentrancy in LimitOrderRouter.executeLimitOrders(bytes32[]) (src/LimitOrderRouter.sol#331-419):
	External calls:
	- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderRouter.sol#335-336)
	- (totalBeaconReward,totalConveyorReward) = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeTokenToWethOrders(orders) (src/LimitOrderRouter.sol#381-383)
	- (totalBeaconReward,totalConveyorReward) = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeTokenToTokenOrders(orders) (src/LimitOrderRouter.sol#386-388)
	State variables written after the call(s):
	- _resolveCompletedOrder(orderId) (src/LimitOrderRouter.sol#398)
		- delete addressToOrderIds[order.owner][orderId] (src/LimitOrderBook.sol#505)
		- addressToOrderIds[order.owner][order.orderId] = OrderType.FilledLimitOrder (src/LimitOrderBook.sol#518-519)
	- _resolveCompletedOrder(orderId) (src/LimitOrderRouter.sol#398)
		- delete orderIdToLimitOrder[orderId] (src/LimitOrderBook.sol#504)
	- _resolveCompletedOrder(orderId) (src/LimitOrderRouter.sol#398)
		- -- totalOrdersPerAddress[order.owner] (src/LimitOrderBook.sol#508)
	- _resolveCompletedOrder(orderId) (src/LimitOrderRouter.sol#398)
		- totalOrdersQuantity[totalOrdersValueKey] -= quantity (src/LimitOrderBook.sol#544)
Reentrancy in SandboxLimitOrderBook.executeOrdersViaSandboxMulticall(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderBook.sol#679-719):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeSandboxLimitOrders(preSandboxExecutionState.sandboxLimitOrders,sandboxMulticall) (src/SandboxLimitOrderBook.sol#695-698)
	State variables written after the call(s):
	- _validateSandboxExecutionAndFillOrders(sandboxMulticall.orderIdBundles,sandboxMulticall.fillAmounts,preSandboxExecutionState) (src/SandboxLimitOrderBook.sol#701-705)
		- delete addressToOrderIds[order.owner][orderId] (src/SandboxLimitOrderBook.sol#1260)
		- addressToOrderIds[order.owner][order.orderId] = OrderType.PartialFilledSandboxLimitOrder (src/SandboxLimitOrderBook.sol#1212-1213)
		- addressToOrderIds[order.owner][order.orderId] = OrderType.FilledSandboxLimitOrder (src/SandboxLimitOrderBook.sol#1273-1274)
	- _validateSandboxExecutionAndFillOrders(sandboxMulticall.orderIdBundles,sandboxMulticall.fillAmounts,preSandboxExecutionState) (src/SandboxLimitOrderBook.sol#701-705)
		- -- totalOrdersPerAddress[order.owner] (src/SandboxLimitOrderBook.sol#1263)
	- _validateSandboxExecutionAndFillOrders(sandboxMulticall.orderIdBundles,sandboxMulticall.fillAmounts,preSandboxExecutionState) (src/SandboxLimitOrderBook.sol#701-705)
		- totalOrdersQuantity[totalOrdersValueKey] -= quantity (src/SandboxLimitOrderBook.sol#1287)
Reentrancy in LimitOrderExecutor.executeTokenToTokenOrders(LimitOrderBook.LimitOrder[]) (src/LimitOrderExecutor.sol#492-570):
	External calls:
	- _transferBeaconReward(totalBeaconReward,tx.origin,WETH) (src/LimitOrderExecutor.sol#565)
		- IWETH(weth).withdraw(totalBeaconReward) (src/LimitOrderSwapRouter.sol#275)
	State variables written after the call(s):
	- conveyorBalance += totalConveyorReward (src/LimitOrderExecutor.sol#567)
Reentrancy in LimitOrderExecutor.executeTokenToWethOrders(LimitOrderBook.LimitOrder[]) (src/LimitOrderExecutor.sol#334-400):
	External calls:
	- _transferBeaconReward(totalBeaconReward,tx.origin,WETH) (src/LimitOrderExecutor.sol#394)
		- IWETH(weth).withdraw(totalBeaconReward) (src/LimitOrderSwapRouter.sol#275)
	State variables written after the call(s):
	- conveyorBalance += totalConveyorReward (src/LimitOrderExecutor.sol#397)
Reentrancy in LimitOrderBook.placeLimitOrder(LimitOrderBook.LimitOrder[]) (src/LimitOrderBook.sol#173-299):
	External calls:
	- _checkSufficientGasCreditsForOrderPlacement(orderGroup.length) (src/LimitOrderBook.sol#178)
		- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderBook.sol#307-308)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/LimitOrderBook.sol#334-337)
	State variables written after the call(s):
	- addressToAllOrderIds[msg.sender].push(orderId) (src/LimitOrderBook.sol#266)
	- addressToOrderIds[msg.sender][orderId] = OrderType.PendingLimitOrder (src/LimitOrderBook.sol#256-257)
	- orderIdToLimitOrder[orderId] = newOrder (src/LimitOrderBook.sol#253)
	- orderNonce += 2 (src/LimitOrderBook.sol#239)
	- _updateTotalOrdersQuantity(orderToken,msg.sender,updatedTotalOrdersValue) (src/LimitOrderBook.sol#274-278)
		- totalOrdersQuantity[totalOrdersValueKey] = newQuantity (src/LimitOrderBook.sol#557)
Reentrancy in SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394):
	External calls:
	- _checkSufficientGasCreditsForOrderPlacement(orderGroup.length) (src/SandboxLimitOrderBook.sol#219)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/SandboxLimitOrderBook.sol#1335-1338)
	State variables written after the call(s):
	- addressToAllOrderIds[msg.sender].push(orderId) (src/SandboxLimitOrderBook.sol#361)
	- addressToOrderIds[msg.sender][orderId] = OrderType.PendingSandboxLimitOrder (src/SandboxLimitOrderBook.sol#351-352)
	- orderIdToSandboxLimitOrder[orderId] = newOrder (src/SandboxLimitOrderBook.sol#348)
	- orderNonce += 2 (src/SandboxLimitOrderBook.sol#334)
	- _updateTotalOrdersQuantity(orderToken,msg.sender,updatedTotalOrdersValue) (src/SandboxLimitOrderBook.sol#369-373)
		- totalOrdersQuantity[totalOrdersValueKey] = newQuantity (src/SandboxLimitOrderBook.sol#1300)
Reentrancy in ConveyorGasOracleTest.setUp() (src/test/ConveyorGasOracle.t.sol#44-52):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/ConveyorGasOracle.t.sol#47)
	- cheatCodes.rollFork(forkId,15233771) (src/test/ConveyorGasOracle.t.sol#48)
	State variables written after the call(s):
	- gasOracle = new ConveyorGasOracle(aggregatorV3Address) (src/test/ConveyorGasOracle.t.sol#50)
Reentrancy in SandboxLimitOrderBookTest.setUp() (src/test/SandboxLimitOrderBook.t.sol#84-123):
	External calls:
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#88)
	State variables written after the call(s):
	- limitOrderExecutor = new LimitOrderExecutor(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,250000) (src/test/SandboxLimitOrderBook.t.sol#94-104)
	- limitOrderQuoter = new LimitOrderQuoter(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) (src/test/SandboxLimitOrderBook.t.sol#90-92)
	- sandboxLimitOrderBook = ISandboxLimitOrderBook(limitOrderExecutor.SANDBOX_LIMIT_ORDER_BOOK()) (src/test/SandboxLimitOrderBook.t.sol#113-115)
	- sandboxLimitOrderBookWrapper = new SandboxLimitOrderBookWrapper(aggregatorV3Address,address(limitOrderExecutor),0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,250000) (src/test/SandboxLimitOrderBook.t.sol#105-111)
Reentrancy in LimitOrderBookTest.setUp() (src/test/LimitOrderBook.t.sol#71-98):
	External calls:
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderBook.t.sol#75)
	State variables written after the call(s):
	- limitOrderExecutor = new LimitOrderExecutor(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,250000) (src/test/LimitOrderBook.t.sol#81-91)
	- limitOrderQuoter = new LimitOrderQuoter(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) (src/test/LimitOrderBook.t.sol#77-79)
	- orderBook = ILimitOrderBook(limitOrderExecutor.LIMIT_ORDER_ROUTER()) (src/test/LimitOrderBook.t.sol#94)
Reentrancy in SwapRouterTest.setUp() (src/test/SwapRouter.t.sol#87-102):
	External calls:
	- cheatCodes.makePersistent(address(limitOrderExecutor)) (src/test/SwapRouter.t.sol#96)
	State variables written after the call(s):
	- swapHelper = new Swap(_uniV2Address,WETH) (src/test/SwapRouter.t.sol#101)
	- uniV2Factory = IUniswapV2Factory(_uniV2FactoryAddress) (src/test/SwapRouter.t.sol#99)
	- uniV2Router = IUniswapV2Router02(_uniV2Address) (src/test/SwapRouter.t.sol#98)
Reentrancy in LimitOrderQuoterTest.setUp() (src/test/LimitOrderQuoter.t.sol#110-121):
	External calls:
	- cheatCodes.makePersistent(address(limitOrderQuoter)) (src/test/LimitOrderQuoter.t.sol#119)
	State variables written after the call(s):
	- iQuoter = IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6) (src/test/LimitOrderQuoter.t.sol#120)
Reentrancy in ConveyorSwapAggregatorTest.setUp() (src/test/ConveyorSwapAggregator.t.sol#32-52):
	External calls:
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/ConveyorSwapAggregator.t.sol#39)
	State variables written after the call(s):
	- conveyorSwapAggregator = IConveyorSwapAggregator(address(new ConveyorSwapAggregator())) (src/test/ConveyorSwapAggregator.t.sol#41-43)
Reentrancy in SwapRouterTest.testCalculateFee(uint112) (src/test/SwapRouter.t.sol#333-368):
	External calls:
	- output = scriptRunner.runPythonScript(path,args) (src/test/SwapRouter.t.sol#360)
	State variables written after the call(s):
	- assertEq(fee / 10000,expected / 10000) (src/test/SwapRouter.t.sol#366)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271):
	External calls:
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#209)
	- swapHelper.swapEthForTokenWithUniV2(20000000000000000000000,swapToken) (src/test/LimitOrderExecutor.t.sol#210)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#211)
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#231)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#232)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#234)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- placeMockOrder(order1) (src/test/LimitOrderExecutor.t.sol#235)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#232)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertEq(expected / 100,minGasCredits) (src/test/LimitOrderExecutor.t.sol#266)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateOrderRewardBeacon(uint64) (src/test/SwapRouter.t.sol#397-425):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/SwapRouter.t.sol#419)
	State variables written after the call(s):
	- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#423)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in ConveyorFeeMathTest.testCalculateOrderRewardBeacon(uint64) (src/test/ConveyorFeeMath.t.sol#79-107):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/ConveyorFeeMath.t.sol#101)
	State variables written after the call(s):
	- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#105)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateOrderRewardConveyor(uint64) (src/test/SwapRouter.t.sol#428-456):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/SwapRouter.t.sol#450)
	State variables written after the call(s):
	- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#454)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in ConveyorFeeMathTest.testCalculateOrderRewardConveyor(uint64) (src/test/ConveyorFeeMath.t.sol#110-138):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/ConveyorFeeMath.t.sol#132)
	State variables written after the call(s):
	- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#136)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV2SpotSushiTest1() (src/test/SwapRouter.t.sol#116-145):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#117)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#118)
	State variables written after the call(s):
	- assertEq(priceWethUsdc.spotPrice,593525979047872548219266386638161406066688) (src/test/SwapRouter.t.sol#141-144)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV2SpotSushiTest2() (src/test/SwapRouter.t.sol#148-168):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#149)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#150)
	State variables written after the call(s):
	- assertEq(priceWethKope.spotPrice,9457943135647822527192493517503987712) (src/test/SwapRouter.t.sol#164-167)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV2SpotSushiTest3() (src/test/SwapRouter.t.sol#171-188):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#172)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#173)
	State variables written after the call(s):
	- assertEq(priceOhmDai.spotPrice,21888402763315038097036358416236281856) (src/test/SwapRouter.t.sol#187)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV2SpotUni1() (src/test/SwapRouter.t.sol#236-256):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#237)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#238)
	State variables written after the call(s):
	- assertEq(spotPriceWethUsdc,195241231237127088630569907242663936) (src/test/SwapRouter.t.sol#255)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV2SpotUni2() (src/test/SwapRouter.t.sol#259-279):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#260)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#261)
	State variables written after the call(s):
	- assertEq(spotPriceDaiUsdc.spotPrice,340481350396253814427678140089094897664) (src/test/SwapRouter.t.sol#275-278)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV2SpotUni3() (src/test/SwapRouter.t.sol#282-302):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#283)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#284)
	State variables written after the call(s):
	- assertEq(spotPriceWethWax.spotPrice,20238613147511897623021403873923301376) (src/test/SwapRouter.t.sol#298-301)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV3SpotPrice1() (src/test/SwapRouter.t.sol#191-209):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#192)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#193)
	- (priceDaiWeth,poolAddressDaiWeth) = limitOrderExecutor.calculateV3SpotPrice(dai,weth,3000,_uniV3FactoryAddress) (src/test/SwapRouter.t.sol#198-206)
	State variables written after the call(s):
	- assertEq(priceDaiWeth.spotPrice,195219315785396777134689842230198271) (src/test/SwapRouter.t.sol#208)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SwapRouterTest.testCalculateV3SpotPrice2() (src/test/SwapRouter.t.sol#212-233):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#213)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#214)
	- (priceDaiUsdc) = limitOrderExecutor.calculateV3SpotPrice(dai,usdc,3000,_uniV3FactoryAddress) (src/test/SwapRouter.t.sol#220-228)
	State variables written after the call(s):
	- assertEq(priceDaiUsdc.spotPrice,341140785248087661355983754903316070398) (src/test/SwapRouter.t.sol#229-232)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#522)
	- IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#523-526)
	- swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#529-585)
	- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#549-550)
	State variables written after the call(s):
	- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#556-561)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#563-566)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#522)
	- IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#523-526)
	- swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#529-585)
	- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#549-550)
	- sandboxLimitOrderBook.cancelOrder(orderId) (src/test/SandboxLimitOrderBook.t.sol#567)
	State variables written after the call(s):
	- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),0) (src/test/SandboxLimitOrderBook.t.sol#574-579)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),0) (src/test/SandboxLimitOrderBook.t.sol#581-584)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrderBatch() (src/test/SandboxLimitOrderRouter.t.sol#459-538):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#461)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#462)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#465)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- (multiCall,orders,orderIds) = createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#467-471)
		- cheatCodes.prank(mockOwner1) (src/test/SandboxLimitOrderRouter.t.sol#1852)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1853)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1810-1812)
		- cheatCodes.prank(mockOwner1) (src/test/SandboxLimitOrderRouter.t.sol#1854)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1855)
		- cheatCodes.prank(mockOwner2) (src/test/SandboxLimitOrderRouter.t.sol#1867)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1868)
		- cheatCodes.prank(mockOwner2) (src/test/SandboxLimitOrderRouter.t.sol#1869)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1870)
		- cheatCodes.prank(mockOwner3) (src/test/SandboxLimitOrderRouter.t.sol#1881)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1882)
		- cheatCodes.prank(mockOwner3) (src/test/SandboxLimitOrderRouter.t.sol#1883)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1884)
		- cheatCodes.prank(mockOwner4) (src/test/SandboxLimitOrderRouter.t.sol#1895)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1896)
		- cheatCodes.prank(mockOwner4) (src/test/SandboxLimitOrderRouter.t.sol#1897)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1898)
		- cheatCodes.prank(mockOwner5) (src/test/SandboxLimitOrderRouter.t.sol#1909)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1910)
		- cheatCodes.prank(mockOwner5) (src/test/SandboxLimitOrderRouter.t.sol#1911)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1912)
		- cheatCodes.prank(mockOwner6) (src/test/SandboxLimitOrderRouter.t.sol#1924)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1925)
		- cheatCodes.prank(mockOwner6) (src/test/SandboxLimitOrderRouter.t.sol#1926)
		- IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1927)
		- cheatCodes.prank(mockOwner7) (src/test/SandboxLimitOrderRouter.t.sol#1938)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1939)
		- cheatCodes.prank(mockOwner7) (src/test/SandboxLimitOrderRouter.t.sol#1940)
		- IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1941)
		- cheatCodes.prank(mockOwner8) (src/test/SandboxLimitOrderRouter.t.sol#1953)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1954)
		- cheatCodes.prank(mockOwner8) (src/test/SandboxLimitOrderRouter.t.sol#1955)
		- IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1956)
		- cheatCodes.deal(address(mockOwner9),1000000000000000000000000) (src/test/SandboxLimitOrderRouter.t.sol#1968)
		- cheatCodes.prank(mockOwner9) (src/test/SandboxLimitOrderRouter.t.sol#1969)
		- IERC20(WETH).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1970)
		- cheatCodes.prank(mockOwner9) (src/test/SandboxLimitOrderRouter.t.sol#1973)
		- (success) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1975-1977)
		- cheatCodes.deal(address(mockOwner10),1000000000000000000000000) (src/test/SandboxLimitOrderRouter.t.sol#1990)
		- cheatCodes.prank(mockOwner10) (src/test/SandboxLimitOrderRouter.t.sol#1991)
		- IERC20(WETH).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1992)
		- cheatCodes.prank(mockOwner10) (src/test/SandboxLimitOrderRouter.t.sol#1995)
		- (depositSuccess) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1997-1999)
		- cheatCodes.prank(mockOwner1) (src/test/SandboxLimitOrderRouter.t.sol#2013)
		- cheatCodes.prank(mockOwner2) (src/test/SandboxLimitOrderRouter.t.sol#2015)
		- cheatCodes.prank(mockOwner3) (src/test/SandboxLimitOrderRouter.t.sol#2017)
		- cheatCodes.prank(mockOwner4) (src/test/SandboxLimitOrderRouter.t.sol#2019)
		- cheatCodes.prank(mockOwner5) (src/test/SandboxLimitOrderRouter.t.sol#2021)
		- cheatCodes.prank(mockOwner6) (src/test/SandboxLimitOrderRouter.t.sol#2023)
		- cheatCodes.prank(mockOwner7) (src/test/SandboxLimitOrderRouter.t.sol#2025)
		- cheatCodes.prank(mockOwner8) (src/test/SandboxLimitOrderRouter.t.sol#2027)
		- cheatCodes.prank(mockOwner9) (src/test/SandboxLimitOrderRouter.t.sol#2029)
		- cheatCodes.prank(mockOwner10) (src/test/SandboxLimitOrderRouter.t.sol#2031)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#475-481)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#488)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#491)
	External calls sending eth:
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#465)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- (multiCall,orders,orderIds) = createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#467-471)
		- (success) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1975-1977)
		- (depositSuccess) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1997-1999)
	State variables written after the call(s):
	- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#494-497)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(order.amountInRemaining,orders[i].amountInRemaining - multiCall.fillAmounts[i]) (src/test/SandboxLimitOrderRouter.t.sol#516-519)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(order.amountOutRemaining,orders[i].amountOutRemaining - ConveyorMath.mul64U(ConveyorMath.divUU(orders[i].amountOutRemaining,orders[i].amountInRemaining),multiCall.fillAmounts[i])) (src/test/SandboxLimitOrderRouter.t.sol#521-531)
		- failed = true (src/test/utils/test.sol#48)
	- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#536)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#216)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#217)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#219)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#221)
	- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#223)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#235)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- orderIds[0] = placeMockOrder(order) (src/test/SandboxLimitOrderRouter.t.sol#254)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1810-1812)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#293-299)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#305)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#308)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#219)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#235)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	State variables written after the call(s):
	- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#311-314)
		- failed = true (src/test/utils/test.sol#48)
	- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#327)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#334)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#335)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#337)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#339)
	- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#341)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#343)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- orderIds[0] = placeMockOrder(order) (src/test/SandboxLimitOrderRouter.t.sol#368)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1810-1812)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#415-421)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#428)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#431)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#337)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#343)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	State variables written after the call(s):
	- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#434-437)
		- failed = true (src/test/utils/test.sol#48)
	- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#452)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrdersSameOwnerBundleInputToken() (src/test/SandboxLimitOrderRouter.t.sol#541-679):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#543)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#544)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#546)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#548)
	- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#550)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#552)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- orderIds = placeMultipleMockOrder(orders) (src/test/SandboxLimitOrderRouter.t.sol#561)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1841-1843)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#643-649)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#656)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#659)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#546)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#552)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	State variables written after the call(s):
	- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#662-665)
		- failed = true (src/test/utils/test.sol#48)
	- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#677)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1211)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1212)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelperUniV2),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1213)
	- swapHelperUniV2.swapEthForTokenWithUniV2(10000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1214)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1216)
	- orderBatch = placeNewMockTaxedToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1218)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1232)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1236)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1237)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1212)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1245-1248)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1259)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1260)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1261)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1262)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1264)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1285)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1292)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1304)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1305)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1260)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1310)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1313-1316)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1163)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1164)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelperUniV2),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1165)
	- swapHelperUniV2.swapEthForTokenWithUniV2(10000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1166)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1168)
	- orderBatch = placeNewMockTaxedToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1170)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1184)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1188)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1189)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1164)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1197-1200)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1095)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1096)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1097)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1098)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1100)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1121)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1128)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1140)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1141)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1096)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1146)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1149-1152)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#981)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#982)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#983)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#985)
	- tokenToWethOrderBatch = placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#987-988)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1702)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1002)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1006)
	- limitOrderRouter.executeLimitOrders(tokenToWethOrderBatch) (src/test/LimitOrderExecutor.t.sol#1007)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#982)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1015-1018)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#907)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#908)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#910)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#911)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#913)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#932)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#945)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#957)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#958)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#908)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#963)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#966-969)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1029)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1030)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1031)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1032)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1034)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1053)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1060)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1072)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1073)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1030)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1078)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1081-1084)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#683-729):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#684)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#685)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#686)
	- IERC20(USDC).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#688)
	- tokenToTokenOrderBatch = placeNewMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#690-691)
		- swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2747)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#706)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#710)
	- limitOrderRouter.executeLimitOrders(tokenToTokenOrderBatch) (src/test/LimitOrderExecutor.t.sol#711)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#685)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#716)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#719-722)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#568)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#569)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#570)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#571)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#572)
	- (spRes) = limitOrderExecutor.calculateV3SpotPrice(DAI,UNI,500,0x1F98431c8aD98523631AE4a59f267346ea31F984) (src/test/LimitOrderExecutor.t.sol#574-580)
	- orderId = placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#618)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#638)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#650)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#651)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#569)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#658-661)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#663)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#665-668)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#391)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#392)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#393)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#394)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#395)
	- (spRes) = limitOrderExecutor.calculateV3SpotPrice(DAI,WETH,500,0x1F98431c8aD98523631AE4a59f267346ea31F984) (src/test/LimitOrderExecutor.t.sol#398-404)
	- orderId = placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#433)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#456)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#468)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#469)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#392)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#476-479)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#481)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#483-486)
		- failed = true (src/test/utils/test.sol#48)
	- assertLe(gasCompensationAfter - gasCompensationBefore,executionCostUpper * gasPrice) (src/test/LimitOrderExecutor.t.sol#487-490)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#853)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#854)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#855)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#857-859)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#863)
	- wethToTaxedOrderBatch = placeNewMockWethToTaxedBatch() (src/test/LimitOrderExecutor.t.sol#865)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#880)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#884)
	- limitOrderRouter.executeLimitOrders(wethToTaxedOrderBatch) (src/test/LimitOrderExecutor.t.sol#885)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#854)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#857-859)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#890)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#893-896)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#739)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#740)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#741)
	- address(WETH).call{value: amountIn}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#743-745)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#747)
	- orderId = placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#794)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#807)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#819)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#820)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#740)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- address(WETH).call{value: amountIn}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#743-745)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#827-830)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#832)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#834-837)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#505)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#507)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#509)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#512-514)
	- IERC20(WETH).approve(address(limitOrderExecutor),5000000000000000000000000000) (src/test/LimitOrderExecutor.t.sol#519)
	- tokenToWethOrderBatch = placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#521)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#536)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#540)
	- limitOrderRouter.executeLimitOrders(tokenToWethOrderBatch) (src/test/LimitOrderExecutor.t.sol#541)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#507)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#512-514)
	State variables written after the call(s):
	- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#546)
		- failed = true (src/test/utils/test.sol#48)
	- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 6) (src/test/LimitOrderExecutor.t.sol#549-552)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderExecutorTest.testFailMinGasCredits() (src/test/LimitOrderExecutor.t.sol#169-205):
	External calls:
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#170)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#171)
	- swapHelper.swapEthForTokenWithUniV2(2000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#174)
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#191)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#192)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#194)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#192)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	State variables written after the call(s):
	- assertTrue(hasMinGasCredits) (src/test/LimitOrderExecutor.t.sol#204)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256) (src/test/LimitOrderBook.t.sol#220-262):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#224)
	- swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#227-261)
	- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#245)
	State variables written after the call(s):
	- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#251-256)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#258)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderRouterTest.testFailValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#278-306):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderRouter.t.sol#287)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#289)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#291-293)
	- orderId = placeMockOrder(order) (src/test/LimitOrderRouter.t.sol#296)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderRouter.t.sol#537)
	- canceled = limitOrderRouter.validateAndCancelOrder(orderId) (src/test/LimitOrderRouter.t.sol#298)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#289)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#291-293)
	State variables written after the call(s):
	- assertTrue(! canceled) (src/test/LimitOrderRouter.t.sol#299)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testFailValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#669-696):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#673)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#675)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#677)
		- cheatCodes.deal(address(this),_amount) (src/test/SandboxLimitOrderBook.t.sol#745)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#679-681)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#684)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- canceled = sandboxLimitOrderBook.validateAndCancelOrder(orderId) (src/test/SandboxLimitOrderBook.t.sol#686)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#677)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#679-681)
	State variables written after the call(s):
	- assertTrue(! canceled) (src/test/SandboxLimitOrderBook.t.sol#687)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in ConveyorTickMathTest.testFromSqrtX96() (src/test/ConveyorTickMath.t.sol#255-281):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/ConveyorTickMath.t.sol#256)
	- cheatCodes.rollFork(forkId,15233771) (src/test/ConveyorTickMath.t.sol#257)
	State variables written after the call(s):
	- assertEq(194786572365129798010721349067079679,priceUSDC) (src/test/ConveyorTickMath.t.sol#279)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(594456218574771757927683806232862281426471,priceWETH) (src/test/ConveyorTickMath.t.sol#280)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderBookTest.testGetLimitOrderById() (src/test/LimitOrderBook.t.sol#101-127):
	External calls:
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#102)
	- swapHelper.swapEthForTokenWithUniV2(20000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#104)
	- orderId = placeMockOrder(order) (src/test/LimitOrderBook.t.sol#115)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	State variables written after the call(s):
	- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/LimitOrderBook.t.sol#122)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/LimitOrderBook.t.sol#123)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(returnedOrder.orderId,orderId) (src/test/LimitOrderBook.t.sol#124)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(returnedOrder.price,order.price) (src/test/LimitOrderBook.t.sol#125)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(returnedOrder.quantity,order.quantity) (src/test/LimitOrderBook.t.sol#126)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testGetOrderIds() (src/test/SandboxLimitOrderBook.t.sol#158-199):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#159)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#160)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#162)
	- orderId1 = placeMockSandboxLimitOrder(newSandboxLimitOrder(swapToken,WETH,10e21,uint112(1))) (src/test/SandboxLimitOrderBook.t.sol#164-166)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- orderId2 = placeMockSandboxLimitOrder(newSandboxLimitOrder(swapToken,WETH,10e21,uint112(1))) (src/test/SandboxLimitOrderBook.t.sol#168-170)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- sandboxLimitOrderBook.cancelOrder(orderId2) (src/test/SandboxLimitOrderBook.t.sol#172)
	State variables written after the call(s):
	- assertEq(pendingSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#194)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(canceledSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#195)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(pendingSandboxLimitOrders[0],orderId1) (src/test/SandboxLimitOrderBook.t.sol#197)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(canceledSandboxLimitOrders[0],orderId2) (src/test/SandboxLimitOrderBook.t.sol#198)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderBookTest.testGetOrderIds() (src/test/LimitOrderBook.t.sol#179-217):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#180)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#181)
	- swapHelper.swapEthForTokenWithUniV2(10000,swapToken) (src/test/LimitOrderBook.t.sol#183)
	- orderId1 = placeMockOrder(newOrder(swapToken,WETH,uint128(1),uint112(1),uint112(1))) (src/test/LimitOrderBook.t.sol#186-188)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	- orderId2 = placeMockOrder(newOrder(swapToken,WETH,uint128(1),uint112(1),uint112(1))) (src/test/LimitOrderBook.t.sol#190-192)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	- orderBook.cancelOrder(orderId2) (src/test/LimitOrderBook.t.sol#194)
	State variables written after the call(s):
	- assertEq(pendingLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#212)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(canceledLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#213)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(pendingLimitOrders[0],orderId1) (src/test/LimitOrderBook.t.sol#215)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(canceledLimitOrders[0],orderId2) (src/test/LimitOrderBook.t.sol#216)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testGetSandboxLimitOrderById() (src/test/SandboxLimitOrderBook.t.sol#132-151):
	External calls:
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#133)
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#135)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#141)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	State variables written after the call(s):
	- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/SandboxLimitOrderBook.t.sol#148)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/SandboxLimitOrderBook.t.sol#149)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(returnedOrder.orderId,orderId) (src/test/SandboxLimitOrderBook.t.sol#150)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderBookTest.testGetTotalOrdersValue() (src/test/LimitOrderBook.t.sol#529-547):
	External calls:
	- swapHelper.swapEthForTokenWithUniV2(20000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#530)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#531)
	- placeMockOrder(order) (src/test/LimitOrderBook.t.sol#543)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	State variables written after the call(s):
	- assertEq(5,totalOrdersValue) (src/test/LimitOrderBook.t.sol#546)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1026)
	- cheatCodes.deal(address(swapHelper),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1027)
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- cheatCodes.deal(address(this),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1031)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	- IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1038)
	- orderIds[0] = placeMockOrderWrapper(orderWeth) (src/test/SandboxLimitOrderRouter.t.sol#1055)
		- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1830-1831)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.FillAmountSpecifiedGreaterThanAmountRemaining.selector,fillAmountWeth,wethQuantity,orderIds[0])) (src/test/SandboxLimitOrderRouter.t.sol#1063-1072)
	- (reverted) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(initializePreSandboxExecutionState(bytes32[][],uint128[]),orderIdBundles,fillAmounts)) (src/test/SandboxLimitOrderRouter.t.sol#1073-1080)
	External calls sending eth:
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	State variables written after the call(s):
	- assertTrue(reverted) (src/test/SandboxLimitOrderRouter.t.sol#1081)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1026)
	- cheatCodes.deal(address(swapHelper),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1027)
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- cheatCodes.deal(address(this),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1031)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	- IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1038)
	- orderIds[0] = placeMockOrderWrapper(orderWeth) (src/test/SandboxLimitOrderRouter.t.sol#1055)
		- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1830-1831)
	External calls sending eth:
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	State variables written after the call(s):
	- assertEq(preSandboxExecutionState.initialTokenInBalances[0],wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1090-1093)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(preSandboxExecutionState.initialTokenOutBalances[0],0) (src/test/SandboxLimitOrderRouter.t.sol#1094-1097)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#324)
	- IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#325-328)
	- swapHelper.swapEthForTokenWithUniV2(amountIn,swapToken) (src/test/SandboxLimitOrderBook.t.sol#333-396)
	- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#353-354)
	- sandboxLimitOrderBookWrapper.partialFillSandboxLimitOrder(uint128(amountOutTokenIn / amountInDivisor),amountOut / amountOutDivisor,orderId) (src/test/SandboxLimitOrderBook.t.sol#359-363)
	State variables written after the call(s):
	- assertEq(totalQuantityBefore - totalOrdersQuantityAfter,amountOutTokenIn / amountInDivisor) (src/test/SandboxLimitOrderBook.t.sol#371-374)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(orderPostPartialFill.fillPercent,ConveyorMath.fromX64ToX16(ConveyorMath.divUU(uint128(amountOutTokenIn / amountInDivisor),uint128(amountOutTokenIn)))) (src/test/SandboxLimitOrderBook.t.sol#376-384)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(orderPostPartialFill.amountInRemaining,(uint128(amountOutTokenIn)) - uint128(amountOutTokenIn / amountInDivisor)) (src/test/SandboxLimitOrderBook.t.sol#386-390)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(orderPostPartialFill.amountOutRemaining,amountOut - amountOut / amountOutDivisor) (src/test/SandboxLimitOrderBook.t.sol#392-395)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderBookTest.testPlaceOrder(uint256,uint256) (src/test/LimitOrderBook.t.sol#135-177):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#136)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#137)
	- swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#140-176)
	- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#158)
	State variables written after the call(s):
	- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#168-173)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#175)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112) (src/test/SandboxLimitOrderBook.t.sol#401-457):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#405)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#406)
	- swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#409-455)
	- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#432-433)
	State variables written after the call(s):
	- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#444-449)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#451-454)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderQuoterTest.testSimulateAToBPriceChangeV2ReserveOutputs(uint112) (src/test/LimitOrderQuoter.t.sol#172-213):
	External calls:
	- (reserveA,reserveB) = limitOrderQuoter.simulateAToBPriceChange(_amountIn,reserveAIn,reserveBIn,pool,true) (src/test/LimitOrderQuoter.t.sol#186-193)
	- outputReserveB = scriptRunner.runPythonScript(path,args) (src/test/LimitOrderQuoter.t.sol#199-202)
	State variables written after the call(s):
	- assertEq(reserveA,expectedReserveA) (src/test/LimitOrderQuoter.t.sol#207)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(reserveB / 10 ** 9,expectedReserveB / 10 ** 9) (src/test/LimitOrderQuoter.t.sol#210)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderQuoterTest.testSimulateAToBPriceChangeV2SpotPrice(uint64) (src/test/LimitOrderQuoter.t.sol#216-247):
	External calls:
	- (spotPrice) = limitOrderQuoter.simulateAToBPriceChange(_amountIn,reserveAIn,reserveBIn,pool,true) (src/test/LimitOrderQuoter.t.sol#228-235)
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/LimitOrderQuoter.t.sol#241)
	State variables written after the call(s):
	- assertEq(spotPrice >> 75,spotPriceExpected >> 75) (src/test/LimitOrderQuoter.t.sol#244)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderQuoterTest.testSimulateAToWethPriceChangeV2() (src/test/LimitOrderQuoter.t.sol#360-384):
	External calls:
	- (newSpotPriceA,amountOut) = limitOrderQuoter.simulateAToWethPriceChange(50000000000000000000000,tokenToTokenExecutionPrice) (src/test/LimitOrderQuoter.t.sol#377-381)
	State variables written after the call(s):
	- assertEq(newSpotPriceA,192714735056741134836410079523110912) (src/test/LimitOrderQuoter.t.sol#382)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(amountOut,28408586008574759898) (src/test/LimitOrderQuoter.t.sol#383)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96CrossTick(uint112) (src/test/ConveyorTickMath.t.sol#203-252):
	External calls:
	- amountOutToValidate = uint256(- conveyorTickMath._simulateAmountOutOnSqrtPriceX96(token0,WETH,usdcWethPoolV3,_alphaX,tickSpacing,liquidity,500)) (src/test/ConveyorTickMath.t.sol#228-238)
	- amountOutExpected = iQuoter.quoteExactInputSingle(WETH,USDC,500,_alphaX,TickMath.MAX_SQRT_RATIO - 1) (src/test/ConveyorTickMath.t.sol#241-247)
	State variables written after the call(s):
	- assertEq(amountOutToValidate,amountOutExpected) (src/test/ConveyorTickMath.t.sol#250)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneFalse(uint64) (src/test/ConveyorTickMath.t.sol#111-155):
	External calls:
	- amountOutExpected = iQuoter.quoteExactInputSingle(WETH,DAI,3000,_alphaX,TickMath.MAX_SQRT_RATIO - 1) (src/test/ConveyorTickMath.t.sol#126-132)
	- amountOutToValidate = uint256(- conveyorTickMath._simulateAmountOutOnSqrtPriceX96(token0,WETH,daiWethPoolV3,_alphaX,tickSpacing,liquidity,3000)) (src/test/ConveyorTickMath.t.sol#133-143)
	State variables written after the call(s):
	- assertEq(int256(amountOutToValidate) / 100,int256(amountOutExpected) / 100) (src/test/ConveyorTickMath.t.sol#147-150)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneTrue(uint72) (src/test/ConveyorTickMath.t.sol#159-199):
	External calls:
	- amountOutExpected = iQuoter.quoteExactInputSingle(DAI,WETH,3000,_alphaX,TickMath.MIN_SQRT_RATIO + 1) (src/test/ConveyorTickMath.t.sol#174-180)
	- amountOutToValidate = uint256(- conveyorTickMath._simulateAmountOutOnSqrtPriceX96(token0,DAI,daiWethPoolV3,_alphaX,tickSpacing,liquidity,3000)) (src/test/ConveyorTickMath.t.sol#183-193)
	State variables written after the call(s):
	- assertEq(amountOutToValidate / 100,amountOutExpected / 100) (src/test/ConveyorTickMath.t.sol#196)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneFalse(uint64) (src/test/LimitOrderQuoter.t.sol#290-329):
	External calls:
	- amountOut = iQuoter.quoteExactInputSingle(WETH,tokenOut,3000,_alphaX,sqrtPriceLimitX96) (src/test/LimitOrderQuoter.t.sol#311-317)
	- amountOutMin = limitOrderQuoter.calculateAmountOutMinAToWeth(poolAddress,_alphaX,0,3000,WETH) (src/test/LimitOrderQuoter.t.sol#318-325)
	State variables written after the call(s):
	- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#327)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneTrue(uint64) (src/test/LimitOrderQuoter.t.sol#249-288):
	External calls:
	- amountOut = iQuoter.quoteExactInputSingle(tokenIn,WETH,3000,_alphaX,sqrtPriceLimitX96) (src/test/LimitOrderQuoter.t.sol#270-276)
	- amountOutMin = limitOrderQuoter.calculateAmountOutMinAToWeth(poolAddress,_alphaX,0,3000,tokenIn) (src/test/LimitOrderQuoter.t.sol#277-284)
	State variables written after the call(s):
	- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#286)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderQuoterTest.testSimulateWethToBPriceChangeV2() (src/test/LimitOrderQuoter.t.sol#333-356):
	External calls:
	- (newSpotPriceB) = limitOrderQuoter.simulateWethToBPriceChange(5000000000000000000,tokenToTokenExecutionPrice) (src/test/LimitOrderQuoter.t.sol#350-354)
	State variables written after the call(s):
	- assertEq(newSpotPriceB,63714967732803596813954797656252367241216) (src/test/LimitOrderQuoter.t.sol#355)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderBookTest.testUpdateOrder(uint128,uint64,uint128,uint128,uint64) (src/test/LimitOrderBook.t.sol#338-386):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#352)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#353)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderBook.t.sol#355)
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#356)
	- orderId = placeMockOrder(order) (src/test/LimitOrderBook.t.sol#368)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	- orderBook.updateOrder(orderId,newPrice,newQuantity) (src/test/LimitOrderBook.t.sol#371)
	State variables written after the call(s):
	- assertEq(newQuantity,totalOrdersValueAfter) (src/test/LimitOrderBook.t.sol#382)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(newQuantity,updatedOrder.quantity) (src/test/LimitOrderBook.t.sol#383)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(newPrice,updatedOrder.price) (src/test/LimitOrderBook.t.sol#384)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testUpdateSandboxOrder(uint128,uint128) (src/test/SandboxLimitOrderBook.t.sol#589-636):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#593)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#594)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#596)
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#597)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#613)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- sandboxLimitOrderBook.updateSandboxLimitOrder(orderId,newAmountInRemaining,newAmountOutRemaining) (src/test/SandboxLimitOrderBook.t.sol#616-620)
	State variables written after the call(s):
	- assertEq(newAmountInRemaining,totalOrdersValueAfter) (src/test/SandboxLimitOrderBook.t.sol#633)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(newAmountInRemaining,updatedOrder.amountInRemaining) (src/test/SandboxLimitOrderBook.t.sol#634)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(newAmountOutRemaining,updatedOrder.amountOutRemaining) (src/test/SandboxLimitOrderBook.t.sol#635)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in LimitOrderRouterTest.testValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#242-275):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderRouter.t.sol#251)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderRouter.t.sol#253)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#255)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#257-259)
	- orderId = placeMockOrder(order) (src/test/LimitOrderRouter.t.sol#262)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderRouter.t.sol#537)
	- IWETH(WETH).withdraw(100000) (src/test/LimitOrderRouter.t.sol#264)
	- canceled = limitOrderRouter.validateAndCancelOrder(orderId) (src/test/LimitOrderRouter.t.sol#266)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#255)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#257-259)
	State variables written after the call(s):
	- assertTrue(canceled) (src/test/LimitOrderRouter.t.sol#267)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderBookTest.testValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#638-666):
	External calls:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#642)
		- cheatCodes.deal(address(this),_amount) (src/test/SandboxLimitOrderBook.t.sol#745)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#644)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#646-648)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#651)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#652)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- IWETH(WETH).withdraw(100000) (src/test/SandboxLimitOrderBook.t.sol#654)
	- canceled = sandboxLimitOrderBook.validateAndCancelOrder(orderId) (src/test/SandboxLimitOrderBook.t.sol#656)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#642)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#646-648)
	State variables written after the call(s):
	- assertTrue(canceled) (src/test/SandboxLimitOrderBook.t.sol#657)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1103-1176):
	External calls:
	- initializeTestBalanceState(wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1126)
		- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1403)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
		- cheatCodes.deal(address(swapHelper),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1404)
		- cheatCodes.deal(address(this),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1407)
		- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1410-1412)
		- IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1414)
	- swapHelper.swapEthForTokenWithUniV2(daiQuantity,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1136-1173)
	- orderIds[0] = placeMockOrderWrapper(orders[0]) (src/test/SandboxLimitOrderRouter.t.sol#1159)
		- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1830-1831)
	- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
		- (status) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(validateSandboxExecutionAndFillOrders(bytes32[][],uint128[],LimitOrderRouter.PreSandboxExecutionState),orderIdBundles,fillAmounts,preSandboxExecutionState)) (src/test/SandboxLimitOrderRouter.t.sol#1220-1227)
		- sandboxLimitOrderBookWrapper.validateSandboxExecutionAndFillOrders(orderIdBundles,fillAmounts,preSandboxExecutionState) (src/test/SandboxLimitOrderRouter.t.sol#1230-1234)
		- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxFillAmountNotSatisfied.selector,orders[0].orderId,initialBalancesIn[0] - wethQuantity,fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
		- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxAmountOutRequiredNotSatisfied.selector,orders[0].orderId,amountOut,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0]))) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
	External calls sending eth:
	- initializeTestBalanceState(wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1126)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
		- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1410-1412)
	State variables written after the call(s):
	- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.validateSandboxExecutionAndFillOrders(bytes32[][],uint256[],uint256[],uint256,SandboxLimitOrderBook.SandboxLimitOrder[],uint128[],uint256) (src/test/SandboxLimitOrderRouter.t.sol#1178-1272):
	External calls:
	- (status) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(validateSandboxExecutionAndFillOrders(bytes32[][],uint128[],LimitOrderRouter.PreSandboxExecutionState),orderIdBundles,fillAmounts,preSandboxExecutionState)) (src/test/SandboxLimitOrderRouter.t.sol#1220-1227)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxFillAmountNotSatisfied.selector,orders[0].orderId,initialBalancesIn[0] - wethQuantity,fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxAmountOutRequiredNotSatisfied.selector,orders[0].orderId,amountOut,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0]))) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
	State variables written after the call(s):
	- assertTrue(status) (src/test/SandboxLimitOrderRouter.t.sol#1228)
		- failed = true (src/test/utils/test.sol#48)
Reentrancy in SandboxLimitOrderRouterTest.validateSandboxExecutionAndFillOrders(bytes32[][],uint256[],uint256[],uint256,SandboxLimitOrderBook.SandboxLimitOrder[],uint128[],uint256) (src/test/SandboxLimitOrderRouter.t.sol#1178-1272):
	External calls:
	- sandboxLimitOrderBookWrapper.validateSandboxExecutionAndFillOrders(orderIdBundles,fillAmounts,preSandboxExecutionState) (src/test/SandboxLimitOrderRouter.t.sol#1230-1234)
	State variables written after the call(s):
	- assertEq(postExecutionOrder.amountInRemaining,orders[0].amountInRemaining - fillAmounts[0]) (src/test/SandboxLimitOrderRouter.t.sol#1243-1246)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(postExecutionOrder.amountOutRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1248-1257)
		- failed = true (src/test/utils/test.sol#48)
	- assertEq(postExecutionOrder.feeRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(fillAmounts[0],orders[0].amountInRemaining),orders[0].feeRemaining)) (src/test/SandboxLimitOrderRouter.t.sol#1259-1268)
		- failed = true (src/test/utils/test.sol#48)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2

Reentrancy in LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261):
	External calls:
	- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderRouter.sol#223-224)
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,orderOwnerGasCreditBalance - executorFee) (src/LimitOrderRouter.sol#242-245)
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,0) (src/LimitOrderRouter.sol#248-251)
	Event emitted after the call(s):
	- OrderCanceled(orderIds) (src/LimitOrderRouter.sol#258)
Reentrancy in SandboxLimitOrderBook._cancelSandboxLimitOrderViaExecutor(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#539-581):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,orderOwnerGasCreditBalance - executorFee) (src/SandboxLimitOrderBook.sol#562-565)
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,0) (src/SandboxLimitOrderBook.sol#568-571)
	Event emitted after the call(s):
	- OrderCanceled(orderIds) (src/SandboxLimitOrderBook.sol#578)
Reentrancy in SandboxLimitOrderBook._checkSufficientGasCreditsForOrderPlacement(uint256) (src/SandboxLimitOrderBook.sol#1305-1341):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/SandboxLimitOrderBook.sol#1335-1338)
	Event emitted after the call(s):
	- GasCreditEvent(msg.sender,userGasCreditBalance + msg.value) (src/SandboxLimitOrderBook.sol#1339)
Reentrancy in LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,currentBalance - REFRESH_FEE) (src/LimitOrderRouter.sol#170-173)
	Event emitted after the call(s):
	- OrderRefreshed(order.orderId,order.lastRefreshTimestamp,order.expirationTimestamp) (src/LimitOrderRouter.sol#182-186)
Reentrancy in SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(order.owner,currentCreditBalance - REFRESH_FEE) (src/SandboxLimitOrderBook.sol#648-651)
	Event emitted after the call(s):
	- OrderRefreshed(order.orderId,order.lastRefreshTimestamp,order.expirationTimestamp) (src/SandboxLimitOrderBook.sol#660-664)
Reentrancy in SandboxLimitOrderRouterTest._requireConveyorFeeIsPaid(uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1277-1317):
	External calls:
	- cheatCodes.deal(address(limitOrderExecutor),compensationAmount) (src/test/SandboxLimitOrderRouter.t.sol#1282)
	- cheatCodes.prank(address(limitOrderExecutor)) (src/test/SandboxLimitOrderRouter.t.sol#1283)
	- (depositSuccess) = address(WETH).call{value: compensationAmount}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1285-1287)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.ConveyorFeesNotPaid.selector,expectedAccumulatedFees,IERC20(WETH).balanceOf(address(limitOrderExecutor)) - contractBalancePreExecution,expectedAccumulatedFees - ((compensationAmount + contractBalancePreExecution) - contractBalancePreExecution))) (src/test/SandboxLimitOrderRouter.t.sol#1294-1304)
	- (reverted) = address(limitOrderExecutor).call(abi.encodeWithSignature(requireConveyorFeeIsPaid(uint256, uint256),uint256(contractBalancePreExecution),uint256(expectedAccumulatedFees))) (src/test/SandboxLimitOrderRouter.t.sol#1305-1311)
	External calls sending eth:
	- (depositSuccess) = address(WETH).call{value: compensationAmount}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1285-1287)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(! reverted) (src/test/SandboxLimitOrderRouter.t.sol#1312-1315)
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(reverted) (src/test/SandboxLimitOrderRouter.t.sol#1312-1315)
Reentrancy in LimitOrderRouter.executeLimitOrders(bytes32[]) (src/LimitOrderRouter.sol#331-419):
	External calls:
	- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderRouter.sol#335-336)
	- (totalBeaconReward,totalConveyorReward) = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeTokenToWethOrders(orders) (src/LimitOrderRouter.sol#381-383)
	- (totalBeaconReward,totalConveyorReward) = ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeTokenToTokenOrders(orders) (src/LimitOrderRouter.sol#386-388)
	Event emitted after the call(s):
	- OrderFufilled(orderIds) (src/LimitOrderRouter.sol#406)
Reentrancy in SandboxLimitOrderBook.executeOrdersViaSandboxMulticall(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderBook.sol#679-719):
	External calls:
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).executeSandboxLimitOrders(preSandboxExecutionState.sandboxLimitOrders,sandboxMulticall) (src/SandboxLimitOrderBook.sol#695-698)
	- executionGasCompensation = _calculateExecutionGasCompensation(getGasPrice(),preSandboxExecutionState.orderOwners,OrderType.PendingSandboxLimitOrder) (src/SandboxLimitOrderBook.sol#708-712)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(orderOwners[i],ownerGasCreditBalance - gasDecrementValue) (src/SandboxLimitOrderBook.sol#1155-1159)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(orderOwners[i],0) (src/SandboxLimitOrderBook.sol#1163-1164)
	Event emitted after the call(s):
	- MeanGasPriceUpdate(block.number,block.timestamp,gasPrice,meanGasPrice) (src/ConveyorGasOracle.sol#62-67)
		- executionGasCompensation = _calculateExecutionGasCompensation(getGasPrice(),preSandboxExecutionState.orderOwners,OrderType.PendingSandboxLimitOrder) (src/SandboxLimitOrderBook.sol#708-712)
Reentrancy in LimitOrderBook.placeLimitOrder(LimitOrderBook.LimitOrder[]) (src/LimitOrderBook.sol#173-299):
	External calls:
	- _checkSufficientGasCreditsForOrderPlacement(orderGroup.length) (src/LimitOrderBook.sol#178)
		- gasPrice = IConveyorGasOracle(CONVEYOR_GAS_ORACLE).getGasPrice() (src/LimitOrderBook.sol#307-308)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/LimitOrderBook.sol#334-337)
	Event emitted after the call(s):
	- OrderPlaced(orderIds) (src/LimitOrderBook.sol#296)
Reentrancy in SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394):
	External calls:
	- _checkSufficientGasCreditsForOrderPlacement(orderGroup.length) (src/SandboxLimitOrderBook.sol#219)
		- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).updateGasCreditBalance(msg.sender,userGasCreditBalance + msg.value) (src/SandboxLimitOrderBook.sol#1335-1338)
	Event emitted after the call(s):
	- OrderPlaced(orderIds) (src/SandboxLimitOrderBook.sol#391)
Reentrancy in SwapRouterTest.testCalculateFee(uint112) (src/test/SwapRouter.t.sol#333-368):
	External calls:
	- output = scriptRunner.runPythonScript(path,args) (src/test/SwapRouter.t.sol#360)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(fee / 10000,expected / 10000) (src/test/SwapRouter.t.sol#366)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(fee / 10000,expected / 10000) (src/test/SwapRouter.t.sol#366)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(fee / 10000,expected / 10000) (src/test/SwapRouter.t.sol#366)
Reentrancy in LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271):
	External calls:
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#209)
	- swapHelper.swapEthForTokenWithUniV2(20000000000000000000000,swapToken) (src/test/LimitOrderExecutor.t.sol#210)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#211)
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#231)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#232)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#234)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- placeMockOrder(order1) (src/test/LimitOrderExecutor.t.sol#235)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#232)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(expected / 100,minGasCredits) (src/test/LimitOrderExecutor.t.sol#266)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(expected / 100,minGasCredits) (src/test/LimitOrderExecutor.t.sol#266)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(expected / 100,minGasCredits) (src/test/LimitOrderExecutor.t.sol#266)
Reentrancy in SwapRouterTest.testCalculateOrderRewardBeacon(uint64) (src/test/SwapRouter.t.sol#397-425):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/SwapRouter.t.sol#419)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#423)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#423)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#423)
Reentrancy in ConveyorFeeMathTest.testCalculateOrderRewardBeacon(uint64) (src/test/ConveyorFeeMath.t.sol#79-107):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/ConveyorFeeMath.t.sol#101)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#105)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#105)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(rewardBeacon / 10 ** 3,beaconRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#105)
Reentrancy in SwapRouterTest.testCalculateOrderRewardConveyor(uint64) (src/test/SwapRouter.t.sol#428-456):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/SwapRouter.t.sol#450)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#454)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#454)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/SwapRouter.t.sol#454)
Reentrancy in ConveyorFeeMathTest.testCalculateOrderRewardConveyor(uint64) (src/test/ConveyorFeeMath.t.sol#110-138):
	External calls:
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/ConveyorFeeMath.t.sol#132)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#136)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#136)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(rewardConveyor / 10 ** 3,conveyorRewardExpected / 10 ** 3) (src/test/ConveyorFeeMath.t.sol#136)
Reentrancy in SwapRouterTest.testCalculateV2SpotSushiTest1() (src/test/SwapRouter.t.sol#116-145):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#117)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#118)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(priceWethUsdc.spotPrice,593525979047872548219266386638161406066688) (src/test/SwapRouter.t.sol#141-144)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(priceWethUsdc.spotPrice,593525979047872548219266386638161406066688) (src/test/SwapRouter.t.sol#141-144)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(priceWethUsdc.spotPrice,593525979047872548219266386638161406066688) (src/test/SwapRouter.t.sol#141-144)
Reentrancy in SwapRouterTest.testCalculateV2SpotSushiTest2() (src/test/SwapRouter.t.sol#148-168):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#149)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#150)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(priceWethKope.spotPrice,9457943135647822527192493517503987712) (src/test/SwapRouter.t.sol#164-167)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(priceWethKope.spotPrice,9457943135647822527192493517503987712) (src/test/SwapRouter.t.sol#164-167)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(priceWethKope.spotPrice,9457943135647822527192493517503987712) (src/test/SwapRouter.t.sol#164-167)
Reentrancy in SwapRouterTest.testCalculateV2SpotSushiTest3() (src/test/SwapRouter.t.sol#171-188):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#172)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#173)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(priceOhmDai.spotPrice,21888402763315038097036358416236281856) (src/test/SwapRouter.t.sol#187)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(priceOhmDai.spotPrice,21888402763315038097036358416236281856) (src/test/SwapRouter.t.sol#187)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(priceOhmDai.spotPrice,21888402763315038097036358416236281856) (src/test/SwapRouter.t.sol#187)
Reentrancy in SwapRouterTest.testCalculateV2SpotUni1() (src/test/SwapRouter.t.sol#236-256):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#237)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#238)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(spotPriceWethUsdc,195241231237127088630569907242663936) (src/test/SwapRouter.t.sol#255)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(spotPriceWethUsdc,195241231237127088630569907242663936) (src/test/SwapRouter.t.sol#255)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(spotPriceWethUsdc,195241231237127088630569907242663936) (src/test/SwapRouter.t.sol#255)
Reentrancy in SwapRouterTest.testCalculateV2SpotUni2() (src/test/SwapRouter.t.sol#259-279):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#260)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#261)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(spotPriceDaiUsdc.spotPrice,340481350396253814427678140089094897664) (src/test/SwapRouter.t.sol#275-278)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(spotPriceDaiUsdc.spotPrice,340481350396253814427678140089094897664) (src/test/SwapRouter.t.sol#275-278)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(spotPriceDaiUsdc.spotPrice,340481350396253814427678140089094897664) (src/test/SwapRouter.t.sol#275-278)
Reentrancy in SwapRouterTest.testCalculateV2SpotUni3() (src/test/SwapRouter.t.sol#282-302):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#283)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#284)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(spotPriceWethWax.spotPrice,20238613147511897623021403873923301376) (src/test/SwapRouter.t.sol#298-301)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(spotPriceWethWax.spotPrice,20238613147511897623021403873923301376) (src/test/SwapRouter.t.sol#298-301)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(spotPriceWethWax.spotPrice,20238613147511897623021403873923301376) (src/test/SwapRouter.t.sol#298-301)
Reentrancy in SwapRouterTest.testCalculateV3SpotPrice1() (src/test/SwapRouter.t.sol#191-209):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#192)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#193)
	- (priceDaiWeth,poolAddressDaiWeth) = limitOrderExecutor.calculateV3SpotPrice(dai,weth,3000,_uniV3FactoryAddress) (src/test/SwapRouter.t.sol#198-206)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(priceDaiWeth.spotPrice,195219315785396777134689842230198271) (src/test/SwapRouter.t.sol#208)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(priceDaiWeth.spotPrice,195219315785396777134689842230198271) (src/test/SwapRouter.t.sol#208)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(priceDaiWeth.spotPrice,195219315785396777134689842230198271) (src/test/SwapRouter.t.sol#208)
Reentrancy in SwapRouterTest.testCalculateV3SpotPrice2() (src/test/SwapRouter.t.sol#212-233):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/SwapRouter.t.sol#213)
	- cheatCodes.rollFork(forkId,15233771) (src/test/SwapRouter.t.sol#214)
	- (priceDaiUsdc) = limitOrderExecutor.calculateV3SpotPrice(dai,usdc,3000,_uniV3FactoryAddress) (src/test/SwapRouter.t.sol#220-228)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(priceDaiUsdc.spotPrice,341140785248087661355983754903316070398) (src/test/SwapRouter.t.sol#229-232)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(priceDaiUsdc.spotPrice,341140785248087661355983754903316070398) (src/test/SwapRouter.t.sol#229-232)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(priceDaiUsdc.spotPrice,341140785248087661355983754903316070398) (src/test/SwapRouter.t.sol#229-232)
Reentrancy in SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#522)
	- IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#523-526)
	- swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#529-585)
	- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#549-550)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#556-561)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#563-566)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#563-566)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#556-561)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#556-561)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#563-566)
Reentrancy in SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#522)
	- IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#523-526)
	- swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#529-585)
	- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#549-550)
	- sandboxLimitOrderBook.cancelOrder(orderId) (src/test/SandboxLimitOrderBook.t.sol#567)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),0) (src/test/SandboxLimitOrderBook.t.sol#581-584)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),0) (src/test/SandboxLimitOrderBook.t.sol#574-579)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),0) (src/test/SandboxLimitOrderBook.t.sol#581-584)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),0) (src/test/SandboxLimitOrderBook.t.sol#574-579)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),0) (src/test/SandboxLimitOrderBook.t.sol#574-579)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),0) (src/test/SandboxLimitOrderBook.t.sol#581-584)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrderBatch() (src/test/SandboxLimitOrderRouter.t.sol#459-538):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#461)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#462)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#465)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- (multiCall,orders,orderIds) = createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#467-471)
		- cheatCodes.prank(mockOwner1) (src/test/SandboxLimitOrderRouter.t.sol#1852)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1853)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1810-1812)
		- cheatCodes.prank(mockOwner1) (src/test/SandboxLimitOrderRouter.t.sol#1854)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1855)
		- cheatCodes.prank(mockOwner2) (src/test/SandboxLimitOrderRouter.t.sol#1867)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1868)
		- cheatCodes.prank(mockOwner2) (src/test/SandboxLimitOrderRouter.t.sol#1869)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1870)
		- cheatCodes.prank(mockOwner3) (src/test/SandboxLimitOrderRouter.t.sol#1881)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1882)
		- cheatCodes.prank(mockOwner3) (src/test/SandboxLimitOrderRouter.t.sol#1883)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1884)
		- cheatCodes.prank(mockOwner4) (src/test/SandboxLimitOrderRouter.t.sol#1895)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1896)
		- cheatCodes.prank(mockOwner4) (src/test/SandboxLimitOrderRouter.t.sol#1897)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1898)
		- cheatCodes.prank(mockOwner5) (src/test/SandboxLimitOrderRouter.t.sol#1909)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1910)
		- cheatCodes.prank(mockOwner5) (src/test/SandboxLimitOrderRouter.t.sol#1911)
		- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1912)
		- cheatCodes.prank(mockOwner6) (src/test/SandboxLimitOrderRouter.t.sol#1924)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1925)
		- cheatCodes.prank(mockOwner6) (src/test/SandboxLimitOrderRouter.t.sol#1926)
		- IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1927)
		- cheatCodes.prank(mockOwner7) (src/test/SandboxLimitOrderRouter.t.sol#1938)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1939)
		- cheatCodes.prank(mockOwner7) (src/test/SandboxLimitOrderRouter.t.sol#1940)
		- IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1941)
		- cheatCodes.prank(mockOwner8) (src/test/SandboxLimitOrderRouter.t.sol#1953)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,USDC) (src/test/SandboxLimitOrderRouter.t.sol#1954)
		- cheatCodes.prank(mockOwner8) (src/test/SandboxLimitOrderRouter.t.sol#1955)
		- IERC20(USDC).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1956)
		- cheatCodes.deal(address(mockOwner9),1000000000000000000000000) (src/test/SandboxLimitOrderRouter.t.sol#1968)
		- cheatCodes.prank(mockOwner9) (src/test/SandboxLimitOrderRouter.t.sol#1969)
		- IERC20(WETH).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1970)
		- cheatCodes.prank(mockOwner9) (src/test/SandboxLimitOrderRouter.t.sol#1973)
		- (success) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1975-1977)
		- cheatCodes.deal(address(mockOwner10),1000000000000000000000000) (src/test/SandboxLimitOrderRouter.t.sol#1990)
		- cheatCodes.prank(mockOwner10) (src/test/SandboxLimitOrderRouter.t.sol#1991)
		- IERC20(WETH).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1992)
		- cheatCodes.prank(mockOwner10) (src/test/SandboxLimitOrderRouter.t.sol#1995)
		- (depositSuccess) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1997-1999)
		- cheatCodes.prank(mockOwner1) (src/test/SandboxLimitOrderRouter.t.sol#2013)
		- cheatCodes.prank(mockOwner2) (src/test/SandboxLimitOrderRouter.t.sol#2015)
		- cheatCodes.prank(mockOwner3) (src/test/SandboxLimitOrderRouter.t.sol#2017)
		- cheatCodes.prank(mockOwner4) (src/test/SandboxLimitOrderRouter.t.sol#2019)
		- cheatCodes.prank(mockOwner5) (src/test/SandboxLimitOrderRouter.t.sol#2021)
		- cheatCodes.prank(mockOwner6) (src/test/SandboxLimitOrderRouter.t.sol#2023)
		- cheatCodes.prank(mockOwner7) (src/test/SandboxLimitOrderRouter.t.sol#2025)
		- cheatCodes.prank(mockOwner8) (src/test/SandboxLimitOrderRouter.t.sol#2027)
		- cheatCodes.prank(mockOwner9) (src/test/SandboxLimitOrderRouter.t.sol#2029)
		- cheatCodes.prank(mockOwner10) (src/test/SandboxLimitOrderRouter.t.sol#2031)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#475-481)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#488)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#491)
	External calls sending eth:
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#465)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- (multiCall,orders,orderIds) = createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#467-471)
		- (success) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1975-1977)
		- (depositSuccess) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1997-1999)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#536)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(order.amountInRemaining,orders[i].amountInRemaining - multiCall.fillAmounts[i]) (src/test/SandboxLimitOrderRouter.t.sol#516-519)
	- log(Error: a <= b not satisfied [uint]) (src/test/utils/test.sol#338)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#494-497)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(order.amountOutRemaining,orders[i].amountOutRemaining - ConveyorMath.mul64U(ConveyorMath.divUU(orders[i].amountOutRemaining,orders[i].amountInRemaining),multiCall.fillAmounts[i])) (src/test/SandboxLimitOrderRouter.t.sol#521-531)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#536)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(order.amountOutRemaining,orders[i].amountOutRemaining - ConveyorMath.mul64U(ConveyorMath.divUU(orders[i].amountOutRemaining,orders[i].amountInRemaining),multiCall.fillAmounts[i])) (src/test/SandboxLimitOrderRouter.t.sol#521-531)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#339)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#494-497)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(order.amountInRemaining,orders[i].amountInRemaining - multiCall.fillAmounts[i]) (src/test/SandboxLimitOrderRouter.t.sol#516-519)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(order.amountOutRemaining,orders[i].amountOutRemaining - ConveyorMath.mul64U(ConveyorMath.divUU(orders[i].amountOutRemaining,orders[i].amountInRemaining),multiCall.fillAmounts[i])) (src/test/SandboxLimitOrderRouter.t.sol#521-531)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#536)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(order.amountInRemaining,orders[i].amountInRemaining - multiCall.fillAmounts[i]) (src/test/SandboxLimitOrderRouter.t.sol#516-519)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#340)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#494-497)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#216)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#217)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#219)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#221)
	- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#223)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#235)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- orderIds[0] = placeMockOrder(order) (src/test/SandboxLimitOrderRouter.t.sol#254)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1810-1812)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#293-299)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#305)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#308)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#219)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#235)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	Event emitted after the call(s):
	- log(Error: a <= b not satisfied [uint]) (src/test/utils/test.sol#338)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#311-314)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#327)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#339)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#311-314)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#327)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#327)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#340)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#311-314)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#334)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#335)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#337)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#339)
	- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#341)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#343)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- orderIds[0] = placeMockOrder(order) (src/test/SandboxLimitOrderRouter.t.sol#368)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1810-1812)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#415-421)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#428)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#431)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#337)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#343)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#452)
	- log(Error: a <= b not satisfied [uint]) (src/test/utils/test.sol#338)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#434-437)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#452)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#339)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#434-437)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#340)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#434-437)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#452)
Reentrancy in SandboxLimitOrderRouterTest.testExecuteMulticallOrdersSameOwnerBundleInputToken() (src/test/SandboxLimitOrderRouter.t.sol#541-679):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#543)
	- cheatCodes.deal(address(swapHelper),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#544)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#546)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#548)
	- IERC20(DAI).approve(address(limitOrderExecutor),type()(uint256).max) (src/test/SandboxLimitOrderRouter.t.sol#550)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#552)
		- cheatCodes.deal(address(sandboxRouter),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1444)
		- cheatCodes.prank(address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1445)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	- orderIds = placeMultipleMockOrder(orders) (src/test/SandboxLimitOrderRouter.t.sol#561)
		- orderIds = orderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1841-1843)
	- (txOriginBalanceBefore,gasCompensationUpperBound) = initializePreSandboxExecutionTxOriginGasCompensationState(orderIds,tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#643-649)
		- gasCompensationUpperBound = sandboxLimitOrderBookWrapper.getGasPrice() * orderIds.length * SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#1359-1362)
	- cheatCodes.prank(tx.origin) (src/test/SandboxLimitOrderRouter.t.sol#656)
	- sandboxRouter.executeSandboxMulticall(multiCall) (src/test/SandboxLimitOrderRouter.t.sol#659)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#546)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
	- dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#552)
		- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
	Event emitted after the call(s):
	- log(Error: a <= b not satisfied [uint]) (src/test/utils/test.sol#338)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#662-665)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#677)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#677)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#339)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#662-665)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#340)
		- validatePostSandboxExecutionGasCompensation(txOriginBalanceBefore,gasCompensationUpperBound) (src/test/SandboxLimitOrderRouter.t.sol#662-665)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- validatePostExecutionProtocolFees(wethBalanceBefore,orders) (src/test/SandboxLimitOrderRouter.t.sol#677)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1210-1255):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1211)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1212)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelperUniV2),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1213)
	- swapHelperUniV2.swapEthForTokenWithUniV2(10000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1214)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1216)
	- orderBatch = placeNewMockTaxedToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#1218)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1232)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1236)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1237)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1212)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1245-1248)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1245-1248)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1245-1248)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1259)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1260)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1261)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1262)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1264)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1285)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1292)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1304)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1305)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1260)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1310)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1313-1316)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1310)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1313-1316)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1310)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1313-1316)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1162-1207):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1163)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1164)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelperUniV2),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1165)
	- swapHelperUniV2.swapEthForTokenWithUniV2(10000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1166)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1168)
	- orderBatch = placeNewMockTaxedToTokenBatch() (src/test/LimitOrderExecutor.t.sol#1170)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1184)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1188)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1189)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1164)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1197-1200)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1197-1200)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1197-1200)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1095)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1096)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1097)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1098)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1100)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1121)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1128)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1140)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1141)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1096)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1149-1152)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1146)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1146)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1149-1152)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1149-1152)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1146)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#980-1025):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#981)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#982)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#983)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#985)
	- tokenToWethOrderBatch = placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#987-988)
		- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#1702)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1002)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1006)
	- limitOrderRouter.executeLimitOrders(tokenToWethOrderBatch) (src/test/LimitOrderExecutor.t.sol#1007)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#982)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1015-1018)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1015-1018)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#1015-1018)
Reentrancy in LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#907)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#908)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#910)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,TAXED_TOKEN) (src/test/LimitOrderExecutor.t.sol#911)
	- IERC20(TAXED_TOKEN).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#913)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#932)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#945)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#957)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#958)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#908)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#963)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#966-969)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#963)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#966-969)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#966-969)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#963)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1029)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1030)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1031)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#1032)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#1034)
	- orderBatch = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1053)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#1060)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#1072)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#1073)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#1030)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1078)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1081-1084)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1081-1084)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1078)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#1078)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#1081-1084)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#683-729):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#684)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#685)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#686)
	- IERC20(USDC).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#688)
	- tokenToTokenOrderBatch = placeNewMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#690-691)
		- swapHelper.swapEthForTokenWithUniV2(10000000000000000000000,USDC) (src/test/LimitOrderExecutor.t.sol#2747)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#706)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#710)
	- limitOrderRouter.executeLimitOrders(tokenToTokenOrderBatch) (src/test/LimitOrderExecutor.t.sol#711)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#685)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#719-722)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#716)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#716)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#719-722)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#716)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#719-722)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#568)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#569)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#570)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#571)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#572)
	- (spRes) = limitOrderExecutor.calculateV3SpotPrice(DAI,UNI,500,0x1F98431c8aD98523631AE4a59f267346ea31F984) (src/test/LimitOrderExecutor.t.sol#574-580)
	- orderId = placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#618)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#638)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#650)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#651)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#569)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#663)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#658-661)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#665-668)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#665-668)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#658-661)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#663)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#665-668)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#663)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#658-661)
Reentrancy in LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#391)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#392)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#393)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#394)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#395)
	- (spRes) = limitOrderExecutor.calculateV3SpotPrice(DAI,WETH,500,0x1F98431c8aD98523631AE4a59f267346ea31F984) (src/test/LimitOrderExecutor.t.sol#398-404)
	- orderId = placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#433)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#456)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#468)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#469)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#392)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#481)
	- log(Error: a <= b not satisfied [uint]) (src/test/utils/test.sol#338)
		- assertLe(gasCompensationAfter - gasCompensationBefore,executionCostUpper * gasPrice) (src/test/LimitOrderExecutor.t.sol#487-490)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#483-486)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#476-479)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#476-479)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#483-486)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#481)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#339)
		- assertLe(gasCompensationAfter - gasCompensationBefore,executionCostUpper * gasPrice) (src/test/LimitOrderExecutor.t.sol#487-490)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#340)
		- assertLe(gasCompensationAfter - gasCompensationBefore,executionCostUpper * gasPrice) (src/test/LimitOrderExecutor.t.sol#487-490)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#481)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#483-486)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#476-479)
Reentrancy in LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#853)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#854)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#855)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#857-859)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#863)
	- wethToTaxedOrderBatch = placeNewMockWethToTaxedBatch() (src/test/LimitOrderExecutor.t.sol#865)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#880)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#884)
	- limitOrderRouter.executeLimitOrders(wethToTaxedOrderBatch) (src/test/LimitOrderExecutor.t.sol#885)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#854)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#857-859)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#890)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#893-896)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#893-896)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#890)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 2) (src/test/LimitOrderExecutor.t.sol#893-896)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#890)
Reentrancy in LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#739)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#740)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#741)
	- address(WETH).call{value: amountIn}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#743-745)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#747)
	- orderId = placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#794)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#807)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#819)
	- limitOrderRouter.executeLimitOrders(orderBatch) (src/test/LimitOrderExecutor.t.sol#820)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#740)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- address(WETH).call{value: amountIn}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#743-745)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#827-830)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#834-837)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#832)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#834-837)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#832)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#827-830)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(balanceAfterMin,order.amountOutMin) (src/test/LimitOrderExecutor.t.sol#832)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#827-830)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice) (src/test/LimitOrderExecutor.t.sol#834-837)
Reentrancy in LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#505)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#507)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#509)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#512-514)
	- IERC20(WETH).approve(address(limitOrderExecutor),5000000000000000000000000000) (src/test/LimitOrderExecutor.t.sol#519)
	- tokenToWethOrderBatch = placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#521)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1534)
	- gasPrice = conveyorGasOracle.getGasPrice() (src/test/LimitOrderExecutor.t.sol#536)
	- cheatCodes.prank(tx.origin) (src/test/LimitOrderExecutor.t.sol#540)
	- limitOrderRouter.executeLimitOrders(tokenToWethOrderBatch) (src/test/LimitOrderExecutor.t.sol#541)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#507)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#512-514)
	Event emitted after the call(s):
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 6) (src/test/LimitOrderExecutor.t.sol#549-552)
	- log(Error: a >= b not satisfied [uint]) (src/test/utils/test.sol#224)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#546)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#546)
	- log_named_uint(  Value a,a) (src/test/utils/test.sol#225)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 6) (src/test/LimitOrderExecutor.t.sol#549-552)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(IERC20(WETH).balanceOf(tx.origin),txOriginBalanceBefore) (src/test/LimitOrderExecutor.t.sol#546)
	- log_named_uint(  Value b,b) (src/test/utils/test.sol#226)
		- assertGe(gasCompensationAfter - gasCompensationBefore,executionCostLower * gasPrice * 6) (src/test/LimitOrderExecutor.t.sol#549-552)
Reentrancy in LimitOrderExecutorTest.testFailMinGasCredits() (src/test/LimitOrderExecutor.t.sol#169-205):
	External calls:
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#170)
	- IERC20(DAI).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#171)
	- swapHelper.swapEthForTokenWithUniV2(2000000000000000000000,DAI) (src/test/LimitOrderExecutor.t.sol#174)
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderExecutor.t.sol#191)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#192)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	- placeMockOrder(order) (src/test/LimitOrderExecutor.t.sol#194)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderExecutor.t.sol#1525)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderExecutor.t.sol#192)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(hasMinGasCredits) (src/test/LimitOrderExecutor.t.sol#204)
Reentrancy in LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256) (src/test/LimitOrderBook.t.sol#220-262):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#224)
	- swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#227-261)
	- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#245)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#258)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#251-256)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#251-256)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#258)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#258)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#251-256)
Reentrancy in LimitOrderRouterTest.testFailValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#278-306):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderRouter.t.sol#287)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#289)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#291-293)
	- orderId = placeMockOrder(order) (src/test/LimitOrderRouter.t.sol#296)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderRouter.t.sol#537)
	- canceled = limitOrderRouter.validateAndCancelOrder(orderId) (src/test/LimitOrderRouter.t.sol#298)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#289)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#291-293)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(! canceled) (src/test/LimitOrderRouter.t.sol#299)
Reentrancy in SandboxLimitOrderBookTest.testFailValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#669-696):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#673)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#675)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#677)
		- cheatCodes.deal(address(this),_amount) (src/test/SandboxLimitOrderBook.t.sol#745)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#679-681)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#684)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- canceled = sandboxLimitOrderBook.validateAndCancelOrder(orderId) (src/test/SandboxLimitOrderBook.t.sol#686)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#677)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#679-681)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(! canceled) (src/test/SandboxLimitOrderBook.t.sol#687)
Reentrancy in ConveyorTickMathTest.testFromSqrtX96() (src/test/ConveyorTickMath.t.sol#255-281):
	External calls:
	- forkId = cheatCodes.activeFork() (src/test/ConveyorTickMath.t.sol#256)
	- cheatCodes.rollFork(forkId,15233771) (src/test/ConveyorTickMath.t.sol#257)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(194786572365129798010721349067079679,priceUSDC) (src/test/ConveyorTickMath.t.sol#279)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(594456218574771757927683806232862281426471,priceWETH) (src/test/ConveyorTickMath.t.sol#280)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(594456218574771757927683806232862281426471,priceWETH) (src/test/ConveyorTickMath.t.sol#280)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(194786572365129798010721349067079679,priceUSDC) (src/test/ConveyorTickMath.t.sol#279)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(194786572365129798010721349067079679,priceUSDC) (src/test/ConveyorTickMath.t.sol#279)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(594456218574771757927683806232862281426471,priceWETH) (src/test/ConveyorTickMath.t.sol#280)
Reentrancy in LimitOrderBookTest.testGetLimitOrderById() (src/test/LimitOrderBook.t.sol#101-127):
	External calls:
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#102)
	- swapHelper.swapEthForTokenWithUniV2(20000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#104)
	- orderId = placeMockOrder(order) (src/test/LimitOrderBook.t.sol#115)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(returnedOrder.price,order.price) (src/test/LimitOrderBook.t.sol#125)
	- log(Error: a == b not satisfied [bytes32]) (src/test/utils/test.sol#89)
		- assertEq(returnedOrder.orderId,orderId) (src/test/LimitOrderBook.t.sol#124)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(returnedOrder.quantity,order.quantity) (src/test/LimitOrderBook.t.sol#126)
	- log(Error: a == b not satisfied [address]) (src/test/utils/test.sol#74)
		- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/LimitOrderBook.t.sol#123)
	- log(Error: a == b not satisfied [address]) (src/test/utils/test.sol#74)
		- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/LimitOrderBook.t.sol#122)
	- log_named_address(  Expected,b) (src/test/utils/test.sol#75)
		- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/LimitOrderBook.t.sol#122)
	- log_named_address(  Expected,b) (src/test/utils/test.sol#75)
		- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/LimitOrderBook.t.sol#123)
	- log_named_address(    Actual,a) (src/test/utils/test.sol#76)
		- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/LimitOrderBook.t.sol#122)
	- log_named_address(    Actual,a) (src/test/utils/test.sol#76)
		- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/LimitOrderBook.t.sol#123)
	- log_named_bytes32(  Expected,b) (src/test/utils/test.sol#90)
		- assertEq(returnedOrder.orderId,orderId) (src/test/LimitOrderBook.t.sol#124)
	- log_named_bytes32(    Actual,a) (src/test/utils/test.sol#91)
		- assertEq(returnedOrder.orderId,orderId) (src/test/LimitOrderBook.t.sol#124)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(returnedOrder.quantity,order.quantity) (src/test/LimitOrderBook.t.sol#126)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(returnedOrder.price,order.price) (src/test/LimitOrderBook.t.sol#125)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(returnedOrder.quantity,order.quantity) (src/test/LimitOrderBook.t.sol#126)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(returnedOrder.price,order.price) (src/test/LimitOrderBook.t.sol#125)
Reentrancy in SandboxLimitOrderBookTest.testGetOrderIds() (src/test/SandboxLimitOrderBook.t.sol#158-199):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#159)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#160)
	- swapHelper.swapEthForTokenWithUniV2(1000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#162)
	- orderId1 = placeMockSandboxLimitOrder(newSandboxLimitOrder(swapToken,WETH,10e21,uint112(1))) (src/test/SandboxLimitOrderBook.t.sol#164-166)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- orderId2 = placeMockSandboxLimitOrder(newSandboxLimitOrder(swapToken,WETH,10e21,uint112(1))) (src/test/SandboxLimitOrderBook.t.sol#168-170)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- sandboxLimitOrderBook.cancelOrder(orderId2) (src/test/SandboxLimitOrderBook.t.sol#172)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [bytes32]) (src/test/utils/test.sol#89)
		- assertEq(canceledSandboxLimitOrders[0],orderId2) (src/test/SandboxLimitOrderBook.t.sol#198)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(canceledSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#195)
	- log(Error: a == b not satisfied [bytes32]) (src/test/utils/test.sol#89)
		- assertEq(pendingSandboxLimitOrders[0],orderId1) (src/test/SandboxLimitOrderBook.t.sol#197)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(pendingSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#194)
	- log_named_bytes32(  Expected,b) (src/test/utils/test.sol#90)
		- assertEq(pendingSandboxLimitOrders[0],orderId1) (src/test/SandboxLimitOrderBook.t.sol#197)
	- log_named_bytes32(  Expected,b) (src/test/utils/test.sol#90)
		- assertEq(canceledSandboxLimitOrders[0],orderId2) (src/test/SandboxLimitOrderBook.t.sol#198)
	- log_named_bytes32(    Actual,a) (src/test/utils/test.sol#91)
		- assertEq(pendingSandboxLimitOrders[0],orderId1) (src/test/SandboxLimitOrderBook.t.sol#197)
	- log_named_bytes32(    Actual,a) (src/test/utils/test.sol#91)
		- assertEq(canceledSandboxLimitOrders[0],orderId2) (src/test/SandboxLimitOrderBook.t.sol#198)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(pendingSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#194)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(canceledSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#195)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(canceledSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#195)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(pendingSandboxLimitOrders.length,1) (src/test/SandboxLimitOrderBook.t.sol#194)
Reentrancy in LimitOrderBookTest.testGetOrderIds() (src/test/LimitOrderBook.t.sol#179-217):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#180)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#181)
	- swapHelper.swapEthForTokenWithUniV2(10000,swapToken) (src/test/LimitOrderBook.t.sol#183)
	- orderId1 = placeMockOrder(newOrder(swapToken,WETH,uint128(1),uint112(1),uint112(1))) (src/test/LimitOrderBook.t.sol#186-188)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	- orderId2 = placeMockOrder(newOrder(swapToken,WETH,uint128(1),uint112(1),uint112(1))) (src/test/LimitOrderBook.t.sol#190-192)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	- orderBook.cancelOrder(orderId2) (src/test/LimitOrderBook.t.sol#194)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [bytes32]) (src/test/utils/test.sol#89)
		- assertEq(pendingLimitOrders[0],orderId1) (src/test/LimitOrderBook.t.sol#215)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(canceledLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#213)
	- log(Error: a == b not satisfied [bytes32]) (src/test/utils/test.sol#89)
		- assertEq(canceledLimitOrders[0],orderId2) (src/test/LimitOrderBook.t.sol#216)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(pendingLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#212)
	- log_named_bytes32(  Expected,b) (src/test/utils/test.sol#90)
		- assertEq(pendingLimitOrders[0],orderId1) (src/test/LimitOrderBook.t.sol#215)
	- log_named_bytes32(  Expected,b) (src/test/utils/test.sol#90)
		- assertEq(canceledLimitOrders[0],orderId2) (src/test/LimitOrderBook.t.sol#216)
	- log_named_bytes32(    Actual,a) (src/test/utils/test.sol#91)
		- assertEq(canceledLimitOrders[0],orderId2) (src/test/LimitOrderBook.t.sol#216)
	- log_named_bytes32(    Actual,a) (src/test/utils/test.sol#91)
		- assertEq(pendingLimitOrders[0],orderId1) (src/test/LimitOrderBook.t.sol#215)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(pendingLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#212)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(canceledLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#213)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(pendingLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#212)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(canceledLimitOrders.length,1) (src/test/LimitOrderBook.t.sol#213)
Reentrancy in SandboxLimitOrderBookTest.testGetSandboxLimitOrderById() (src/test/SandboxLimitOrderBook.t.sol#132-151):
	External calls:
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#133)
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#135)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#141)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [address]) (src/test/utils/test.sol#74)
		- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/SandboxLimitOrderBook.t.sol#149)
	- log(Error: a == b not satisfied [address]) (src/test/utils/test.sol#74)
		- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/SandboxLimitOrderBook.t.sol#148)
	- log(Error: a == b not satisfied [bytes32]) (src/test/utils/test.sol#89)
		- assertEq(returnedOrder.orderId,orderId) (src/test/SandboxLimitOrderBook.t.sol#150)
	- log_named_address(  Expected,b) (src/test/utils/test.sol#75)
		- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/SandboxLimitOrderBook.t.sol#149)
	- log_named_address(  Expected,b) (src/test/utils/test.sol#75)
		- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/SandboxLimitOrderBook.t.sol#148)
	- log_named_address(    Actual,a) (src/test/utils/test.sol#76)
		- assertEq(returnedOrder.tokenOut,order.tokenOut) (src/test/SandboxLimitOrderBook.t.sol#149)
	- log_named_address(    Actual,a) (src/test/utils/test.sol#76)
		- assertEq(returnedOrder.tokenIn,order.tokenIn) (src/test/SandboxLimitOrderBook.t.sol#148)
	- log_named_bytes32(  Expected,b) (src/test/utils/test.sol#90)
		- assertEq(returnedOrder.orderId,orderId) (src/test/SandboxLimitOrderBook.t.sol#150)
	- log_named_bytes32(    Actual,a) (src/test/utils/test.sol#91)
		- assertEq(returnedOrder.orderId,orderId) (src/test/SandboxLimitOrderBook.t.sol#150)
Reentrancy in LimitOrderBookTest.testGetTotalOrdersValue() (src/test/LimitOrderBook.t.sol#529-547):
	External calls:
	- swapHelper.swapEthForTokenWithUniV2(20000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#530)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#531)
	- placeMockOrder(order) (src/test/LimitOrderBook.t.sol#543)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(5,totalOrdersValue) (src/test/LimitOrderBook.t.sol#546)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(5,totalOrdersValue) (src/test/LimitOrderBook.t.sol#546)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(5,totalOrdersValue) (src/test/LimitOrderBook.t.sol#546)
Reentrancy in SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1026)
	- cheatCodes.deal(address(swapHelper),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1027)
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- cheatCodes.deal(address(this),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1031)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	- IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1038)
	- orderIds[0] = placeMockOrderWrapper(orderWeth) (src/test/SandboxLimitOrderRouter.t.sol#1055)
		- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1830-1831)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.FillAmountSpecifiedGreaterThanAmountRemaining.selector,fillAmountWeth,wethQuantity,orderIds[0])) (src/test/SandboxLimitOrderRouter.t.sol#1063-1072)
	- (reverted) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(initializePreSandboxExecutionState(bytes32[][],uint128[]),orderIdBundles,fillAmounts)) (src/test/SandboxLimitOrderRouter.t.sol#1073-1080)
	External calls sending eth:
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(reverted) (src/test/SandboxLimitOrderRouter.t.sol#1081)
Reentrancy in SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101):
	External calls:
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1026)
	- cheatCodes.deal(address(swapHelper),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1027)
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- cheatCodes.deal(address(this),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1031)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	- IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1038)
	- orderIds[0] = placeMockOrderWrapper(orderWeth) (src/test/SandboxLimitOrderRouter.t.sol#1055)
		- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1830-1831)
	External calls sending eth:
	- depositGasCreditsForMockOrdersWrapper(type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1029)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(preSandboxExecutionState.initialTokenOutBalances[0],0) (src/test/SandboxLimitOrderRouter.t.sol#1094-1097)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(preSandboxExecutionState.initialTokenInBalances[0],wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1090-1093)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(preSandboxExecutionState.initialTokenInBalances[0],wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1090-1093)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(preSandboxExecutionState.initialTokenOutBalances[0],0) (src/test/SandboxLimitOrderRouter.t.sol#1094-1097)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(preSandboxExecutionState.initialTokenOutBalances[0],0) (src/test/SandboxLimitOrderRouter.t.sol#1094-1097)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(preSandboxExecutionState.initialTokenInBalances[0],wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1090-1093)
Reentrancy in SandboxLimitOrderBookTest.testPartialFillSandboxLimitOrder(uint128,uint128,uint8,uint8) (src/test/SandboxLimitOrderBook.t.sol#317-398):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#324)
	- IERC20(swapToken).approve(address(limitOrderExecutor),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#325-328)
	- swapHelper.swapEthForTokenWithUniV2(amountIn,swapToken) (src/test/SandboxLimitOrderBook.t.sol#333-396)
	- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#353-354)
	- sandboxLimitOrderBookWrapper.partialFillSandboxLimitOrder(uint128(amountOutTokenIn / amountInDivisor),amountOut / amountOutDivisor,orderId) (src/test/SandboxLimitOrderBook.t.sol#359-363)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderPostPartialFill.amountInRemaining,(uint128(amountOutTokenIn)) - uint128(amountOutTokenIn / amountInDivisor)) (src/test/SandboxLimitOrderBook.t.sol#386-390)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderPostPartialFill.amountOutRemaining,amountOut - amountOut / amountOutDivisor) (src/test/SandboxLimitOrderBook.t.sol#392-395)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderPostPartialFill.fillPercent,ConveyorMath.fromX64ToX16(ConveyorMath.divUU(uint128(amountOutTokenIn / amountInDivisor),uint128(amountOutTokenIn)))) (src/test/SandboxLimitOrderBook.t.sol#376-384)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(totalQuantityBefore - totalOrdersQuantityAfter,amountOutTokenIn / amountInDivisor) (src/test/SandboxLimitOrderBook.t.sol#371-374)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderPostPartialFill.amountInRemaining,(uint128(amountOutTokenIn)) - uint128(amountOutTokenIn / amountInDivisor)) (src/test/SandboxLimitOrderBook.t.sol#386-390)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderPostPartialFill.amountOutRemaining,amountOut - amountOut / amountOutDivisor) (src/test/SandboxLimitOrderBook.t.sol#392-395)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderPostPartialFill.fillPercent,ConveyorMath.fromX64ToX16(ConveyorMath.divUU(uint128(amountOutTokenIn / amountInDivisor),uint128(amountOutTokenIn)))) (src/test/SandboxLimitOrderBook.t.sol#376-384)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(totalQuantityBefore - totalOrdersQuantityAfter,amountOutTokenIn / amountInDivisor) (src/test/SandboxLimitOrderBook.t.sol#371-374)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderPostPartialFill.amountInRemaining,(uint128(amountOutTokenIn)) - uint128(amountOutTokenIn / amountInDivisor)) (src/test/SandboxLimitOrderBook.t.sol#386-390)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderPostPartialFill.amountOutRemaining,amountOut - amountOut / amountOutDivisor) (src/test/SandboxLimitOrderBook.t.sol#392-395)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderPostPartialFill.fillPercent,ConveyorMath.fromX64ToX16(ConveyorMath.divUU(uint128(amountOutTokenIn / amountInDivisor),uint128(amountOutTokenIn)))) (src/test/SandboxLimitOrderBook.t.sol#376-384)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(totalQuantityBefore - totalOrdersQuantityAfter,amountOutTokenIn / amountInDivisor) (src/test/SandboxLimitOrderBook.t.sol#371-374)
Reentrancy in LimitOrderBookTest.testPlaceOrder(uint256,uint256) (src/test/LimitOrderBook.t.sol#135-177):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#136)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#137)
	- swapHelper.swapEthForTokenWithUniV2(swapAmount,swapToken) (src/test/LimitOrderBook.t.sol#140-176)
	- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#158)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#175)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#168-173)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#175)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#168-173)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/LimitOrderBook.t.sol#168-173)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(orderBook.totalOrdersPerAddress(address(this)),1) (src/test/LimitOrderBook.t.sol#175)
Reentrancy in SandboxLimitOrderBookTest.testPlaceSandboxOrder(uint112,uint112) (src/test/SandboxLimitOrderBook.t.sol#401-457):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#405)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#406)
	- swapHelper.swapEthForTokenWithUniV2(amountInRemaining,swapToken) (src/test/SandboxLimitOrderBook.t.sol#409-455)
	- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#432-433)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#451-454)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#444-449)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#444-449)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#451-454)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(sandboxLimitOrderBook.totalOrdersPerAddress(address(this)),1) (src/test/SandboxLimitOrderBook.t.sol#451-454)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(sandboxLimitOrderBook.totalOrdersQuantity(keccak256(bytes)(abi.encode(address(this),swapToken))),amountOut) (src/test/SandboxLimitOrderBook.t.sol#444-449)
Reentrancy in LimitOrderQuoterTest.testSimulateAToBPriceChangeV2ReserveOutputs(uint112) (src/test/LimitOrderQuoter.t.sol#172-213):
	External calls:
	- (reserveA,reserveB) = limitOrderQuoter.simulateAToBPriceChange(_amountIn,reserveAIn,reserveBIn,pool,true) (src/test/LimitOrderQuoter.t.sol#186-193)
	- outputReserveB = scriptRunner.runPythonScript(path,args) (src/test/LimitOrderQuoter.t.sol#199-202)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(reserveA,expectedReserveA) (src/test/LimitOrderQuoter.t.sol#207)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(reserveB / 10 ** 9,expectedReserveB / 10 ** 9) (src/test/LimitOrderQuoter.t.sol#210)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(reserveA,expectedReserveA) (src/test/LimitOrderQuoter.t.sol#207)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(reserveB / 10 ** 9,expectedReserveB / 10 ** 9) (src/test/LimitOrderQuoter.t.sol#210)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(reserveA,expectedReserveA) (src/test/LimitOrderQuoter.t.sol#207)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(reserveB / 10 ** 9,expectedReserveB / 10 ** 9) (src/test/LimitOrderQuoter.t.sol#210)
Reentrancy in LimitOrderQuoterTest.testSimulateAToBPriceChangeV2SpotPrice(uint64) (src/test/LimitOrderQuoter.t.sol#216-247):
	External calls:
	- (spotPrice) = limitOrderQuoter.simulateAToBPriceChange(_amountIn,reserveAIn,reserveBIn,pool,true) (src/test/LimitOrderQuoter.t.sol#228-235)
	- spotOut = scriptRunner.runPythonScript(path,args) (src/test/LimitOrderQuoter.t.sol#241)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(spotPrice >> 75,spotPriceExpected >> 75) (src/test/LimitOrderQuoter.t.sol#244)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(spotPrice >> 75,spotPriceExpected >> 75) (src/test/LimitOrderQuoter.t.sol#244)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(spotPrice >> 75,spotPriceExpected >> 75) (src/test/LimitOrderQuoter.t.sol#244)
Reentrancy in LimitOrderQuoterTest.testSimulateAToWethPriceChangeV2() (src/test/LimitOrderQuoter.t.sol#360-384):
	External calls:
	- (newSpotPriceA,amountOut) = limitOrderQuoter.simulateAToWethPriceChange(50000000000000000000000,tokenToTokenExecutionPrice) (src/test/LimitOrderQuoter.t.sol#377-381)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newSpotPriceA,192714735056741134836410079523110912) (src/test/LimitOrderQuoter.t.sol#382)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(amountOut,28408586008574759898) (src/test/LimitOrderQuoter.t.sol#383)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(amountOut,28408586008574759898) (src/test/LimitOrderQuoter.t.sol#383)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newSpotPriceA,192714735056741134836410079523110912) (src/test/LimitOrderQuoter.t.sol#382)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(amountOut,28408586008574759898) (src/test/LimitOrderQuoter.t.sol#383)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newSpotPriceA,192714735056741134836410079523110912) (src/test/LimitOrderQuoter.t.sol#382)
Reentrancy in ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96CrossTick(uint112) (src/test/ConveyorTickMath.t.sol#203-252):
	External calls:
	- amountOutToValidate = uint256(- conveyorTickMath._simulateAmountOutOnSqrtPriceX96(token0,WETH,usdcWethPoolV3,_alphaX,tickSpacing,liquidity,500)) (src/test/ConveyorTickMath.t.sol#228-238)
	- amountOutExpected = iQuoter.quoteExactInputSingle(WETH,USDC,500,_alphaX,TickMath.MAX_SQRT_RATIO - 1) (src/test/ConveyorTickMath.t.sol#241-247)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(amountOutToValidate,amountOutExpected) (src/test/ConveyorTickMath.t.sol#250)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(amountOutToValidate,amountOutExpected) (src/test/ConveyorTickMath.t.sol#250)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(amountOutToValidate,amountOutExpected) (src/test/ConveyorTickMath.t.sol#250)
Reentrancy in ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneFalse(uint64) (src/test/ConveyorTickMath.t.sol#111-155):
	External calls:
	- amountOutExpected = iQuoter.quoteExactInputSingle(WETH,DAI,3000,_alphaX,TickMath.MAX_SQRT_RATIO - 1) (src/test/ConveyorTickMath.t.sol#126-132)
	- amountOutToValidate = uint256(- conveyorTickMath._simulateAmountOutOnSqrtPriceX96(token0,WETH,daiWethPoolV3,_alphaX,tickSpacing,liquidity,3000)) (src/test/ConveyorTickMath.t.sol#133-143)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [int]) (src/test/utils/test.sol#110)
		- assertEq(int256(amountOutToValidate) / 100,int256(amountOutExpected) / 100) (src/test/ConveyorTickMath.t.sol#147-150)
	- log_named_int(  Expected,b) (src/test/utils/test.sol#111)
		- assertEq(int256(amountOutToValidate) / 100,int256(amountOutExpected) / 100) (src/test/ConveyorTickMath.t.sol#147-150)
	- log_named_int(    Actual,a) (src/test/utils/test.sol#112)
		- assertEq(int256(amountOutToValidate) / 100,int256(amountOutExpected) / 100) (src/test/ConveyorTickMath.t.sol#147-150)
Reentrancy in ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneTrue(uint72) (src/test/ConveyorTickMath.t.sol#159-199):
	External calls:
	- amountOutExpected = iQuoter.quoteExactInputSingle(DAI,WETH,3000,_alphaX,TickMath.MIN_SQRT_RATIO + 1) (src/test/ConveyorTickMath.t.sol#174-180)
	- amountOutToValidate = uint256(- conveyorTickMath._simulateAmountOutOnSqrtPriceX96(token0,DAI,daiWethPoolV3,_alphaX,tickSpacing,liquidity,3000)) (src/test/ConveyorTickMath.t.sol#183-193)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(amountOutToValidate / 100,amountOutExpected / 100) (src/test/ConveyorTickMath.t.sol#196)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(amountOutToValidate / 100,amountOutExpected / 100) (src/test/ConveyorTickMath.t.sol#196)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(amountOutToValidate / 100,amountOutExpected / 100) (src/test/ConveyorTickMath.t.sol#196)
Reentrancy in LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneFalse(uint64) (src/test/LimitOrderQuoter.t.sol#290-329):
	External calls:
	- amountOut = iQuoter.quoteExactInputSingle(WETH,tokenOut,3000,_alphaX,sqrtPriceLimitX96) (src/test/LimitOrderQuoter.t.sol#311-317)
	- amountOutMin = limitOrderQuoter.calculateAmountOutMinAToWeth(poolAddress,_alphaX,0,3000,WETH) (src/test/LimitOrderQuoter.t.sol#318-325)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#327)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#327)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#327)
Reentrancy in LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneTrue(uint64) (src/test/LimitOrderQuoter.t.sol#249-288):
	External calls:
	- amountOut = iQuoter.quoteExactInputSingle(tokenIn,WETH,3000,_alphaX,sqrtPriceLimitX96) (src/test/LimitOrderQuoter.t.sol#270-276)
	- amountOutMin = limitOrderQuoter.calculateAmountOutMinAToWeth(poolAddress,_alphaX,0,3000,tokenIn) (src/test/LimitOrderQuoter.t.sol#277-284)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#286)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#286)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(amountOut,amountOutMin) (src/test/LimitOrderQuoter.t.sol#286)
Reentrancy in LimitOrderQuoterTest.testSimulateWethToBPriceChangeV2() (src/test/LimitOrderQuoter.t.sol#333-356):
	External calls:
	- (newSpotPriceB) = limitOrderQuoter.simulateWethToBPriceChange(5000000000000000000,tokenToTokenExecutionPrice) (src/test/LimitOrderQuoter.t.sol#350-354)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newSpotPriceB,63714967732803596813954797656252367241216) (src/test/LimitOrderQuoter.t.sol#355)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newSpotPriceB,63714967732803596813954797656252367241216) (src/test/LimitOrderQuoter.t.sol#355)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newSpotPriceB,63714967732803596813954797656252367241216) (src/test/LimitOrderQuoter.t.sol#355)
Reentrancy in LimitOrderBookTest.testUpdateOrder(uint128,uint64,uint128,uint128,uint64) (src/test/LimitOrderBook.t.sol#338-386):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderBook.t.sol#352)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderBook.t.sol#353)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/LimitOrderBook.t.sol#355)
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#356)
	- orderId = placeMockOrder(order) (src/test/LimitOrderBook.t.sol#368)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderBook.t.sol#589)
	- orderBook.updateOrder(orderId,newPrice,newQuantity) (src/test/LimitOrderBook.t.sol#371)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newPrice,updatedOrder.price) (src/test/LimitOrderBook.t.sol#384)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newQuantity,updatedOrder.quantity) (src/test/LimitOrderBook.t.sol#383)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newQuantity,totalOrdersValueAfter) (src/test/LimitOrderBook.t.sol#382)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newPrice,updatedOrder.price) (src/test/LimitOrderBook.t.sol#384)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newQuantity,updatedOrder.quantity) (src/test/LimitOrderBook.t.sol#383)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newQuantity,totalOrdersValueAfter) (src/test/LimitOrderBook.t.sol#382)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newQuantity,updatedOrder.quantity) (src/test/LimitOrderBook.t.sol#383)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newQuantity,totalOrdersValueAfter) (src/test/LimitOrderBook.t.sol#382)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newPrice,updatedOrder.price) (src/test/LimitOrderBook.t.sol#384)
Reentrancy in SandboxLimitOrderBookTest.testUpdateSandboxOrder(uint128,uint128) (src/test/SandboxLimitOrderBook.t.sol#589-636):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#593)
	- IERC20(swapToken).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#594)
	- cheatCodes.deal(address(swapHelper),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#596)
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#597)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#613)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- sandboxLimitOrderBook.updateSandboxLimitOrder(orderId,newAmountInRemaining,newAmountOutRemaining) (src/test/SandboxLimitOrderBook.t.sol#616-620)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newAmountInRemaining,updatedOrder.amountInRemaining) (src/test/SandboxLimitOrderBook.t.sol#634)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newAmountInRemaining,totalOrdersValueAfter) (src/test/SandboxLimitOrderBook.t.sol#633)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(newAmountOutRemaining,updatedOrder.amountOutRemaining) (src/test/SandboxLimitOrderBook.t.sol#635)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newAmountInRemaining,updatedOrder.amountInRemaining) (src/test/SandboxLimitOrderBook.t.sol#634)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newAmountInRemaining,totalOrdersValueAfter) (src/test/SandboxLimitOrderBook.t.sol#633)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(newAmountOutRemaining,updatedOrder.amountOutRemaining) (src/test/SandboxLimitOrderBook.t.sol#635)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newAmountInRemaining,updatedOrder.amountInRemaining) (src/test/SandboxLimitOrderBook.t.sol#634)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newAmountInRemaining,totalOrdersValueAfter) (src/test/SandboxLimitOrderBook.t.sol#633)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(newAmountOutRemaining,updatedOrder.amountOutRemaining) (src/test/SandboxLimitOrderBook.t.sol#635)
Reentrancy in LimitOrderRouterTest.testValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#242-275):
	External calls:
	- cheatCodes.deal(address(this),MAX_UINT) (src/test/LimitOrderRouter.t.sol#251)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/LimitOrderRouter.t.sol#253)
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#255)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#257-259)
	- orderId = placeMockOrder(order) (src/test/LimitOrderRouter.t.sol#262)
		- orderIds = orderBook.placeLimitOrder(orderGroup) (src/test/LimitOrderRouter.t.sol#537)
	- IWETH(WETH).withdraw(100000) (src/test/LimitOrderRouter.t.sol#264)
	- canceled = limitOrderRouter.validateAndCancelOrder(orderId) (src/test/LimitOrderRouter.t.sol#266)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/LimitOrderRouter.t.sol#255)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#257-259)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(canceled) (src/test/LimitOrderRouter.t.sol#267)
Reentrancy in SandboxLimitOrderBookTest.testValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#638-666):
	External calls:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#642)
		- cheatCodes.deal(address(this),_amount) (src/test/SandboxLimitOrderBook.t.sol#745)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#644)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#646-648)
	- IERC20(WETH).approve(address(limitOrderExecutor),MAX_UINT) (src/test/SandboxLimitOrderBook.t.sol#651)
	- orderId = placeMockSandboxLimitOrder(order) (src/test/SandboxLimitOrderBook.t.sol#652)
		- orderIds = sandboxLimitOrderBook.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderBook.t.sol#738-739)
	- IWETH(WETH).withdraw(100000) (src/test/SandboxLimitOrderBook.t.sol#654)
	- canceled = sandboxLimitOrderBook.validateAndCancelOrder(orderId) (src/test/SandboxLimitOrderBook.t.sol#656)
	External calls sending eth:
	- depositGasCreditsForMockOrders(type()(uint128).max) (src/test/SandboxLimitOrderBook.t.sol#642)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#646-648)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(canceled) (src/test/SandboxLimitOrderBook.t.sol#657)
Reentrancy in SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1103-1176):
	External calls:
	- initializeTestBalanceState(wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1126)
		- cheatCodes.deal(address(this),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1403)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
		- cheatCodes.deal(address(swapHelper),type()(uint128).max) (src/test/SandboxLimitOrderRouter.t.sol#1404)
		- cheatCodes.deal(address(this),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1407)
		- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1410-1412)
		- IERC20(WETH).approve(address(limitOrderExecutor),wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1414)
	- swapHelper.swapEthForTokenWithUniV2(daiQuantity,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1136-1173)
	- orderIds[0] = placeMockOrderWrapper(orders[0]) (src/test/SandboxLimitOrderRouter.t.sol#1159)
		- orderIds = sandboxLimitOrderBookWrapper.placeSandboxLimitOrder(orderGroup) (src/test/SandboxLimitOrderRouter.t.sol#1830-1831)
	- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
		- (status) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(validateSandboxExecutionAndFillOrders(bytes32[][],uint128[],LimitOrderRouter.PreSandboxExecutionState),orderIdBundles,fillAmounts,preSandboxExecutionState)) (src/test/SandboxLimitOrderRouter.t.sol#1220-1227)
		- sandboxLimitOrderBookWrapper.validateSandboxExecutionAndFillOrders(orderIdBundles,fillAmounts,preSandboxExecutionState) (src/test/SandboxLimitOrderRouter.t.sol#1230-1234)
		- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxFillAmountNotSatisfied.selector,orders[0].orderId,initialBalancesIn[0] - wethQuantity,fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
		- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxAmountOutRequiredNotSatisfied.selector,orders[0].orderId,amountOut,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0]))) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
	External calls sending eth:
	- initializeTestBalanceState(wethQuantity) (src/test/SandboxLimitOrderRouter.t.sol#1126)
		- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
		- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1410-1412)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- validateSandboxExecutionAndFillOrders(orderIdBundles,initialBalancesIn,initialBalancesOut,wethQuantity,orders,fillAmounts,amountOut) (src/test/SandboxLimitOrderRouter.t.sol#1164-1172)
Reentrancy in SandboxLimitOrderRouterTest.validateSandboxExecutionAndFillOrders(bytes32[][],uint256[],uint256[],uint256,SandboxLimitOrderBook.SandboxLimitOrder[],uint128[],uint256) (src/test/SandboxLimitOrderRouter.t.sol#1178-1272):
	External calls:
	- (status) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(validateSandboxExecutionAndFillOrders(bytes32[][],uint128[],LimitOrderRouter.PreSandboxExecutionState),orderIdBundles,fillAmounts,preSandboxExecutionState)) (src/test/SandboxLimitOrderRouter.t.sol#1220-1227)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxFillAmountNotSatisfied.selector,orders[0].orderId,initialBalancesIn[0] - wethQuantity,fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
	- cheatCodes.expectRevert(abi.encodeWithSelector(Errors.SandboxAmountOutRequiredNotSatisfied.selector,orders[0].orderId,amountOut,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0]))) (src/test/SandboxLimitOrderRouter.t.sol#1199-1218)
	Event emitted after the call(s):
	- log(Error: Assertion Failed) (src/test/utils/test.sol#60)
		- assertTrue(status) (src/test/SandboxLimitOrderRouter.t.sol#1228)
Reentrancy in SandboxLimitOrderRouterTest.validateSandboxExecutionAndFillOrders(bytes32[][],uint256[],uint256[],uint256,SandboxLimitOrderBook.SandboxLimitOrder[],uint128[],uint256) (src/test/SandboxLimitOrderRouter.t.sol#1178-1272):
	External calls:
	- sandboxLimitOrderBookWrapper.validateSandboxExecutionAndFillOrders(orderIdBundles,fillAmounts,preSandboxExecutionState) (src/test/SandboxLimitOrderRouter.t.sol#1230-1234)
	Event emitted after the call(s):
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(postExecutionOrder.feeRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(fillAmounts[0],orders[0].amountInRemaining),orders[0].feeRemaining)) (src/test/SandboxLimitOrderRouter.t.sol#1259-1268)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(postExecutionOrder.amountInRemaining,orders[0].amountInRemaining - fillAmounts[0]) (src/test/SandboxLimitOrderRouter.t.sol#1243-1246)
	- log(Error: a == b not satisfied [uint]) (src/test/utils/test.sol#124)
		- assertEq(postExecutionOrder.amountOutRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1248-1257)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(postExecutionOrder.feeRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(fillAmounts[0],orders[0].amountInRemaining),orders[0].feeRemaining)) (src/test/SandboxLimitOrderRouter.t.sol#1259-1268)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(postExecutionOrder.amountOutRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1248-1257)
	- log_named_uint(  Expected,b) (src/test/utils/test.sol#125)
		- assertEq(postExecutionOrder.amountInRemaining,orders[0].amountInRemaining - fillAmounts[0]) (src/test/SandboxLimitOrderRouter.t.sol#1243-1246)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(postExecutionOrder.amountOutRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(orders[0].amountOutRemaining,orders[0].amountInRemaining),fillAmounts[0])) (src/test/SandboxLimitOrderRouter.t.sol#1248-1257)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(postExecutionOrder.feeRemaining,ConveyorMath.mul64U(ConveyorMath.divUU(fillAmounts[0],orders[0].amountInRemaining),orders[0].feeRemaining)) (src/test/SandboxLimitOrderRouter.t.sol#1259-1268)
	- log_named_uint(    Actual,a) (src/test/utils/test.sol#126)
		- assertEq(postExecutionOrder.amountInRemaining,orders[0].amountInRemaining - fillAmounts[0]) (src/test/SandboxLimitOrderRouter.t.sol#1243-1246)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3

LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) uses timestamp for comparisons
	Dangerous comparisons:
	- assert(bool)(order0_scope_1.lastRefreshTimestamp == block.timestamp) (src/test/LimitOrderRouter.t.sol#358)
SandboxLimitOrderBookTest.testRefreshOrder() (src/test/SandboxLimitOrderBook.t.sol#202-244) uses timestamp for comparisons
	Dangerous comparisons:
	- assert(bool)(orderPostRefresh.lastRefreshTimestamp == block.timestamp) (src/test/SandboxLimitOrderBook.t.sol#242)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) uses timestamp for comparisons
	Dangerous comparisons:
	- ! (block.timestamp == lastGasOracleTimestamp) (src/ConveyorGasOracle.sol#48)
	- block.timestamp - lastGasOracleTimestamp > timeHorizon (src/ConveyorGasOracle.sol#53)
LimitOrderRouter._refreshLimitOrder(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#143-190) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > order.expirationTimestamp (src/LimitOrderRouter.sol#151)
	- currentBalance < REFRESH_FEE (src/LimitOrderRouter.sol#156)
	- IERC20(order.tokenIn).balanceOf(order.owner) < order.quantity (src/LimitOrderRouter.sol#160)
	- block.timestamp - order.lastRefreshTimestamp < REFRESH_INTERVAL (src/LimitOrderRouter.sol#165)
LimitOrderRouter.validateAndCancelOrder(bytes32) (src/LimitOrderRouter.sol#195-213) uses timestamp for comparisons
	Dangerous comparisons:
	- IERC20(order.tokenIn).balanceOf(order.owner) < order.quantity (src/LimitOrderRouter.sol#202)
LimitOrderRouter._cancelLimitOrderViaExecutor(LimitOrderBook.LimitOrder) (src/LimitOrderRouter.sol#218-261) uses timestamp for comparisons
	Dangerous comparisons:
	- orderOwnerGasCreditBalance > executorFee (src/LimitOrderRouter.sol#240)
LimitOrderRouter.executeLimitOrders(bytes32[]) (src/LimitOrderRouter.sol#331-419) uses timestamp for comparisons
	Dangerous comparisons:
	- orders[i].orderId == bytes32(0) (src/LimitOrderRouter.sol#353)
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394) uses timestamp for comparisons
	Dangerous comparisons:
	- tokenBalance < updatedTotalOrdersValue (src/SandboxLimitOrderBook.sol#316)
	- totalApprovedQuantity < updatedTotalOrdersValue (src/SandboxLimitOrderBook.sol#382)
SandboxLimitOrderBook.updateSandboxLimitOrder(bytes32,uint128,uint128) (src/SandboxLimitOrderBook.sol#400-454) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#407)
	- IERC20(order.tokenIn).balanceOf(msg.sender) < totalOrdersValue (src/SandboxLimitOrderBook.sol#418)
	- totalApprovedQuantity < amountInRemaining (src/SandboxLimitOrderBook.sol#436)
SandboxLimitOrderBook.cancelOrder(bytes32) (src/SandboxLimitOrderBook.sol#470-506) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#474)
	- order.owner != msg.sender (src/SandboxLimitOrderBook.sol#478)
SandboxLimitOrderBook.validateAndCancelOrder(bytes32) (src/SandboxLimitOrderBook.sol#511-534) uses timestamp for comparisons
	Dangerous comparisons:
	- IERC20(order.tokenIn).balanceOf(order.owner) < order.amountInRemaining (src/SandboxLimitOrderBook.sol#520-521)
SandboxLimitOrderBook._cancelSandboxLimitOrderViaExecutor(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#539-581) uses timestamp for comparisons
	Dangerous comparisons:
	- orderOwnerGasCreditBalance > executorFee (src/SandboxLimitOrderBook.sol#560)
SandboxLimitOrderBook._refreshSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder) (src/SandboxLimitOrderBook.sol#614-667) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > order.expirationTimestamp (src/SandboxLimitOrderBook.sol#619)
	- ILimitOrderExecutor(LIMIT_ORDER_EXECUTOR).gasCreditBalance(order.owner) < REFRESH_FEE (src/SandboxLimitOrderBook.sol#625-627)
	- IERC20(order.tokenIn).balanceOf(order.owner) < order.amountInRemaining (src/SandboxLimitOrderBook.sol#633-634)
	- block.timestamp - order.lastRefreshTimestamp < REFRESH_INTERVAL (src/SandboxLimitOrderBook.sol#640)
SandboxLimitOrderBook._initializePreSandboxExecutionState(bytes32[][],uint128[]) (src/SandboxLimitOrderBook.sol#725-816) uses timestamp for comparisons
	Dangerous comparisons:
	- currentOrder.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#764)
	- amountSpecifiedToFill > currentOrder.amountInRemaining (src/SandboxLimitOrderBook.sol#780)
SandboxLimitOrderBook._resolveCompletedOrder(bytes32) (src/SandboxLimitOrderBook.sol#1248-1275) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#1255)
SandboxLimitOrderBook.getSandboxLimitOrderById(bytes32) (src/SandboxLimitOrderBook.sol#1367-1378) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/SandboxLimitOrderBook.sol#1373)
LimitOrderBook.getLimitOrderById(bytes32) (src/LimitOrderBook.sol#156-168) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/LimitOrderBook.sol#163)
LimitOrderBook.placeLimitOrder(LimitOrderBook.LimitOrder[]) (src/LimitOrderBook.sol#173-299) uses timestamp for comparisons
	Dangerous comparisons:
	- tokenBalance < updatedTotalOrdersValue (src/LimitOrderBook.sol#221)
	- totalApprovedQuantity < updatedTotalOrdersValue (src/LimitOrderBook.sol#287)
LimitOrderBook._updateLimitOrder(bytes32,uint128,uint128) (src/LimitOrderBook.sol#369-419) uses timestamp for comparisons
	Dangerous comparisons:
	- IERC20(order.tokenIn).balanceOf(msg.sender) < totalOrdersValue (src/LimitOrderBook.sol#385)
	- totalApprovedQuantity < quantity (src/LimitOrderBook.sol#403)
LimitOrderBook.cancelOrder(bytes32) (src/LimitOrderBook.sol#423-459) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/LimitOrderBook.sol#427)
	- order.owner != msg.sender (src/LimitOrderBook.sol#431)
LimitOrderBook._resolveCompletedOrder(bytes32) (src/LimitOrderBook.sol#494-520) uses timestamp for comparisons
	Dangerous comparisons:
	- order.orderId == bytes32(0) (src/LimitOrderBook.sol#499)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp

UnsafeMath.divRoundingUp(uint256,uint256) (lib/libraries/Uniswap/UnsafeMath.sol#12-16) uses assembly
	- INLINE ASM (lib/libraries/Uniswap/UnsafeMath.sol#13-15)
LimitOrderSwapRouter._safeTransferETH(address,uint256) (src/LimitOrderSwapRouter.sol#163-174) uses assembly
	- INLINE ASM (src/LimitOrderSwapRouter.sol#166-169)
LimitOrderSwapRouter._lpIsNotUniV3(address) (src/LimitOrderSwapRouter.sol#695-717) uses assembly
	- INLINE ASM (src/LimitOrderSwapRouter.sol#697-713)
LimitOrderQuoterTest.testSimulateAToBPriceChangeV2ReserveOutputs(uint112) (src/test/LimitOrderQuoter.t.sol#172-213) uses assembly
	- INLINE ASM (src/test/LimitOrderQuoter.t.sol#180-182)
LimitOrderQuoterTest.testSimulateAToBPriceChangeV2SpotPrice(uint64) (src/test/LimitOrderQuoter.t.sol#216-247) uses assembly
	- INLINE ASM (src/test/LimitOrderQuoter.t.sol#222-224)
FullMath.mulDiv(uint256,uint256,uint256) (lib/libraries/Uniswap/FullMath.sol#14-108) uses assembly
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#27-31)
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#36-38)
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#53-55)
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#57-60)
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#67-69)
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#72-74)
	- INLINE ASM (lib/libraries/Uniswap/FullMath.sol#78-80)
console._sendLogPayload(bytes) (src/test/utils/Console.sol#7-14) uses assembly
	- INLINE ASM (src/test/utils/Console.sol#10-13)
LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271) uses assembly
	- INLINE ASM (src/test/LimitOrderExecutor.t.sol#237-239)
Address._revert(bytes,string) (lib/utils/Address.sol#231-243) uses assembly
	- INLINE ASM (lib/utils/Address.sol#236-239)
LimitOrderRouter.executeLimitOrders(bytes32[]) (src/LimitOrderRouter.sol#331-419) uses assembly
	- INLINE ASM (src/LimitOrderRouter.sol#339-341)
LimitOrderRouter._calculateExecutionGasConsumed(uint256,uint256,LimitOrderBook.OrderType) (src/LimitOrderRouter.sol#457-478) uses assembly
	- INLINE ASM (src/LimitOrderRouter.sol#462-467)
SandboxLimitOrderBook.executeOrdersViaSandboxMulticall(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderBook.sol#679-719) uses assembly
	- INLINE ASM (src/SandboxLimitOrderBook.sol#683-685)
SandboxLimitOrderBook._calculateExecutionGasConsumed(uint256,uint256,SandboxLimitOrderBook.OrderType) (src/SandboxLimitOrderBook.sol#1104-1125) uses assembly
	- INLINE ASM (src/SandboxLimitOrderBook.sol#1109-1114)
SandboxLimitOrderBook.getOrderIds(address,SandboxLimitOrderBook.OrderType,uint256,uint256) (src/SandboxLimitOrderBook.sol#1386-1433) uses assembly
	- INLINE ASM (src/SandboxLimitOrderBook.sol#1398-1404)
	- INLINE ASM (src/SandboxLimitOrderBook.sol#1408-1413)
	- INLINE ASM (src/SandboxLimitOrderBook.sol#1428-1430)
SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101) uses assembly
	- INLINE ASM (src/test/SandboxLimitOrderRouter.t.sol#1018-1023)
LimitOrderQuoter._lpIsNotUniV3(address) (src/LimitOrderQuoter.sol#23-45) uses assembly
	- INLINE ASM (src/LimitOrderQuoter.sol#25-41)
LimitOrderExecutor._requireConveyorFeeIsPaid(uint256,uint256) (src/LimitOrderExecutor.sol#753-781) uses assembly
	- INLINE ASM (src/LimitOrderExecutor.sol#763-770)
LimitOrderBook.getOrderIds(address,LimitOrderBook.OrderType,uint256,uint256) (src/LimitOrderBook.sol#570-617) uses assembly
	- INLINE ASM (src/LimitOrderBook.sol#582-588)
	- INLINE ASM (src/LimitOrderBook.sol#592-597)
	- INLINE ASM (src/LimitOrderBook.sol#612-614)
TickMath.getTickAtSqrtRatio(uint160) (lib/libraries/Uniswap/TickMath.sol#68-213) uses assembly
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#77-81)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#82-86)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#87-91)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#92-96)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#97-101)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#102-106)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#107-111)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#112-115)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#122-127)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#128-133)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#134-139)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#140-145)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#146-151)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#152-157)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#158-163)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#164-169)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#170-175)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#176-181)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#182-187)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#188-193)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#194-199)
	- INLINE ASM (lib/libraries/Uniswap/TickMath.sol#200-204)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage

Different versions of Solidity are used:
	- Version used: ['0.8.16', '>=0.4.0', '>=0.4.22', '>=0.4.23', '>=0.5.0', '>=0.6.2', '>=0.7.0', '>=0.7.5', '^0.8.0', '^0.8.1', '^0.8.16']
	- 0.8.16 (src/interfaces/ILimitOrderBook.sol#2)
	- 0.8.16 (src/test/LimitOrderRouter.t.sol#2)
	- 0.8.16 (src/test/ConveyorGasOracle.t.sol#2)
	- ^0.8.0 (lib/libraries/token/SafeERC20.sol#4)
	- 0.8.16 (src/test/utils/Swap.sol#2)
	- 0.8.16 (lib/interfaces/token/IWETH.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v2/IUniswapV2Factory.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#2)
	- >=0.5.0 (lib/libraries/Uniswap/UnsafeMath.sol#2)
	- ^0.8.0 (lib/libraries/Uniswap/SqrtPriceMath.sol#2)
	- 0.8.16 (src/SandboxLimitOrderRouter.sol#2)
	- 0.8.16 (src/interfaces/IConveyorGasOracle.sol#2)
	- 0.8.16 (src/test/SandboxLimitOrderBook.t.sol#2)
	- 0.8.16 (src/test/LimitOrderBook.t.sol#2)
	- 0.8.16 (src/LimitOrderSwapRouter.sol#2)
	- >=0.7.5 (lib/interfaces/uniswap-v3/IQuoter.sol#2)
	- v2 (lib/interfaces/uniswap-v3/IQuoter.sol#3)
	- 0.8.16 (src/test/SwapRouter.t.sol#2)
	- 0.8.16 (src/lib/ConveyorTickMath.sol#2)
	- 0.8.16 (src/test/LimitOrderQuoter.t.sol#2)
	- ^0.8.0 (lib/libraries/Uniswap/Tick.sol#2)
	- 0.8.16 (src/test/utils/Utils.sol#2)
	- ^0.8.0 (lib/libraries/Uniswap/SwapMath.sol#2)
	- ^0.8.0 (lib/libraries/Uniswap/FullMath.sol#2)
	- >=0.4.22 (src/test/utils/Console.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#2)
	- 0.8.16 (src/interfaces/ISandboxLimitOrderRouter.sol#2)
	- 0.8.16 (src/interfaces/ILimitOrderRouter.sol#2)
	- 0.8.16 (src/ConveyorErrors.sol#2)
	- 0.8.16 (src/test/LimitOrderExecutor.t.sol#2)
	- ^0.8.16 (src/test/ConveyorTickMath.t.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3Factory.sol#2)
	- 0.8.16 (src/lib/ConveyorFeeMath.sol#2)
	- 0.8.16 (src/ConveyorGasOracle.sol#2)
	- ^0.8.1 (lib/utils/Address.sol#4)
	- ^0.8.0 (lib/interfaces/token/draft-IERC20Permit.sol#4)
	- >=0.4.23 (src/test/utils/test.sol#16)
	- >=0.7.5 (lib/interfaces/uniswap-v3/ISwapRouter.sol#2)
	- v2 (lib/interfaces/uniswap-v3/ISwapRouter.sol#3)
	- 0.8.16 (src/LimitOrderRouter.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolImmutables.sol#2)
	- 0.8.16 (src/SandboxLimitOrderBook.sol#2)
	- 0.8.16 (src/interfaces/ILimitOrderSwapRouter.sol#2)
	- 0.8.16 (src/test/ConveyorSwapAggregator.t.sol#2)
	- 0.8.16 (src/test/SandboxLimitOrderRouter.t.sol#2)
	- >=0.4.0 (lib/libraries/Uniswap/FixedPoint96.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3Pool.sol#2)
	- >=0.5.0 (lib/libraries/Uniswap/SafeCast.sol#2)
	- 0.8.16 (src/ConveyorSwapAggregator.sol#2)
	- 0.8.16 (src/LimitOrderQuoter.sol#2)
	- >=0.5.0 (lib/libraries/Uniswap/LiquidityMath.sol#2)
	- 0.8.16 (src/LimitOrderExecutor.sol#2)
	- 0.8.16 (src/test/ConveyorFeeMath.t.sol#2)
	- ^0.8.0 (lib/libraries/Uniswap/TickBitmap.sol#2)
	- >=0.7.0 (lib/libraries/Uniswap/LowGasSafeMath.sol#2)
	- 0.8.16 (src/lib/ConveyorMath.sol#2)
	- 0.8.16 (lib/libraries/QuadruplePrecision.sol#2)
	- 0.8.16 (src/LimitOrderBook.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolDerivedState.sol#2)
	- 0.8.16 (src/interfaces/ISandboxLimitOrderBook.sol#2)
	- 0.8.16 (lib/AggregatorV3Interface.sol#2)
	- 0.8.16 (src/test/utils/ScriptRunner.sol#3)
	- 0.8.16 (src/interfaces/IConveyorSwapAggregator.sol#2)
	- 0.8.16 (lib/interfaces/token/IERC20.sol#2)
	- 0.8.16 (src/interfaces/ILimitOrderExecutor.sol#2)
	- >=0.6.2 (lib/interfaces/uniswap-v2/IUniswapV2Router01.sol#2)
	- ^0.8.0 (lib/libraries/Uniswap/TickMath.sol#2)
	- 0.8.16 (src/interfaces/ILimitOrderQuoter.sol#2)
	- >=0.6.2 (lib/interfaces/uniswap-v2/IUniswapV2Router02.sol#2)
	- >=0.5.0 (lib/libraries/Uniswap/BitMath.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v2/IUniswapV2Pair.sol#2)
	- >=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolActions.sol#2)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used

LimitOrderBook._removeOrderFromSystem(bytes32) (src/LimitOrderBook.sol#475-490) has costly operations inside a loop:
	- delete orderIdToLimitOrder[orderId] (src/LimitOrderBook.sol#479)
LimitOrderBook._resolveCompletedOrder(bytes32) (src/LimitOrderBook.sol#494-520) has costly operations inside a loop:
	- delete orderIdToLimitOrder[orderId] (src/LimitOrderBook.sol#504)
LimitOrderBook.placeLimitOrder(LimitOrderBook.LimitOrder[]) (src/LimitOrderBook.sol#173-299) has costly operations inside a loop:
	- orderNonce += 2 (src/LimitOrderBook.sol#239)
LimitOrderBook.cancelOrder(bytes32) (src/LimitOrderBook.sol#423-459) has costly operations inside a loop:
	- delete orderIdToLimitOrder[orderId] (src/LimitOrderBook.sol#436)
SandboxLimitOrderBook.placeSandboxLimitOrder(SandboxLimitOrderBook.SandboxLimitOrder[]) (src/SandboxLimitOrderBook.sol#214-394) has costly operations inside a loop:
	- orderNonce += 2 (src/SandboxLimitOrderBook.sol#334)
SandboxLimitOrderBook.cancelOrder(bytes32) (src/SandboxLimitOrderBook.sol#470-506) has costly operations inside a loop:
	- delete orderIdToSandboxLimitOrder[orderId] (src/SandboxLimitOrderBook.sol#483)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- cumulativeSum = meanGasPrice + gasPrice (src/ConveyorGasOracle.sol#54)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- arithmeticscale = 2 (src/ConveyorGasOracle.sol#55)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- meanGasPrice = cumulativeSum / arithmeticscale (src/ConveyorGasOracle.sol#56)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- lastGasOracleTimestamp = block.timestamp (src/ConveyorGasOracle.sol#71)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- cumulativeSum += gasPrice (src/ConveyorGasOracle.sol#58)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- arithmeticscale ++ (src/ConveyorGasOracle.sol#59)
ConveyorGasOracle.getGasPrice() (src/ConveyorGasOracle.sol#47-85) has costly operations inside a loop:
	- meanGasPrice = cumulativeSum / arithmeticscale (src/ConveyorGasOracle.sol#60)
SandboxLimitOrderBook._removeOrderFromSystem(bytes32) (src/SandboxLimitOrderBook.sol#1228-1244) has costly operations inside a loop:
	- delete orderIdToSandboxLimitOrder[order.orderId] (src/SandboxLimitOrderBook.sol#1233)
DSTest.fail() (src/test/utils/test.sol#47-49) has costly operations inside a loop:
	- failed = true (src/test/utils/test.sol#48)
LimitOrderSwapRouter._swapV3(address,address,address,uint24,uint256,uint256,address,address) (src/LimitOrderSwapRouter.sol#395-441) has costly operations inside a loop:
	- uniV3AmountOut = 0 (src/LimitOrderSwapRouter.sol#438)
LimitOrderSwapRouter.constructor(bytes32[],address[],bool[]) (src/LimitOrderSwapRouter.sol#127-158) has costly operations inside a loop:
	- UNISWAP_V3_FACTORY = uniswapV3Factory (src/LimitOrderSwapRouter.sol#156)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop

DSTest.assertEq(address,address,string) (src/test/utils/test.sol#80-85) is never used and should be removed
DSTest.assertEq(bytes32,bytes32,string) (src/test/utils/test.sol#95-100) is never used and should be removed
DSTest.assertEq(int256,int256,string) (src/test/utils/test.sol#116-121) is never used and should be removed
DSTest.assertEq(string,string) (src/test/utils/test.sol#393-400) is never used and should be removed
DSTest.assertEq(string,string,string) (src/test/utils/test.sol#401-406) is never used and should be removed
DSTest.assertEq(uint256,uint256,string) (src/test/utils/test.sol#130-135) is never used and should be removed
DSTest.assertEq0(bytes,bytes) (src/test/utils/test.sol#420-427) is never used and should be removed
DSTest.assertEq0(bytes,bytes,string) (src/test/utils/test.sol#428-433) is never used and should be removed
DSTest.assertEq32(bytes32,bytes32) (src/test/utils/test.sol#101-103) is never used and should be removed
DSTest.assertEq32(bytes32,bytes32,string) (src/test/utils/test.sol#104-106) is never used and should be removed
DSTest.assertEqDecimal(int256,int256,uint256) (src/test/utils/test.sol#136-143) is never used and should be removed
DSTest.assertEqDecimal(int256,int256,uint256,string) (src/test/utils/test.sol#144-149) is never used and should be removed
DSTest.assertEqDecimal(uint256,uint256,uint256) (src/test/utils/test.sol#150-157) is never used and should be removed
DSTest.assertEqDecimal(uint256,uint256,uint256,string) (src/test/utils/test.sol#158-163) is never used and should be removed
DSTest.assertGe(int256,int256) (src/test/utils/test.sol#236-243) is never used and should be removed
DSTest.assertGe(int256,int256,string) (src/test/utils/test.sol#244-249) is never used and should be removed
DSTest.assertGe(uint256,uint256,string) (src/test/utils/test.sol#230-235) is never used and should be removed
DSTest.assertGeDecimal(int256,int256,uint256) (src/test/utils/test.sol#250-257) is never used and should be removed
DSTest.assertGeDecimal(int256,int256,uint256,string) (src/test/utils/test.sol#258-263) is never used and should be removed
DSTest.assertGeDecimal(uint256,uint256,uint256) (src/test/utils/test.sol#264-271) is never used and should be removed
DSTest.assertGeDecimal(uint256,uint256,uint256,string) (src/test/utils/test.sol#272-277) is never used and should be removed
DSTest.assertGt(int256,int256) (src/test/utils/test.sol#179-186) is never used and should be removed
DSTest.assertGt(int256,int256,string) (src/test/utils/test.sol#187-192) is never used and should be removed
DSTest.assertGt(uint256,uint256) (src/test/utils/test.sol#165-172) is never used and should be removed
DSTest.assertGt(uint256,uint256,string) (src/test/utils/test.sol#173-178) is never used and should be removed
DSTest.assertGtDecimal(int256,int256,uint256) (src/test/utils/test.sol#193-200) is never used and should be removed
DSTest.assertGtDecimal(int256,int256,uint256,string) (src/test/utils/test.sol#201-206) is never used and should be removed
DSTest.assertGtDecimal(uint256,uint256,uint256) (src/test/utils/test.sol#207-214) is never used and should be removed
DSTest.assertGtDecimal(uint256,uint256,uint256,string) (src/test/utils/test.sol#215-220) is never used and should be removed
DSTest.assertLe(int256,int256) (src/test/utils/test.sol#350-357) is never used and should be removed
DSTest.assertLe(int256,int256,string) (src/test/utils/test.sol#358-363) is never used and should be removed
DSTest.assertLe(uint256,uint256,string) (src/test/utils/test.sol#344-349) is never used and should be removed
DSTest.assertLeDecimal(int256,int256,uint256) (src/test/utils/test.sol#364-371) is never used and should be removed
DSTest.assertLeDecimal(int256,int256,uint256,string) (src/test/utils/test.sol#372-377) is never used and should be removed
DSTest.assertLeDecimal(uint256,uint256,uint256) (src/test/utils/test.sol#378-385) is never used and should be removed
DSTest.assertLeDecimal(uint256,uint256,uint256,string) (src/test/utils/test.sol#386-391) is never used and should be removed
DSTest.assertLt(int256,int256) (src/test/utils/test.sol#293-300) is never used and should be removed
DSTest.assertLt(int256,int256,string) (src/test/utils/test.sol#301-306) is never used and should be removed
DSTest.assertLt(uint256,uint256) (src/test/utils/test.sol#279-286) is never used and should be removed
DSTest.assertLt(uint256,uint256,string) (src/test/utils/test.sol#287-292) is never used and should be removed
DSTest.assertLtDecimal(int256,int256,uint256) (src/test/utils/test.sol#307-314) is never used and should be removed
DSTest.assertLtDecimal(int256,int256,uint256,string) (src/test/utils/test.sol#315-320) is never used and should be removed
DSTest.assertLtDecimal(uint256,uint256,uint256) (src/test/utils/test.sol#321-328) is never used and should be removed
DSTest.assertLtDecimal(uint256,uint256,uint256,string) (src/test/utils/test.sol#329-334) is never used and should be removed
DSTest.assertTrue(bool,string) (src/test/utils/test.sol#65-70) is never used and should be removed
DSTest.checkEq0(bytes,bytes) (src/test/utils/test.sol#408-419) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#3030-3088) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2527-2583) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderExecutor.t.sol#2380-2422) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderExecutor.t.sol#2424-2466) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2203-2260) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2321-2378) is never used and should be removed
LimitOrderExecutorTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1830-1887) is never used and should be removed
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2468-2525) is never used and should be removed
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) is never used and should be removed
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2144-2201) is never used and should be removed
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) is never used and should be removed
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2262-2319) is never used and should be removed
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1771-1828) is never used and should be removed
LimitOrderRouterTest.placeMultipleMockOrder(LimitOrderBook.LimitOrder[]) (src/test/LimitOrderRouter.t.sol#542-549) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1752-1858) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#1643-1690) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderRouter.t.sol#1597-1641) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderRouter.t.sol#559-629) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#631-708) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderRouter.t.sol#1029-1094) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1480-1537) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1156-1213) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1274-1331) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#783-840) is never used and should be removed
LimitOrderRouterTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderRouter.t.sol#710-781) is never used and should be removed
SandboxLimitOrderRouterTest.initializePreExecutionOwnerBalances(address[],address[],address[]) (src/test/SandboxLimitOrderRouter.t.sol#1323-1346) is never used and should be removed
SwapRouterTest.newMockOrder(address,address,uint128,bool,bool,uint16,uint112,uint112,uint16,uint16,uint32,uint32) (src/test/SwapRouter.t.sol#483-515) is never used and should be removed
console.log() (src/test/utils/Console.sol#16-18) is never used and should be removed
console.log(address,address) (src/test/utils/Console.sol#248-250) is never used and should be removed
console.log(address,address,address) (src/test/utils/Console.sol#504-506) is never used and should be removed
console.log(address,address,address,address) (src/test/utils/Console.sol#1528-1530) is never used and should be removed
console.log(address,address,address,bool) (src/test/utils/Console.sol#1524-1526) is never used and should be removed
console.log(address,address,address,string) (src/test/utils/Console.sol#1520-1522) is never used and should be removed
console.log(address,address,address,uint256) (src/test/utils/Console.sol#1516-1518) is never used and should be removed
console.log(address,address,bool) (src/test/utils/Console.sol#500-502) is never used and should be removed
console.log(address,address,bool,address) (src/test/utils/Console.sol#1512-1514) is never used and should be removed
console.log(address,address,bool,bool) (src/test/utils/Console.sol#1508-1510) is never used and should be removed
console.log(address,address,bool,string) (src/test/utils/Console.sol#1504-1506) is never used and should be removed
console.log(address,address,bool,uint256) (src/test/utils/Console.sol#1500-1502) is never used and should be removed
console.log(address,address,string) (src/test/utils/Console.sol#496-498) is never used and should be removed
console.log(address,address,string,address) (src/test/utils/Console.sol#1496-1498) is never used and should be removed
console.log(address,address,string,bool) (src/test/utils/Console.sol#1492-1494) is never used and should be removed
console.log(address,address,string,string) (src/test/utils/Console.sol#1488-1490) is never used and should be removed
console.log(address,address,string,uint256) (src/test/utils/Console.sol#1484-1486) is never used and should be removed
console.log(address,address,uint256) (src/test/utils/Console.sol#492-494) is never used and should be removed
console.log(address,address,uint256,address) (src/test/utils/Console.sol#1480-1482) is never used and should be removed
console.log(address,address,uint256,bool) (src/test/utils/Console.sol#1476-1478) is never used and should be removed
console.log(address,address,uint256,string) (src/test/utils/Console.sol#1472-1474) is never used and should be removed
console.log(address,address,uint256,uint256) (src/test/utils/Console.sol#1468-1470) is never used and should be removed
console.log(address,bool) (src/test/utils/Console.sol#244-246) is never used and should be removed
console.log(address,bool,address) (src/test/utils/Console.sol#488-490) is never used and should be removed
console.log(address,bool,address,address) (src/test/utils/Console.sol#1464-1466) is never used and should be removed
console.log(address,bool,address,bool) (src/test/utils/Console.sol#1460-1462) is never used and should be removed
console.log(address,bool,address,string) (src/test/utils/Console.sol#1456-1458) is never used and should be removed
console.log(address,bool,address,uint256) (src/test/utils/Console.sol#1452-1454) is never used and should be removed
console.log(address,bool,bool) (src/test/utils/Console.sol#484-486) is never used and should be removed
console.log(address,bool,bool,address) (src/test/utils/Console.sol#1448-1450) is never used and should be removed
console.log(address,bool,bool,bool) (src/test/utils/Console.sol#1444-1446) is never used and should be removed
console.log(address,bool,bool,string) (src/test/utils/Console.sol#1440-1442) is never used and should be removed
console.log(address,bool,bool,uint256) (src/test/utils/Console.sol#1436-1438) is never used and should be removed
console.log(address,bool,string) (src/test/utils/Console.sol#480-482) is never used and should be removed
console.log(address,bool,string,address) (src/test/utils/Console.sol#1432-1434) is never used and should be removed
console.log(address,bool,string,bool) (src/test/utils/Console.sol#1428-1430) is never used and should be removed
console.log(address,bool,string,string) (src/test/utils/Console.sol#1424-1426) is never used and should be removed
console.log(address,bool,string,uint256) (src/test/utils/Console.sol#1420-1422) is never used and should be removed
console.log(address,bool,uint256) (src/test/utils/Console.sol#476-478) is never used and should be removed
console.log(address,bool,uint256,address) (src/test/utils/Console.sol#1416-1418) is never used and should be removed
console.log(address,bool,uint256,bool) (src/test/utils/Console.sol#1412-1414) is never used and should be removed
console.log(address,bool,uint256,string) (src/test/utils/Console.sol#1408-1410) is never used and should be removed
console.log(address,bool,uint256,uint256) (src/test/utils/Console.sol#1404-1406) is never used and should be removed
console.log(address,string) (src/test/utils/Console.sol#240-242) is never used and should be removed
console.log(address,string,address) (src/test/utils/Console.sol#472-474) is never used and should be removed
console.log(address,string,address,address) (src/test/utils/Console.sol#1400-1402) is never used and should be removed
console.log(address,string,address,bool) (src/test/utils/Console.sol#1396-1398) is never used and should be removed
console.log(address,string,address,string) (src/test/utils/Console.sol#1392-1394) is never used and should be removed
console.log(address,string,address,uint256) (src/test/utils/Console.sol#1388-1390) is never used and should be removed
console.log(address,string,bool) (src/test/utils/Console.sol#468-470) is never used and should be removed
console.log(address,string,bool,address) (src/test/utils/Console.sol#1384-1386) is never used and should be removed
console.log(address,string,bool,bool) (src/test/utils/Console.sol#1380-1382) is never used and should be removed
console.log(address,string,bool,string) (src/test/utils/Console.sol#1376-1378) is never used and should be removed
console.log(address,string,bool,uint256) (src/test/utils/Console.sol#1372-1374) is never used and should be removed
console.log(address,string,string) (src/test/utils/Console.sol#464-466) is never used and should be removed
console.log(address,string,string,address) (src/test/utils/Console.sol#1368-1370) is never used and should be removed
console.log(address,string,string,bool) (src/test/utils/Console.sol#1364-1366) is never used and should be removed
console.log(address,string,string,string) (src/test/utils/Console.sol#1360-1362) is never used and should be removed
console.log(address,string,string,uint256) (src/test/utils/Console.sol#1356-1358) is never used and should be removed
console.log(address,string,uint256) (src/test/utils/Console.sol#460-462) is never used and should be removed
console.log(address,string,uint256,address) (src/test/utils/Console.sol#1352-1354) is never used and should be removed
console.log(address,string,uint256,bool) (src/test/utils/Console.sol#1348-1350) is never used and should be removed
console.log(address,string,uint256,string) (src/test/utils/Console.sol#1344-1346) is never used and should be removed
console.log(address,string,uint256,uint256) (src/test/utils/Console.sol#1340-1342) is never used and should be removed
console.log(address,uint256) (src/test/utils/Console.sol#236-238) is never used and should be removed
console.log(address,uint256,address) (src/test/utils/Console.sol#456-458) is never used and should be removed
console.log(address,uint256,address,address) (src/test/utils/Console.sol#1336-1338) is never used and should be removed
console.log(address,uint256,address,bool) (src/test/utils/Console.sol#1332-1334) is never used and should be removed
console.log(address,uint256,address,string) (src/test/utils/Console.sol#1328-1330) is never used and should be removed
console.log(address,uint256,address,uint256) (src/test/utils/Console.sol#1324-1326) is never used and should be removed
console.log(address,uint256,bool) (src/test/utils/Console.sol#452-454) is never used and should be removed
console.log(address,uint256,bool,address) (src/test/utils/Console.sol#1320-1322) is never used and should be removed
console.log(address,uint256,bool,bool) (src/test/utils/Console.sol#1316-1318) is never used and should be removed
console.log(address,uint256,bool,string) (src/test/utils/Console.sol#1312-1314) is never used and should be removed
console.log(address,uint256,bool,uint256) (src/test/utils/Console.sol#1308-1310) is never used and should be removed
console.log(address,uint256,string) (src/test/utils/Console.sol#448-450) is never used and should be removed
console.log(address,uint256,string,address) (src/test/utils/Console.sol#1304-1306) is never used and should be removed
console.log(address,uint256,string,bool) (src/test/utils/Console.sol#1300-1302) is never used and should be removed
console.log(address,uint256,string,string) (src/test/utils/Console.sol#1296-1298) is never used and should be removed
console.log(address,uint256,string,uint256) (src/test/utils/Console.sol#1292-1294) is never used and should be removed
console.log(address,uint256,uint256) (src/test/utils/Console.sol#444-446) is never used and should be removed
console.log(address,uint256,uint256,address) (src/test/utils/Console.sol#1288-1290) is never used and should be removed
console.log(address,uint256,uint256,bool) (src/test/utils/Console.sol#1284-1286) is never used and should be removed
console.log(address,uint256,uint256,string) (src/test/utils/Console.sol#1280-1282) is never used and should be removed
console.log(address,uint256,uint256,uint256) (src/test/utils/Console.sol#1276-1278) is never used and should be removed
console.log(bool) (src/test/utils/Console.sol#180-182) is never used and should be removed
console.log(bool,address) (src/test/utils/Console.sol#232-234) is never used and should be removed
console.log(bool,address,address) (src/test/utils/Console.sol#440-442) is never used and should be removed
console.log(bool,address,address,address) (src/test/utils/Console.sol#1272-1274) is never used and should be removed
console.log(bool,address,address,bool) (src/test/utils/Console.sol#1268-1270) is never used and should be removed
console.log(bool,address,address,string) (src/test/utils/Console.sol#1264-1266) is never used and should be removed
console.log(bool,address,address,uint256) (src/test/utils/Console.sol#1260-1262) is never used and should be removed
console.log(bool,address,bool) (src/test/utils/Console.sol#436-438) is never used and should be removed
console.log(bool,address,bool,address) (src/test/utils/Console.sol#1256-1258) is never used and should be removed
console.log(bool,address,bool,bool) (src/test/utils/Console.sol#1252-1254) is never used and should be removed
console.log(bool,address,bool,string) (src/test/utils/Console.sol#1248-1250) is never used and should be removed
console.log(bool,address,bool,uint256) (src/test/utils/Console.sol#1244-1246) is never used and should be removed
console.log(bool,address,string) (src/test/utils/Console.sol#432-434) is never used and should be removed
console.log(bool,address,string,address) (src/test/utils/Console.sol#1240-1242) is never used and should be removed
console.log(bool,address,string,bool) (src/test/utils/Console.sol#1236-1238) is never used and should be removed
console.log(bool,address,string,string) (src/test/utils/Console.sol#1232-1234) is never used and should be removed
console.log(bool,address,string,uint256) (src/test/utils/Console.sol#1228-1230) is never used and should be removed
console.log(bool,address,uint256) (src/test/utils/Console.sol#428-430) is never used and should be removed
console.log(bool,address,uint256,address) (src/test/utils/Console.sol#1224-1226) is never used and should be removed
console.log(bool,address,uint256,bool) (src/test/utils/Console.sol#1220-1222) is never used and should be removed
console.log(bool,address,uint256,string) (src/test/utils/Console.sol#1216-1218) is never used and should be removed
console.log(bool,address,uint256,uint256) (src/test/utils/Console.sol#1212-1214) is never used and should be removed
console.log(bool,bool) (src/test/utils/Console.sol#228-230) is never used and should be removed
console.log(bool,bool,address) (src/test/utils/Console.sol#424-426) is never used and should be removed
console.log(bool,bool,address,address) (src/test/utils/Console.sol#1208-1210) is never used and should be removed
console.log(bool,bool,address,bool) (src/test/utils/Console.sol#1204-1206) is never used and should be removed
console.log(bool,bool,address,string) (src/test/utils/Console.sol#1200-1202) is never used and should be removed
console.log(bool,bool,address,uint256) (src/test/utils/Console.sol#1196-1198) is never used and should be removed
console.log(bool,bool,bool) (src/test/utils/Console.sol#420-422) is never used and should be removed
console.log(bool,bool,bool,address) (src/test/utils/Console.sol#1192-1194) is never used and should be removed
console.log(bool,bool,bool,bool) (src/test/utils/Console.sol#1188-1190) is never used and should be removed
console.log(bool,bool,bool,string) (src/test/utils/Console.sol#1184-1186) is never used and should be removed
console.log(bool,bool,bool,uint256) (src/test/utils/Console.sol#1180-1182) is never used and should be removed
console.log(bool,bool,string) (src/test/utils/Console.sol#416-418) is never used and should be removed
console.log(bool,bool,string,address) (src/test/utils/Console.sol#1176-1178) is never used and should be removed
console.log(bool,bool,string,bool) (src/test/utils/Console.sol#1172-1174) is never used and should be removed
console.log(bool,bool,string,string) (src/test/utils/Console.sol#1168-1170) is never used and should be removed
console.log(bool,bool,string,uint256) (src/test/utils/Console.sol#1164-1166) is never used and should be removed
console.log(bool,bool,uint256) (src/test/utils/Console.sol#412-414) is never used and should be removed
console.log(bool,bool,uint256,address) (src/test/utils/Console.sol#1160-1162) is never used and should be removed
console.log(bool,bool,uint256,bool) (src/test/utils/Console.sol#1156-1158) is never used and should be removed
console.log(bool,bool,uint256,string) (src/test/utils/Console.sol#1152-1154) is never used and should be removed
console.log(bool,bool,uint256,uint256) (src/test/utils/Console.sol#1148-1150) is never used and should be removed
console.log(bool,string) (src/test/utils/Console.sol#224-226) is never used and should be removed
console.log(bool,string,address) (src/test/utils/Console.sol#408-410) is never used and should be removed
console.log(bool,string,address,address) (src/test/utils/Console.sol#1144-1146) is never used and should be removed
console.log(bool,string,address,bool) (src/test/utils/Console.sol#1140-1142) is never used and should be removed
console.log(bool,string,address,string) (src/test/utils/Console.sol#1136-1138) is never used and should be removed
console.log(bool,string,address,uint256) (src/test/utils/Console.sol#1132-1134) is never used and should be removed
console.log(bool,string,bool) (src/test/utils/Console.sol#404-406) is never used and should be removed
console.log(bool,string,bool,address) (src/test/utils/Console.sol#1128-1130) is never used and should be removed
console.log(bool,string,bool,bool) (src/test/utils/Console.sol#1124-1126) is never used and should be removed
console.log(bool,string,bool,string) (src/test/utils/Console.sol#1120-1122) is never used and should be removed
console.log(bool,string,bool,uint256) (src/test/utils/Console.sol#1116-1118) is never used and should be removed
console.log(bool,string,string) (src/test/utils/Console.sol#400-402) is never used and should be removed
console.log(bool,string,string,address) (src/test/utils/Console.sol#1112-1114) is never used and should be removed
console.log(bool,string,string,bool) (src/test/utils/Console.sol#1108-1110) is never used and should be removed
console.log(bool,string,string,string) (src/test/utils/Console.sol#1104-1106) is never used and should be removed
console.log(bool,string,string,uint256) (src/test/utils/Console.sol#1100-1102) is never used and should be removed
console.log(bool,string,uint256) (src/test/utils/Console.sol#396-398) is never used and should be removed
console.log(bool,string,uint256,address) (src/test/utils/Console.sol#1096-1098) is never used and should be removed
console.log(bool,string,uint256,bool) (src/test/utils/Console.sol#1092-1094) is never used and should be removed
console.log(bool,string,uint256,string) (src/test/utils/Console.sol#1088-1090) is never used and should be removed
console.log(bool,string,uint256,uint256) (src/test/utils/Console.sol#1084-1086) is never used and should be removed
console.log(bool,uint256) (src/test/utils/Console.sol#220-222) is never used and should be removed
console.log(bool,uint256,address) (src/test/utils/Console.sol#392-394) is never used and should be removed
console.log(bool,uint256,address,address) (src/test/utils/Console.sol#1080-1082) is never used and should be removed
console.log(bool,uint256,address,bool) (src/test/utils/Console.sol#1076-1078) is never used and should be removed
console.log(bool,uint256,address,string) (src/test/utils/Console.sol#1072-1074) is never used and should be removed
console.log(bool,uint256,address,uint256) (src/test/utils/Console.sol#1068-1070) is never used and should be removed
console.log(bool,uint256,bool) (src/test/utils/Console.sol#388-390) is never used and should be removed
console.log(bool,uint256,bool,address) (src/test/utils/Console.sol#1064-1066) is never used and should be removed
console.log(bool,uint256,bool,bool) (src/test/utils/Console.sol#1060-1062) is never used and should be removed
console.log(bool,uint256,bool,string) (src/test/utils/Console.sol#1056-1058) is never used and should be removed
console.log(bool,uint256,bool,uint256) (src/test/utils/Console.sol#1052-1054) is never used and should be removed
console.log(bool,uint256,string) (src/test/utils/Console.sol#384-386) is never used and should be removed
console.log(bool,uint256,string,address) (src/test/utils/Console.sol#1048-1050) is never used and should be removed
console.log(bool,uint256,string,bool) (src/test/utils/Console.sol#1044-1046) is never used and should be removed
console.log(bool,uint256,string,string) (src/test/utils/Console.sol#1040-1042) is never used and should be removed
console.log(bool,uint256,string,uint256) (src/test/utils/Console.sol#1036-1038) is never used and should be removed
console.log(bool,uint256,uint256) (src/test/utils/Console.sol#380-382) is never used and should be removed
console.log(bool,uint256,uint256,address) (src/test/utils/Console.sol#1032-1034) is never used and should be removed
console.log(bool,uint256,uint256,bool) (src/test/utils/Console.sol#1028-1030) is never used and should be removed
console.log(bool,uint256,uint256,string) (src/test/utils/Console.sol#1024-1026) is never used and should be removed
console.log(bool,uint256,uint256,uint256) (src/test/utils/Console.sol#1020-1022) is never used and should be removed
console.log(string,address) (src/test/utils/Console.sol#216-218) is never used and should be removed
console.log(string,address,address) (src/test/utils/Console.sol#376-378) is never used and should be removed
console.log(string,address,address,address) (src/test/utils/Console.sol#1016-1018) is never used and should be removed
console.log(string,address,address,bool) (src/test/utils/Console.sol#1012-1014) is never used and should be removed
console.log(string,address,address,string) (src/test/utils/Console.sol#1008-1010) is never used and should be removed
console.log(string,address,address,uint256) (src/test/utils/Console.sol#1004-1006) is never used and should be removed
console.log(string,address,bool) (src/test/utils/Console.sol#372-374) is never used and should be removed
console.log(string,address,bool,address) (src/test/utils/Console.sol#1000-1002) is never used and should be removed
console.log(string,address,bool,bool) (src/test/utils/Console.sol#996-998) is never used and should be removed
console.log(string,address,bool,string) (src/test/utils/Console.sol#992-994) is never used and should be removed
console.log(string,address,bool,uint256) (src/test/utils/Console.sol#988-990) is never used and should be removed
console.log(string,address,string) (src/test/utils/Console.sol#368-370) is never used and should be removed
console.log(string,address,string,address) (src/test/utils/Console.sol#984-986) is never used and should be removed
console.log(string,address,string,bool) (src/test/utils/Console.sol#980-982) is never used and should be removed
console.log(string,address,string,string) (src/test/utils/Console.sol#976-978) is never used and should be removed
console.log(string,address,string,uint256) (src/test/utils/Console.sol#972-974) is never used and should be removed
console.log(string,address,uint256) (src/test/utils/Console.sol#364-366) is never used and should be removed
console.log(string,address,uint256,address) (src/test/utils/Console.sol#968-970) is never used and should be removed
console.log(string,address,uint256,bool) (src/test/utils/Console.sol#964-966) is never used and should be removed
console.log(string,address,uint256,string) (src/test/utils/Console.sol#960-962) is never used and should be removed
console.log(string,address,uint256,uint256) (src/test/utils/Console.sol#956-958) is never used and should be removed
console.log(string,bool) (src/test/utils/Console.sol#212-214) is never used and should be removed
console.log(string,bool,address) (src/test/utils/Console.sol#360-362) is never used and should be removed
console.log(string,bool,address,address) (src/test/utils/Console.sol#952-954) is never used and should be removed
console.log(string,bool,address,bool) (src/test/utils/Console.sol#948-950) is never used and should be removed
console.log(string,bool,address,string) (src/test/utils/Console.sol#944-946) is never used and should be removed
console.log(string,bool,address,uint256) (src/test/utils/Console.sol#940-942) is never used and should be removed
console.log(string,bool,bool) (src/test/utils/Console.sol#356-358) is never used and should be removed
console.log(string,bool,bool,address) (src/test/utils/Console.sol#936-938) is never used and should be removed
console.log(string,bool,bool,bool) (src/test/utils/Console.sol#932-934) is never used and should be removed
console.log(string,bool,bool,string) (src/test/utils/Console.sol#928-930) is never used and should be removed
console.log(string,bool,bool,uint256) (src/test/utils/Console.sol#924-926) is never used and should be removed
console.log(string,bool,string) (src/test/utils/Console.sol#352-354) is never used and should be removed
console.log(string,bool,string,address) (src/test/utils/Console.sol#920-922) is never used and should be removed
console.log(string,bool,string,bool) (src/test/utils/Console.sol#916-918) is never used and should be removed
console.log(string,bool,string,string) (src/test/utils/Console.sol#912-914) is never used and should be removed
console.log(string,bool,string,uint256) (src/test/utils/Console.sol#908-910) is never used and should be removed
console.log(string,bool,uint256) (src/test/utils/Console.sol#348-350) is never used and should be removed
console.log(string,bool,uint256,address) (src/test/utils/Console.sol#904-906) is never used and should be removed
console.log(string,bool,uint256,bool) (src/test/utils/Console.sol#900-902) is never used and should be removed
console.log(string,bool,uint256,string) (src/test/utils/Console.sol#896-898) is never used and should be removed
console.log(string,bool,uint256,uint256) (src/test/utils/Console.sol#892-894) is never used and should be removed
console.log(string,string) (src/test/utils/Console.sol#208-210) is never used and should be removed
console.log(string,string,address) (src/test/utils/Console.sol#344-346) is never used and should be removed
console.log(string,string,address,address) (src/test/utils/Console.sol#888-890) is never used and should be removed
console.log(string,string,address,bool) (src/test/utils/Console.sol#884-886) is never used and should be removed
console.log(string,string,address,string) (src/test/utils/Console.sol#880-882) is never used and should be removed
console.log(string,string,address,uint256) (src/test/utils/Console.sol#876-878) is never used and should be removed
console.log(string,string,bool) (src/test/utils/Console.sol#340-342) is never used and should be removed
console.log(string,string,bool,address) (src/test/utils/Console.sol#872-874) is never used and should be removed
console.log(string,string,bool,bool) (src/test/utils/Console.sol#868-870) is never used and should be removed
console.log(string,string,bool,string) (src/test/utils/Console.sol#864-866) is never used and should be removed
console.log(string,string,bool,uint256) (src/test/utils/Console.sol#860-862) is never used and should be removed
console.log(string,string,string) (src/test/utils/Console.sol#336-338) is never used and should be removed
console.log(string,string,string,address) (src/test/utils/Console.sol#856-858) is never used and should be removed
console.log(string,string,string,bool) (src/test/utils/Console.sol#852-854) is never used and should be removed
console.log(string,string,string,string) (src/test/utils/Console.sol#848-850) is never used and should be removed
console.log(string,string,string,uint256) (src/test/utils/Console.sol#844-846) is never used and should be removed
console.log(string,string,uint256) (src/test/utils/Console.sol#332-334) is never used and should be removed
console.log(string,string,uint256,address) (src/test/utils/Console.sol#840-842) is never used and should be removed
console.log(string,string,uint256,bool) (src/test/utils/Console.sol#836-838) is never used and should be removed
console.log(string,string,uint256,string) (src/test/utils/Console.sol#832-834) is never used and should be removed
console.log(string,string,uint256,uint256) (src/test/utils/Console.sol#828-830) is never used and should be removed
console.log(string,uint256) (src/test/utils/Console.sol#204-206) is never used and should be removed
console.log(string,uint256,address) (src/test/utils/Console.sol#328-330) is never used and should be removed
console.log(string,uint256,address,address) (src/test/utils/Console.sol#824-826) is never used and should be removed
console.log(string,uint256,address,bool) (src/test/utils/Console.sol#820-822) is never used and should be removed
console.log(string,uint256,address,string) (src/test/utils/Console.sol#816-818) is never used and should be removed
console.log(string,uint256,address,uint256) (src/test/utils/Console.sol#812-814) is never used and should be removed
console.log(string,uint256,bool) (src/test/utils/Console.sol#324-326) is never used and should be removed
console.log(string,uint256,bool,address) (src/test/utils/Console.sol#808-810) is never used and should be removed
console.log(string,uint256,bool,bool) (src/test/utils/Console.sol#804-806) is never used and should be removed
console.log(string,uint256,bool,string) (src/test/utils/Console.sol#800-802) is never used and should be removed
console.log(string,uint256,bool,uint256) (src/test/utils/Console.sol#796-798) is never used and should be removed
console.log(string,uint256,string) (src/test/utils/Console.sol#320-322) is never used and should be removed
console.log(string,uint256,string,address) (src/test/utils/Console.sol#792-794) is never used and should be removed
console.log(string,uint256,string,bool) (src/test/utils/Console.sol#788-790) is never used and should be removed
console.log(string,uint256,string,string) (src/test/utils/Console.sol#784-786) is never used and should be removed
console.log(string,uint256,string,uint256) (src/test/utils/Console.sol#780-782) is never used and should be removed
console.log(string,uint256,uint256) (src/test/utils/Console.sol#316-318) is never used and should be removed
console.log(string,uint256,uint256,address) (src/test/utils/Console.sol#776-778) is never used and should be removed
console.log(string,uint256,uint256,bool) (src/test/utils/Console.sol#772-774) is never used and should be removed
console.log(string,uint256,uint256,string) (src/test/utils/Console.sol#768-770) is never used and should be removed
console.log(string,uint256,uint256,uint256) (src/test/utils/Console.sol#764-766) is never used and should be removed
console.log(uint256,address) (src/test/utils/Console.sol#200-202) is never used and should be removed
console.log(uint256,address,address) (src/test/utils/Console.sol#312-314) is never used and should be removed
console.log(uint256,address,address,address) (src/test/utils/Console.sol#760-762) is never used and should be removed
console.log(uint256,address,address,bool) (src/test/utils/Console.sol#756-758) is never used and should be removed
console.log(uint256,address,address,string) (src/test/utils/Console.sol#752-754) is never used and should be removed
console.log(uint256,address,address,uint256) (src/test/utils/Console.sol#748-750) is never used and should be removed
console.log(uint256,address,bool) (src/test/utils/Console.sol#308-310) is never used and should be removed
console.log(uint256,address,bool,address) (src/test/utils/Console.sol#744-746) is never used and should be removed
console.log(uint256,address,bool,bool) (src/test/utils/Console.sol#740-742) is never used and should be removed
console.log(uint256,address,bool,string) (src/test/utils/Console.sol#736-738) is never used and should be removed
console.log(uint256,address,bool,uint256) (src/test/utils/Console.sol#732-734) is never used and should be removed
console.log(uint256,address,string) (src/test/utils/Console.sol#304-306) is never used and should be removed
console.log(uint256,address,string,address) (src/test/utils/Console.sol#728-730) is never used and should be removed
console.log(uint256,address,string,bool) (src/test/utils/Console.sol#724-726) is never used and should be removed
console.log(uint256,address,string,string) (src/test/utils/Console.sol#720-722) is never used and should be removed
console.log(uint256,address,string,uint256) (src/test/utils/Console.sol#716-718) is never used and should be removed
console.log(uint256,address,uint256) (src/test/utils/Console.sol#300-302) is never used and should be removed
console.log(uint256,address,uint256,address) (src/test/utils/Console.sol#712-714) is never used and should be removed
console.log(uint256,address,uint256,bool) (src/test/utils/Console.sol#708-710) is never used and should be removed
console.log(uint256,address,uint256,string) (src/test/utils/Console.sol#704-706) is never used and should be removed
console.log(uint256,address,uint256,uint256) (src/test/utils/Console.sol#700-702) is never used and should be removed
console.log(uint256,bool) (src/test/utils/Console.sol#196-198) is never used and should be removed
console.log(uint256,bool,address) (src/test/utils/Console.sol#296-298) is never used and should be removed
console.log(uint256,bool,address,address) (src/test/utils/Console.sol#696-698) is never used and should be removed
console.log(uint256,bool,address,bool) (src/test/utils/Console.sol#692-694) is never used and should be removed
console.log(uint256,bool,address,string) (src/test/utils/Console.sol#688-690) is never used and should be removed
console.log(uint256,bool,address,uint256) (src/test/utils/Console.sol#684-686) is never used and should be removed
console.log(uint256,bool,bool) (src/test/utils/Console.sol#292-294) is never used and should be removed
console.log(uint256,bool,bool,address) (src/test/utils/Console.sol#680-682) is never used and should be removed
console.log(uint256,bool,bool,bool) (src/test/utils/Console.sol#676-678) is never used and should be removed
console.log(uint256,bool,bool,string) (src/test/utils/Console.sol#672-674) is never used and should be removed
console.log(uint256,bool,bool,uint256) (src/test/utils/Console.sol#668-670) is never used and should be removed
console.log(uint256,bool,string) (src/test/utils/Console.sol#288-290) is never used and should be removed
console.log(uint256,bool,string,address) (src/test/utils/Console.sol#664-666) is never used and should be removed
console.log(uint256,bool,string,bool) (src/test/utils/Console.sol#660-662) is never used and should be removed
console.log(uint256,bool,string,string) (src/test/utils/Console.sol#656-658) is never used and should be removed
console.log(uint256,bool,string,uint256) (src/test/utils/Console.sol#652-654) is never used and should be removed
console.log(uint256,bool,uint256) (src/test/utils/Console.sol#284-286) is never used and should be removed
console.log(uint256,bool,uint256,address) (src/test/utils/Console.sol#648-650) is never used and should be removed
console.log(uint256,bool,uint256,bool) (src/test/utils/Console.sol#644-646) is never used and should be removed
console.log(uint256,bool,uint256,string) (src/test/utils/Console.sol#640-642) is never used and should be removed
console.log(uint256,bool,uint256,uint256) (src/test/utils/Console.sol#636-638) is never used and should be removed
console.log(uint256,string) (src/test/utils/Console.sol#192-194) is never used and should be removed
console.log(uint256,string,address) (src/test/utils/Console.sol#280-282) is never used and should be removed
console.log(uint256,string,address,address) (src/test/utils/Console.sol#632-634) is never used and should be removed
console.log(uint256,string,address,bool) (src/test/utils/Console.sol#628-630) is never used and should be removed
console.log(uint256,string,address,string) (src/test/utils/Console.sol#624-626) is never used and should be removed
console.log(uint256,string,address,uint256) (src/test/utils/Console.sol#620-622) is never used and should be removed
console.log(uint256,string,bool) (src/test/utils/Console.sol#276-278) is never used and should be removed
console.log(uint256,string,bool,address) (src/test/utils/Console.sol#616-618) is never used and should be removed
console.log(uint256,string,bool,bool) (src/test/utils/Console.sol#612-614) is never used and should be removed
console.log(uint256,string,bool,string) (src/test/utils/Console.sol#608-610) is never used and should be removed
console.log(uint256,string,bool,uint256) (src/test/utils/Console.sol#604-606) is never used and should be removed
console.log(uint256,string,string) (src/test/utils/Console.sol#272-274) is never used and should be removed
console.log(uint256,string,string,address) (src/test/utils/Console.sol#600-602) is never used and should be removed
console.log(uint256,string,string,bool) (src/test/utils/Console.sol#596-598) is never used and should be removed
console.log(uint256,string,string,string) (src/test/utils/Console.sol#592-594) is never used and should be removed
console.log(uint256,string,string,uint256) (src/test/utils/Console.sol#588-590) is never used and should be removed
console.log(uint256,string,uint256) (src/test/utils/Console.sol#268-270) is never used and should be removed
console.log(uint256,string,uint256,address) (src/test/utils/Console.sol#584-586) is never used and should be removed
console.log(uint256,string,uint256,bool) (src/test/utils/Console.sol#580-582) is never used and should be removed
console.log(uint256,string,uint256,string) (src/test/utils/Console.sol#576-578) is never used and should be removed
console.log(uint256,string,uint256,uint256) (src/test/utils/Console.sol#572-574) is never used and should be removed
console.log(uint256,uint256,address) (src/test/utils/Console.sol#264-266) is never used and should be removed
console.log(uint256,uint256,address,address) (src/test/utils/Console.sol#568-570) is never used and should be removed
console.log(uint256,uint256,address,bool) (src/test/utils/Console.sol#564-566) is never used and should be removed
console.log(uint256,uint256,address,string) (src/test/utils/Console.sol#560-562) is never used and should be removed
console.log(uint256,uint256,address,uint256) (src/test/utils/Console.sol#556-558) is never used and should be removed
console.log(uint256,uint256,bool) (src/test/utils/Console.sol#260-262) is never used and should be removed
console.log(uint256,uint256,bool,address) (src/test/utils/Console.sol#552-554) is never used and should be removed
console.log(uint256,uint256,bool,bool) (src/test/utils/Console.sol#548-550) is never used and should be removed
console.log(uint256,uint256,bool,string) (src/test/utils/Console.sol#544-546) is never used and should be removed
console.log(uint256,uint256,bool,uint256) (src/test/utils/Console.sol#540-542) is never used and should be removed
console.log(uint256,uint256,string) (src/test/utils/Console.sol#256-258) is never used and should be removed
console.log(uint256,uint256,string,address) (src/test/utils/Console.sol#536-538) is never used and should be removed
console.log(uint256,uint256,string,bool) (src/test/utils/Console.sol#532-534) is never used and should be removed
console.log(uint256,uint256,string,string) (src/test/utils/Console.sol#528-530) is never used and should be removed
console.log(uint256,uint256,string,uint256) (src/test/utils/Console.sol#524-526) is never used and should be removed
console.log(uint256,uint256,uint256) (src/test/utils/Console.sol#252-254) is never used and should be removed
console.log(uint256,uint256,uint256,address) (src/test/utils/Console.sol#520-522) is never used and should be removed
console.log(uint256,uint256,uint256,bool) (src/test/utils/Console.sol#516-518) is never used and should be removed
console.log(uint256,uint256,uint256,string) (src/test/utils/Console.sol#512-514) is never used and should be removed
console.logAddress(address) (src/test/utils/Console.sol#36-38) is never used and should be removed
console.logBool(bool) (src/test/utils/Console.sol#32-34) is never used and should be removed
console.logBytes(bytes) (src/test/utils/Console.sol#40-42) is never used and should be removed
console.logBytes1(bytes1) (src/test/utils/Console.sol#44-46) is never used and should be removed
console.logBytes10(bytes10) (src/test/utils/Console.sol#80-82) is never used and should be removed
console.logBytes11(bytes11) (src/test/utils/Console.sol#84-86) is never used and should be removed
console.logBytes12(bytes12) (src/test/utils/Console.sol#88-90) is never used and should be removed
console.logBytes13(bytes13) (src/test/utils/Console.sol#92-94) is never used and should be removed
console.logBytes14(bytes14) (src/test/utils/Console.sol#96-98) is never used and should be removed
console.logBytes15(bytes15) (src/test/utils/Console.sol#100-102) is never used and should be removed
console.logBytes16(bytes16) (src/test/utils/Console.sol#104-106) is never used and should be removed
console.logBytes17(bytes17) (src/test/utils/Console.sol#108-110) is never used and should be removed
console.logBytes18(bytes18) (src/test/utils/Console.sol#112-114) is never used and should be removed
console.logBytes19(bytes19) (src/test/utils/Console.sol#116-118) is never used and should be removed
console.logBytes2(bytes2) (src/test/utils/Console.sol#48-50) is never used and should be removed
console.logBytes20(bytes20) (src/test/utils/Console.sol#120-122) is never used and should be removed
console.logBytes21(bytes21) (src/test/utils/Console.sol#124-126) is never used and should be removed
console.logBytes22(bytes22) (src/test/utils/Console.sol#128-130) is never used and should be removed
console.logBytes23(bytes23) (src/test/utils/Console.sol#132-134) is never used and should be removed
console.logBytes24(bytes24) (src/test/utils/Console.sol#136-138) is never used and should be removed
console.logBytes25(bytes25) (src/test/utils/Console.sol#140-142) is never used and should be removed
console.logBytes26(bytes26) (src/test/utils/Console.sol#144-146) is never used and should be removed
console.logBytes27(bytes27) (src/test/utils/Console.sol#148-150) is never used and should be removed
console.logBytes28(bytes28) (src/test/utils/Console.sol#152-154) is never used and should be removed
console.logBytes29(bytes29) (src/test/utils/Console.sol#156-158) is never used and should be removed
console.logBytes3(bytes3) (src/test/utils/Console.sol#52-54) is never used and should be removed
console.logBytes30(bytes30) (src/test/utils/Console.sol#160-162) is never used and should be removed
console.logBytes31(bytes31) (src/test/utils/Console.sol#164-166) is never used and should be removed
console.logBytes4(bytes4) (src/test/utils/Console.sol#56-58) is never used and should be removed
console.logBytes5(bytes5) (src/test/utils/Console.sol#60-62) is never used and should be removed
console.logBytes6(bytes6) (src/test/utils/Console.sol#64-66) is never used and should be removed
console.logBytes7(bytes7) (src/test/utils/Console.sol#68-70) is never used and should be removed
console.logBytes8(bytes8) (src/test/utils/Console.sol#72-74) is never used and should be removed
console.logBytes9(bytes9) (src/test/utils/Console.sol#76-78) is never used and should be removed
console.logInt(int256) (src/test/utils/Console.sol#20-22) is never used and should be removed
console.logString(string) (src/test/utils/Console.sol#28-30) is never used and should be removed
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code

LimitOrderRouterTest._hexDems (src/test/LimitOrderRouter.t.sol#82) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_uniswapV2HexDem)
LimitOrderRouterTest._dexFactories (src/test/LimitOrderRouter.t.sol#83) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
SandboxLimitOrderBookTest._hexDems (src/test/SandboxLimitOrderBook.t.sol#78) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_uniswapV2HexDem)
SandboxLimitOrderBookTest._dexFactories (src/test/SandboxLimitOrderBook.t.sol#79) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
LimitOrderBookTest._hexDems (src/test/LimitOrderBook.t.sol#66) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_uniswapV2HexDem)
LimitOrderBookTest._dexFactories (src/test/LimitOrderBook.t.sol#67) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
SwapRouterTest._hexDems (src/test/SwapRouter.t.sol#77) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_sushiHexDem,_uniswapV2HexDem)
SwapRouterTest._dexFactories (src/test/SwapRouter.t.sol#78-82) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_sushiFactoryAddress,_uniV3FactoryAddress)
LimitOrderQuoterTest._hexDems (src/test/LimitOrderQuoter.t.sol#89-93) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,bytes32(0))
LimitOrderQuoterTest._dexFactories (src/test/LimitOrderQuoter.t.sol#94-98) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
LimitOrderExecutorTest._hexDems (src/test/LimitOrderExecutor.t.sol#81) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_uniswapV2HexDem)
LimitOrderExecutorTest._dexFactories (src/test/LimitOrderExecutor.t.sol#82) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
ConveyorTickMathTest._hexDems (src/test/ConveyorTickMath.t.sol#77-81) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_uniswapV2HexDem)
ConveyorTickMathTest._dexFactories (src/test/ConveyorTickMath.t.sol#82-86) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
SandboxLimitOrderRouterTest._hexDems (src/test/SandboxLimitOrderRouter.t.sol#96) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_uniswapV2HexDem)
SandboxLimitOrderRouterTest._dexFactories (src/test/SandboxLimitOrderRouter.t.sol#97) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_uniV3FactoryAddress)
ConveyorFeeMathTest._hexDems (src/test/ConveyorFeeMath.t.sol#59) is set pre-construction with a non-constant function or state variable:
	- (_uniswapV2HexDem,_sushiHexDem,_uniswapV2HexDem)
ConveyorFeeMathTest._dexFactories (src/test/ConveyorFeeMath.t.sol#60-64) is set pre-construction with a non-constant function or state variable:
	- (_uniV2FactoryAddress,_sushiFactoryAddress,_uniV3FactoryAddress)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state

Pragma version^0.8.0 (lib/libraries/token/SafeERC20.sol#4) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v2/IUniswapV2Factory.sol#2) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#2) allows old versions
Pragma version>=0.5.0 (lib/libraries/Uniswap/UnsafeMath.sol#2) allows old versions
Pragma version^0.8.0 (lib/libraries/Uniswap/SqrtPriceMath.sol#2) allows old versions
Pragma version^0.8.0 (lib/libraries/Uniswap/Tick.sol#2) allows old versions
Pragma version^0.8.0 (lib/libraries/Uniswap/SwapMath.sol#2) allows old versions
Pragma version^0.8.0 (lib/libraries/Uniswap/FullMath.sol#2) allows old versions
Pragma version>=0.4.22 (src/test/utils/Console.sol#2) is known to contain severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#2) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3Factory.sol#2) allows old versions
Pragma version^0.8.1 (lib/utils/Address.sol#4) allows old versions
Pragma version^0.8.0 (lib/interfaces/token/draft-IERC20Permit.sol#4) allows old versions
Pragma version>=0.4.23 (src/test/utils/test.sol#16) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolImmutables.sol#2) allows old versions
Pragma version>=0.4.0 (lib/libraries/Uniswap/FixedPoint96.sol#2) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3Pool.sol#2) allows old versions
Pragma version>=0.5.0 (lib/libraries/Uniswap/SafeCast.sol#2) allows old versions
Pragma version>=0.5.0 (lib/libraries/Uniswap/LiquidityMath.sol#2) allows old versions
Pragma version^0.8.0 (lib/libraries/Uniswap/TickBitmap.sol#2) allows old versions
Pragma version>=0.7.0 (lib/libraries/Uniswap/LowGasSafeMath.sol#2) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolDerivedState.sol#2) allows old versions
Pragma version>=0.6.2 (lib/interfaces/uniswap-v2/IUniswapV2Router01.sol#2) allows old versions
Pragma version^0.8.0 (lib/libraries/Uniswap/TickMath.sol#2) allows old versions
Pragma version>=0.6.2 (lib/interfaces/uniswap-v2/IUniswapV2Router02.sol#2) allows old versions
Pragma version>=0.5.0 (lib/libraries/Uniswap/BitMath.sol#2) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v2/IUniswapV2Pair.sol#2) allows old versions
Pragma version>=0.5.0 (lib/interfaces/uniswap-v3/IUniswapV3PoolActions.sol#2) allows old versions
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity

Low level call in LimitOrderRouterTest.testValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#242-275):
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#257-259)
Low level call in LimitOrderRouterTest.testFailValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#278-306):
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderRouter.t.sol#291-293)
Low level call in LimitOrderRouterTest.depositGasCreditsForMockOrders(uint256) (src/test/LimitOrderRouter.t.sol#551-557):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderRouter.t.sol#552-554)
Low level call in SandboxLimitOrderRouter.sandboxRouterCallback(SandboxLimitOrderRouter.SandboxMulticall) (src/SandboxLimitOrderRouter.sol#65-83):
	- (success) = sandBoxCall.target.call(sandBoxCall.callData) (src/SandboxLimitOrderRouter.sol#73)
Low level call in SandboxLimitOrderBookTest.testValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#638-666):
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#646-648)
Low level call in SandboxLimitOrderBookTest.testFailValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#669-696):
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderBook.t.sol#679-681)
Low level call in SandboxLimitOrderBookTest.depositGasCreditsForMockOrders(uint256) (src/test/SandboxLimitOrderBook.t.sol#744-751):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderBook.t.sol#746-748)
Low level call in LimitOrderBookTest.depositGasCreditsForMockOrders(uint256) (src/test/LimitOrderBook.t.sol#594-601):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderBook.t.sol#596-598)
Low level call in SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664):
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SwapRouter.t.sol#640-642)
Low level call in LimitOrderExecutorTest.testExecuteWethToTokenSingle() (src/test/LimitOrderExecutor.t.sol#332-382):
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#337-339)
Low level call in LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559):
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#512-514)
Low level call in LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849):
	- address(WETH).call{value: amountIn}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#743-745)
Low level call in LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903):
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#857-859)
Low level call in LimitOrderExecutorTest.depositGasCreditsForMockOrders(uint256) (src/test/LimitOrderExecutor.t.sol#1539-1545):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/LimitOrderExecutor.t.sol#1540-1542)
Low level call in Address.sendValue(address,uint256) (lib/utils/Address.sol#60-65):
	- (success) = recipient.call{value: amount}() (lib/utils/Address.sol#63)
Low level call in Address.functionCallWithValue(address,bytes,uint256,string) (lib/utils/Address.sol#128-137):
	- (success,returndata) = target.call{value: value}(data) (lib/utils/Address.sol#135)
Low level call in Address.functionStaticCall(address,bytes,string) (lib/utils/Address.sol#155-162):
	- (success,returndata) = target.staticcall(data) (lib/utils/Address.sol#160)
Low level call in Address.functionDelegateCall(address,bytes,string) (lib/utils/Address.sol#180-187):
	- (success,returndata) = target.delegatecall(data) (lib/utils/Address.sol#185)
Low level call in ConveyorSwapAggregatorTest.testSwapUniv3SingleLP() (src/test/ConveyorSwapAggregator.t.sol#133-188):
	- (depositSuccess) = address(tokenOut).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/ConveyorSwapAggregator.t.sol#142-144)
Low level call in SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101):
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1034-1036)
	- (reverted) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(initializePreSandboxExecutionState(bytes32[][],uint128[]),orderIdBundles,fillAmounts)) (src/test/SandboxLimitOrderRouter.t.sol#1073-1080)
Low level call in SandboxLimitOrderRouterTest.validateSandboxExecutionAndFillOrders(bytes32[][],uint256[],uint256[],uint256,SandboxLimitOrderBook.SandboxLimitOrder[],uint128[],uint256) (src/test/SandboxLimitOrderRouter.t.sol#1178-1272):
	- (status) = address(sandboxLimitOrderBookWrapper).call(abi.encodeWithSignature(validateSandboxExecutionAndFillOrders(bytes32[][],uint128[],LimitOrderRouter.PreSandboxExecutionState),orderIdBundles,fillAmounts,preSandboxExecutionState)) (src/test/SandboxLimitOrderRouter.t.sol#1220-1227)
Low level call in SandboxLimitOrderRouterTest._requireConveyorFeeIsPaid(uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1277-1317):
	- (depositSuccess) = address(WETH).call{value: compensationAmount}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1285-1287)
	- (reverted) = address(limitOrderExecutor).call(abi.encodeWithSignature(requireConveyorFeeIsPaid(uint256, uint256),uint256(contractBalancePreExecution),uint256(expectedAccumulatedFees))) (src/test/SandboxLimitOrderRouter.t.sol#1305-1311)
Low level call in SandboxLimitOrderRouterTest.initializeTestBalanceState(uint128) (src/test/SandboxLimitOrderRouter.t.sol#1401-1415):
	- (depositSuccess) = address(WETH).call{value: wethQuantity}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1410-1412)
Low level call in SandboxLimitOrderRouterTest.dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#1442-1451):
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
Low level call in SandboxLimitOrderRouterTest.depositGasCreditsForMockOrders(uint256) (src/test/SandboxLimitOrderRouter.t.sol#1768-1774):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1769-1771)
Low level call in SandboxLimitOrderRouterTest.depositGasCreditsForMockOrdersWrapper(uint256) (src/test/SandboxLimitOrderRouter.t.sol#1776-1782):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1777-1779)
Low level call in SandboxLimitOrderRouterTest.depositGasCreditsForMockOrdersCustomOwner(uint256,address) (src/test/SandboxLimitOrderRouter.t.sol#1785-1795):
	- (depositSuccess) = address(limitOrderExecutor).call{value: _amount}(abi.encodeWithSignature(depositGasCredits())) (src/test/SandboxLimitOrderRouter.t.sol#1790-1792)
Low level call in SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035):
	- (success) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1975-1977)
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1997-1999)
Low level call in ConveyorSwapExecutor.executeMulticall(ConveyorSwapAggregator.Call[]) (src/ConveyorSwapAggregator.sol#62-77):
	- (success) = call.target.call(call.callData) (src/ConveyorSwapAggregator.sol#69)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls

SandboxLimitOrderRouter (src/SandboxLimitOrderRouter.sol#12-112) should inherit from IUniswapV3SwapCallback (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#6-22)
SandboxLimitOrderRouter (src/SandboxLimitOrderRouter.sol#12-112) should inherit from ISandboxLimitOrderRouter (src/interfaces/ISandboxLimitOrderRouter.sol#6-16)
ConveyorSwapAggregatorTest (src/test/ConveyorSwapAggregator.t.sol#26-256) should inherit from IUniswapV3SwapCallback (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#6-22)
ConveyorSwapExecutor (src/ConveyorSwapAggregator.sol#61-106) should inherit from IUniswapV3SwapCallback (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#6-22)
ConveyorSwapExecutor (src/ConveyorSwapAggregator.sol#61-106) should inherit from IConveyorSwapExecutor (src/ConveyorSwapAggregator.sol#7-10)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance

Function LimitOrderRouterTest.testFailValidateOrderSequence_InvalidBatchOrder() (src/test/LimitOrderRouter.t.sol#153-162) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentInputTokenInBatch() (src/test/LimitOrderRouter.t.sol#164-175) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentStoplossStatus() (src/test/LimitOrderRouter.t.sol#177-186) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#188-196) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentFeeIn() (src/test/LimitOrderRouter.t.sol#198-206) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentFeeOut() (src/test/LimitOrderRouter.t.sol#208-216) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentBuySellStatusInBatch() (src/test/LimitOrderRouter.t.sol#218-228) is not in mixedCase
Function LimitOrderRouterTest.testFailValidateOrderSequence_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#230-240) is not in mixedCase
Function LimitOrderRouterTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/LimitOrderRouter.t.sol#363-410) is not in mixedCase
Function LimitOrderRouterTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/LimitOrderRouter.t.sol#414-449) is not in mixedCase
Parameter LimitOrderRouterTest.depositGasCreditsForMockOrders(uint256)._amount (src/test/LimitOrderRouter.t.sol#551) is not in mixedCase
Function LimitOrderRouterTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#783-840) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#842-899) is not in mixedCase
Function LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) is not in mixedCase
Function LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderRouter.t.sol#967-1027) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#1096-1154) is not in mixedCase
Function LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1156-1213) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1215-1272) is not in mixedCase
Function LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1274-1331) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1333-1390) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderRouter.t.sol#1392-1434) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderRouter.t.sol#1436-1478) is not in mixedCase
Function LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1480-1537) is not in mixedCase
Function LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1539-1595) is not in mixedCase
Variable LimitOrderRouterTest.REFRESH_FEE (src/test/LimitOrderRouter.t.sol#46) is not in mixedCase
Variable LimitOrderRouterTest.WETH (src/test/LimitOrderRouter.t.sol#53) is not in mixedCase
Variable LimitOrderRouterTest.LINK (src/test/LimitOrderRouter.t.sol#54) is not in mixedCase
Variable LimitOrderRouterTest.UNI (src/test/LimitOrderRouter.t.sol#55) is not in mixedCase
Variable LimitOrderRouterTest.USDC (src/test/LimitOrderRouter.t.sol#56) is not in mixedCase
Variable LimitOrderRouterTest.DAI (src/test/LimitOrderRouter.t.sol#57) is not in mixedCase
Variable LimitOrderRouterTest.TAXED_TOKEN (src/test/LimitOrderRouter.t.sol#58) is not in mixedCase
Variable LimitOrderRouterTest.TAXED_TOKEN_1 (src/test/LimitOrderRouter.t.sol#59) is not in mixedCase
Variable LimitOrderRouterTest.TAXED_TOKEN_2 (src/test/LimitOrderRouter.t.sol#60) is not in mixedCase
Variable LimitOrderRouterTest.TAXED_TOKEN_3 (src/test/LimitOrderRouter.t.sol#61) is not in mixedCase
Variable LimitOrderRouterTest._sushiSwapRouterAddress (src/test/LimitOrderRouter.t.sol#69-70) is not in mixedCase
Variable LimitOrderRouterTest._uniV2FactoryAddress (src/test/LimitOrderRouter.t.sol#71) is not in mixedCase
Variable LimitOrderRouterTest._uniV3FactoryAddress (src/test/LimitOrderRouter.t.sol#73) is not in mixedCase
Variable LimitOrderRouterTest._uniswapV2HexDem (src/test/LimitOrderRouter.t.sol#78-79) is not in mixedCase
Variable LimitOrderRouterTest._hexDems (src/test/LimitOrderRouter.t.sol#82) is not in mixedCase
Variable LimitOrderRouterTest._dexFactories (src/test/LimitOrderRouter.t.sol#83) is not in mixedCase
Variable LimitOrderRouterTest._isUniV2 (src/test/LimitOrderRouter.t.sol#84) is not in mixedCase
Parameter Swap.swapEthForTokenWithUniV2(uint256,address)._swapToken (src/test/utils/Swap.sol#19) is not in mixedCase
Parameter Swap.swapEthForTokenWithTransferFeesUniV2(uint256,address)._swapToken (src/test/utils/Swap.sol#40) is not in mixedCase
Variable Swap.WETH (src/test/utils/Swap.sol#9) is not in mixedCase
Variable SandboxLimitOrderRouter.LIMIT_ORDER_EXECUTOR (src/SandboxLimitOrderRouter.sol#15) is not in mixedCase
Variable SandboxLimitOrderRouter.SANDBOX_LIMIT_ORDER_BOOK (src/SandboxLimitOrderRouter.sol#16) is not in mixedCase
Function SandboxLimitOrderBookTest.testFailGetSandboxLimitOrderById_OrderDoesNotExist() (src/test/SandboxLimitOrderBook.t.sol#154-156) is not in mixedCase
Function SandboxLimitOrderBookTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/SandboxLimitOrderBook.t.sol#247-284) is not in mixedCase
Function SandboxLimitOrderBookTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/SandboxLimitOrderBook.t.sol#288-314) is not in mixedCase
Function SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientWalletBalance(uint112) (src/test/SandboxLimitOrderBook.t.sol#459-486) is not in mixedCase
Function SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256) (src/test/SandboxLimitOrderBook.t.sol#488-517) is not in mixedCase
Parameter SandboxLimitOrderBookTest.depositGasCreditsForMockOrders(uint256)._amount (src/test/SandboxLimitOrderBook.t.sol#744) is not in mixedCase
Variable SandboxLimitOrderBookTest.WETH (src/test/SandboxLimitOrderBook.t.sol#57) is not in mixedCase
Variable SandboxLimitOrderBookTest.MAX_UINT (src/test/SandboxLimitOrderBook.t.sol#62) is not in mixedCase
Variable SandboxLimitOrderBookTest._sushiSwapRouterAddress (src/test/SandboxLimitOrderBook.t.sol#64-65) is not in mixedCase
Variable SandboxLimitOrderBookTest._uniV2FactoryAddress (src/test/SandboxLimitOrderBook.t.sol#66) is not in mixedCase
Variable SandboxLimitOrderBookTest._uniV3FactoryAddress (src/test/SandboxLimitOrderBook.t.sol#67) is not in mixedCase
Variable SandboxLimitOrderBookTest._uniswapV2HexDem (src/test/SandboxLimitOrderBook.t.sol#71-72) is not in mixedCase
Variable SandboxLimitOrderBookTest._hexDems (src/test/SandboxLimitOrderBook.t.sol#78) is not in mixedCase
Variable SandboxLimitOrderBookTest._dexFactories (src/test/SandboxLimitOrderBook.t.sol#79) is not in mixedCase
Variable SandboxLimitOrderBookTest._isUniV2 (src/test/SandboxLimitOrderBook.t.sol#80) is not in mixedCase
Variable SandboxLimitOrderBookTest.REFRESH_FEE (src/test/SandboxLimitOrderBook.t.sol#82) is not in mixedCase
Function LimitOrderBookTest.testFailGetLimitOrderById_OrderDoesNotExist() (src/test/LimitOrderBook.t.sol#130-132) is not in mixedCase
Function LimitOrderBookTest.testFailPlaceOrder_InsufficientAllowanceForOrderPlacement(uint256,uint256) (src/test/LimitOrderBook.t.sol#220-262) is not in mixedCase
Function LimitOrderBookTest.testFailPlaceOrder_InsufficientWalletBalance() (src/test/LimitOrderBook.t.sol#265-284) is not in mixedCase
Function LimitOrderBookTest.testFailPlaceOrder_IncongruentTokenInOrderGroup(uint256,uint256,uint256,uint256) (src/test/LimitOrderBook.t.sol#287-335) is not in mixedCase
Function LimitOrderBookTest.testFailUpdateOrder_InsufficientAllowanceForOrderUpdate(uint128,uint64,uint128,uint128) (src/test/LimitOrderBook.t.sol#389-415) is not in mixedCase
Function LimitOrderBookTest.testFailUpdateOrder_OrderDoesNotExist(uint256,uint256,bytes32) (src/test/LimitOrderBook.t.sol#418-444) is not in mixedCase
Function LimitOrderBookTest.testFailCancelOrder_OrderDoesNotExist(bytes32) (src/test/LimitOrderBook.t.sol#470-473) is not in mixedCase
Function LimitOrderBookTest.testFailCancelOrders_OrderDoesNotExist(bytes32,bytes32) (src/test/LimitOrderBook.t.sol#515-526) is not in mixedCase
Parameter LimitOrderBookTest.depositGasCreditsForMockOrders(uint256)._amount (src/test/LimitOrderBook.t.sol#594) is not in mixedCase
Variable LimitOrderBookTest.WETH (src/test/LimitOrderBook.t.sol#45) is not in mixedCase
Variable LimitOrderBookTest.MAX_UINT (src/test/LimitOrderBook.t.sol#50) is not in mixedCase
Variable LimitOrderBookTest._sushiSwapRouterAddress (src/test/LimitOrderBook.t.sol#52-53) is not in mixedCase
Variable LimitOrderBookTest._uniV2FactoryAddress (src/test/LimitOrderBook.t.sol#54) is not in mixedCase
Variable LimitOrderBookTest._uniV3FactoryAddress (src/test/LimitOrderBook.t.sol#55) is not in mixedCase
Variable LimitOrderBookTest._uniswapV2HexDem (src/test/LimitOrderBook.t.sol#59-60) is not in mixedCase
Variable LimitOrderBookTest._hexDems (src/test/LimitOrderBook.t.sol#66) is not in mixedCase
Variable LimitOrderBookTest._dexFactories (src/test/LimitOrderBook.t.sol#67) is not in mixedCase
Variable LimitOrderBookTest._isUniV2 (src/test/LimitOrderBook.t.sol#68) is not in mixedCase
Parameter LimitOrderSwapRouter.getAllPrices(address,address,uint24).FEE (src/LimitOrderSwapRouter.sol#728) is not in mixedCase
Constant LimitOrderSwapRouter.MIN_FEE_64x64 (src/LimitOrderSwapRouter.sol#102) is not in UPPER_CASE_WITH_UNDERSCORES
Constant LimitOrderSwapRouter.ONE_128x128 (src/LimitOrderSwapRouter.sol#107) is not in UPPER_CASE_WITH_UNDERSCORES
Variable LimitOrderSwapRouter.UNISWAP_V3_FACTORY (src/LimitOrderSwapRouter.sol#118) is not in mixedCase
Parameter SwapRouterTest.testCalculateFee(uint112)._amount (src/test/SwapRouter.t.sol#333) is not in mixedCase
Function SwapRouterTest.testFailUniswapV3Callback_UnauthorizedUniswapV3CallbackCaller() (src/test/SwapRouter.t.sol#370-382) is not in mixedCase
Parameter SwapRouterTest.uint2str(uint256)._i (src/test/SwapRouter.t.sol#459) is not in mixedCase
Function SwapRouterTest.testSwapV2_1() (src/test/SwapRouter.t.sol#522-547) is not in mixedCase
Function SwapRouterTest.testSwapV2_2() (src/test/SwapRouter.t.sol#549-574) is not in mixedCase
Function SwapRouterTest.testSwapV2_3() (src/test/SwapRouter.t.sol#576-602) is not in mixedCase
Function SwapRouterTest.testFailSwapV2_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#604-631) is not in mixedCase
Function SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664) is not in mixedCase
Function SwapRouterTest.testSwapV3_2() (src/test/SwapRouter.t.sol#667-692) is not in mixedCase
Function SwapRouterTest.testFailSwap_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#725-755) is not in mixedCase
Variable SwapRouterTest._uniV2Address (src/test/SwapRouter.t.sol#52) is not in mixedCase
Variable SwapRouterTest._uniV2FactoryAddress (src/test/SwapRouter.t.sol#53) is not in mixedCase
Variable SwapRouterTest._sushiFactoryAddress (src/test/SwapRouter.t.sol#54) is not in mixedCase
Variable SwapRouterTest._pancakeFactoryAddress (src/test/SwapRouter.t.sol#55) is not in mixedCase
Variable SwapRouterTest._uniV3FactoryAddress (src/test/SwapRouter.t.sol#56) is not in mixedCase
Variable SwapRouterTest.WETH (src/test/SwapRouter.t.sol#65) is not in mixedCase
Variable SwapRouterTest._sushiHexDem (src/test/SwapRouter.t.sol#68-69) is not in mixedCase
Variable SwapRouterTest._uniswapV2HexDem (src/test/SwapRouter.t.sol#70-71) is not in mixedCase
Variable SwapRouterTest._hexDems (src/test/SwapRouter.t.sol#77) is not in mixedCase
Variable SwapRouterTest._dexFactories (src/test/SwapRouter.t.sol#78-82) is not in mixedCase
Variable SwapRouterTest._isUniV2 (src/test/SwapRouter.t.sol#83) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._tokenIn (src/test/SwapRouter.t.sol#783) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._tokenOut (src/test/SwapRouter.t.sol#784) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._lp (src/test/SwapRouter.t.sol#785) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._amountIn (src/test/SwapRouter.t.sol#786) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._amountOutMin (src/test/SwapRouter.t.sol#787) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._receiver (src/test/SwapRouter.t.sol#788) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV2(address,address,address,uint256,uint256,address,address)._sender (src/test/SwapRouter.t.sol#789) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._lp (src/test/SwapRouter.t.sol#804) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._tokenIn (src/test/SwapRouter.t.sol#805) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._tokenOut (src/test/SwapRouter.t.sol#806) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._fee (src/test/SwapRouter.t.sol#807) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._amountIn (src/test/SwapRouter.t.sol#808) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._amountOutMin (src/test/SwapRouter.t.sol#809) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._receiver (src/test/SwapRouter.t.sol#810) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._sender (src/test/SwapRouter.t.sol#811) is not in mixedCase
Parameter LimitOrderExecutorWrapper.calculateV2SpotPrice(address,address,address,bytes32)._factory (src/test/SwapRouter.t.sol#829) is not in mixedCase
Parameter LimitOrderExecutorWrapper.calculateV2SpotPrice(address,address,address,bytes32)._initBytecode (src/test/SwapRouter.t.sol#830) is not in mixedCase
Parameter LimitOrderExecutorWrapper.calculateV3SpotPrice(address,address,uint24,address).FEE (src/test/SwapRouter.t.sol#838) is not in mixedCase
Parameter LimitOrderExecutorWrapper.calculateV3SpotPrice(address,address,uint24,address)._factory (src/test/SwapRouter.t.sol#839) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._tokenIn (src/test/SwapRouter.t.sol#845) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._tokenOut (src/test/SwapRouter.t.sol#846) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._lp (src/test/SwapRouter.t.sol#847) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._fee (src/test/SwapRouter.t.sol#848) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._amountIn (src/test/SwapRouter.t.sol#849) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._amountOutMin (src/test/SwapRouter.t.sol#850) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._receiver (src/test/SwapRouter.t.sol#851) is not in mixedCase
Parameter LimitOrderExecutorWrapper.swap(address,address,address,uint24,uint256,uint256,address,address)._sender (src/test/SwapRouter.t.sol#852) is not in mixedCase
Constant ConveyorTickMath.MAX_64x64 (src/lib/ConveyorTickMath.sol#32) is not in UPPER_CASE_WITH_UNDERSCORES
Parameter LimitOrderQuoterTest.testSimulateAToBPriceChangeV2ReserveOutputs(uint112)._amountIn (src/test/LimitOrderQuoter.t.sol#172) is not in mixedCase
Parameter LimitOrderQuoterTest.testSimulateAToBPriceChangeV2SpotPrice(uint64)._amountIn (src/test/LimitOrderQuoter.t.sol#216) is not in mixedCase
Function LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneTrue(uint64) (src/test/LimitOrderQuoter.t.sol#249-288) is not in mixedCase
Parameter LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneTrue(uint64)._alphaX (src/test/LimitOrderQuoter.t.sol#249) is not in mixedCase
Function LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneFalse(uint64) (src/test/LimitOrderQuoter.t.sol#290-329) is not in mixedCase
Parameter LimitOrderQuoterTest.testSimulateAmountOutV3_Fuzz1_ZeroForOneFalse(uint64)._alphaX (src/test/LimitOrderQuoter.t.sol#290) is not in mixedCase
Parameter LimitOrderQuoterTest.uint2str(uint256)._i (src/test/LimitOrderQuoter.t.sol#387) is not in mixedCase
Variable LimitOrderQuoterTest.WETH (src/test/LimitOrderQuoter.t.sol#59) is not in mixedCase
Variable LimitOrderQuoterTest.LINK (src/test/LimitOrderQuoter.t.sol#60) is not in mixedCase
Variable LimitOrderQuoterTest.UNI (src/test/LimitOrderQuoter.t.sol#61) is not in mixedCase
Variable LimitOrderQuoterTest.USDC (src/test/LimitOrderQuoter.t.sol#62) is not in mixedCase
Variable LimitOrderQuoterTest.DAI (src/test/LimitOrderQuoter.t.sol#63) is not in mixedCase
Variable LimitOrderQuoterTest.TAXED_TOKEN (src/test/LimitOrderQuoter.t.sol#64) is not in mixedCase
Variable LimitOrderQuoterTest.TAXED_TOKEN_1 (src/test/LimitOrderQuoter.t.sol#65) is not in mixedCase
Variable LimitOrderQuoterTest.TAXED_TOKEN_2 (src/test/LimitOrderQuoter.t.sol#66) is not in mixedCase
Variable LimitOrderQuoterTest.TAXED_TOKEN_3 (src/test/LimitOrderQuoter.t.sol#67) is not in mixedCase
Variable LimitOrderQuoterTest._sushiSwapRouterAddress (src/test/LimitOrderQuoter.t.sol#75-76) is not in mixedCase
Variable LimitOrderQuoterTest._uniV2FactoryAddress (src/test/LimitOrderQuoter.t.sol#77) is not in mixedCase
Variable LimitOrderQuoterTest._uniV3FactoryAddress (src/test/LimitOrderQuoter.t.sol#79) is not in mixedCase
Variable LimitOrderQuoterTest._uniswapV2HexDem (src/test/LimitOrderQuoter.t.sol#85-86) is not in mixedCase
Variable LimitOrderQuoterTest._hexDems (src/test/LimitOrderQuoter.t.sol#89-93) is not in mixedCase
Variable LimitOrderQuoterTest._dexFactories (src/test/LimitOrderQuoter.t.sol#94-98) is not in mixedCase
Variable LimitOrderQuoterTest._isUniV2 (src/test/LimitOrderQuoter.t.sol#99-103) is not in mixedCase
Contract utils (src/test/utils/Utils.sol#4-92) is not in CapWords
Parameter utils.callDataCost(bytes)._callData (src/test/utils/Utils.sol#6) is not in mixedCase
Parameter utils.hexStrToBytes(string).hex_str (src/test/utils/Utils.sol#27) is not in mixedCase
Contract console (src/test/utils/Console.sol#4-1532) is not in CapWords
Parameter LimitOrderExecutorTest.testCalculateMinGasCredits(uint128)._amount (src/test/LimitOrderExecutor.t.sol#208) is not in mixedCase
Function LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#308-329) is not in mixedCase
Function LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1329-1358) is not in mixedCase
Function LimitOrderExecutorTest.testFailExecuteTokenToTokenBatch_DuplicateOrdersInExecution() (src/test/LimitOrderExecutor.t.sol#1361-1390) is not in mixedCase
Function LimitOrderExecutorTest.testFailExecuteTokenToWethOrderBatch_InvalidNonEOAStoplossExecution() (src/test/LimitOrderExecutor.t.sol#1393-1421) is not in mixedCase
Function LimitOrderExecutorTest.testFailExecuteOrders_InvalidCalldata() (src/test/LimitOrderExecutor.t.sol#1424-1429) is not in mixedCase
Function LimitOrderExecutorTest.testFailExecuteOrders_OrderDoesNotExist() (src/test/LimitOrderExecutor.t.sol#1432-1437) is not in mixedCase
Parameter LimitOrderExecutorTest.depositGasCreditsForMockOrders(uint256)._amount (src/test/LimitOrderExecutor.t.sol#1539) is not in mixedCase
Function LimitOrderExecutorTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1771-1828) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1830-1887) is not in mixedCase
Function LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) is not in mixedCase
Function LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) is not in mixedCase
Function LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2144-2201) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2203-2260) is not in mixedCase
Function LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2262-2319) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2321-2378) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderExecutor.t.sol#2380-2422) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderExecutor.t.sol#2424-2466) is not in mixedCase
Function LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2468-2525) is not in mixedCase
Function LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2527-2583) is not in mixedCase
Variable LimitOrderExecutorTest.WETH (src/test/LimitOrderExecutor.t.sol#50) is not in mixedCase
Variable LimitOrderExecutorTest.LINK (src/test/LimitOrderExecutor.t.sol#51) is not in mixedCase
Variable LimitOrderExecutorTest.UNI (src/test/LimitOrderExecutor.t.sol#52) is not in mixedCase
Variable LimitOrderExecutorTest.USDC (src/test/LimitOrderExecutor.t.sol#53) is not in mixedCase
Variable LimitOrderExecutorTest.DAI (src/test/LimitOrderExecutor.t.sol#54) is not in mixedCase
Variable LimitOrderExecutorTest.TAXED_TOKEN (src/test/LimitOrderExecutor.t.sol#55) is not in mixedCase
Variable LimitOrderExecutorTest.TAXED_TOKEN_1 (src/test/LimitOrderExecutor.t.sol#56) is not in mixedCase
Variable LimitOrderExecutorTest.TAXED_TOKEN_2 (src/test/LimitOrderExecutor.t.sol#57) is not in mixedCase
Variable LimitOrderExecutorTest.TAXED_TOKEN_3 (src/test/LimitOrderExecutor.t.sol#58) is not in mixedCase
Variable LimitOrderExecutorTest._sushiSwapRouterAddress (src/test/LimitOrderExecutor.t.sol#66-67) is not in mixedCase
Variable LimitOrderExecutorTest._uniV2FactoryAddress (src/test/LimitOrderExecutor.t.sol#68) is not in mixedCase
Variable LimitOrderExecutorTest._uniV3FactoryAddress (src/test/LimitOrderExecutor.t.sol#70) is not in mixedCase
Variable LimitOrderExecutorTest._uniswapV2HexDem (src/test/LimitOrderExecutor.t.sol#75-76) is not in mixedCase
Variable LimitOrderExecutorTest._hexDems (src/test/LimitOrderExecutor.t.sol#81) is not in mixedCase
Variable LimitOrderExecutorTest._dexFactories (src/test/LimitOrderExecutor.t.sol#82) is not in mixedCase
Variable LimitOrderExecutorTest._isUniV2 (src/test/LimitOrderExecutor.t.sol#83) is not in mixedCase
Function ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneFalse(uint64) (src/test/ConveyorTickMath.t.sol#111-155) is not in mixedCase
Parameter ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneFalse(uint64)._alphaX (src/test/ConveyorTickMath.t.sol#112) is not in mixedCase
Function ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneTrue(uint72) (src/test/ConveyorTickMath.t.sol#159-199) is not in mixedCase
Parameter ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneTrue(uint72)._alphaX (src/test/ConveyorTickMath.t.sol#159) is not in mixedCase
Parameter ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96CrossTick(uint112)._alphaX (src/test/ConveyorTickMath.t.sol#203) is not in mixedCase
Variable ConveyorTickMathTest.WETH (src/test/ConveyorTickMath.t.sol#51) is not in mixedCase
Variable ConveyorTickMathTest.USDC (src/test/ConveyorTickMath.t.sol#52) is not in mixedCase
Variable ConveyorTickMathTest.DAI (src/test/ConveyorTickMath.t.sol#53) is not in mixedCase
Variable ConveyorTickMathTest._sushiSwapRouterAddress (src/test/ConveyorTickMath.t.sol#65-66) is not in mixedCase
Variable ConveyorTickMathTest._uniV2FactoryAddress (src/test/ConveyorTickMath.t.sol#67) is not in mixedCase
Variable ConveyorTickMathTest._uniV3FactoryAddress (src/test/ConveyorTickMath.t.sol#69) is not in mixedCase
Variable ConveyorTickMathTest._uniswapV2HexDem (src/test/ConveyorTickMath.t.sol#73-74) is not in mixedCase
Variable ConveyorTickMathTest._hexDems (src/test/ConveyorTickMath.t.sol#77-81) is not in mixedCase
Variable ConveyorTickMathTest._dexFactories (src/test/ConveyorTickMath.t.sol#82-86) is not in mixedCase
Variable ConveyorTickMathTest._isUniV2 (src/test/ConveyorTickMath.t.sol#87-91) is not in mixedCase
Variable ConveyorTickMathTest._uniV2Address (src/test/ConveyorTickMath.t.sol#92) is not in mixedCase
Function ConveyorTickMathWrapper._fromSqrtX96(uint160,bool,address,address) (src/test/ConveyorTickMath.t.sol#287-294) is not in mixedCase
Function ConveyorTickMathWrapper._simulateAmountOutOnSqrtPriceX96(address,address,address,uint256,int24,uint128,uint24) (src/test/ConveyorTickMath.t.sol#296-315) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._lp (src/test/ConveyorTickMath.t.sol#326) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._tokenIn (src/test/ConveyorTickMath.t.sol#327) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._tokenOut (src/test/ConveyorTickMath.t.sol#328) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._fee (src/test/ConveyorTickMath.t.sol#329) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._amountIn (src/test/ConveyorTickMath.t.sol#330) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._amountOutMin (src/test/ConveyorTickMath.t.sol#331) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._receiver (src/test/ConveyorTickMath.t.sol#332) is not in mixedCase
Parameter SwapRouterWrapper.swapV3(address,address,address,uint24,uint256,uint256,address,address)._sender (src/test/ConveyorTickMath.t.sol#333) is not in mixedCase
Constant ConveyorGasOracle.timeHorizon (src/ConveyorGasOracle.sol#15) is not in UPPER_CASE_WITH_UNDERSCORES
Function IERC20Permit.DOMAIN_SEPARATOR() (lib/interfaces/token/draft-IERC20Permit.sol#59) is not in mixedCase
Event DSTestlog(string) (src/test/utils/test.sol#19) is not in CapWords
Event DSTestlogs(bytes) (src/test/utils/test.sol#20) is not in CapWords
Event DSTestlog_address(address) (src/test/utils/test.sol#22) is not in CapWords
Event DSTestlog_bytes32(bytes32) (src/test/utils/test.sol#23) is not in CapWords
Event DSTestlog_int(int256) (src/test/utils/test.sol#24) is not in CapWords
Event DSTestlog_uint(uint256) (src/test/utils/test.sol#25) is not in CapWords
Event DSTestlog_bytes(bytes) (src/test/utils/test.sol#26) is not in CapWords
Event DSTestlog_string(string) (src/test/utils/test.sol#27) is not in CapWords
Event DSTestlog_named_address(string,address) (src/test/utils/test.sol#29) is not in CapWords
Event DSTestlog_named_bytes32(string,bytes32) (src/test/utils/test.sol#30) is not in CapWords
Event DSTestlog_named_decimal_int(string,int256,uint256) (src/test/utils/test.sol#31) is not in CapWords
Event DSTestlog_named_decimal_uint(string,uint256,uint256) (src/test/utils/test.sol#32) is not in CapWords
Event DSTestlog_named_int(string,int256) (src/test/utils/test.sol#33) is not in CapWords
Event DSTestlog_named_uint(string,uint256) (src/test/utils/test.sol#34) is not in CapWords
Event DSTestlog_named_bytes(string,bytes) (src/test/utils/test.sol#35) is not in CapWords
Event DSTestlog_named_string(string,string) (src/test/utils/test.sol#36) is not in CapWords
Variable DSTest.IS_TEST (src/test/utils/test.sol#38) is not in mixedCase
Modifier DSTest.logs_gas() (src/test/utils/test.sol#51-56) is not in mixedCase
Variable SandboxLimitOrderBook.LIMIT_ORDER_EXECUTOR (src/SandboxLimitOrderBook.sol#22) is not in mixedCase
Variable SandboxLimitOrderBook.SANDBOX_LIMIT_ORDER_ROUTER (src/SandboxLimitOrderBook.sol#24) is not in mixedCase
Variable SandboxLimitOrderBook.CONVEYOR_GAS_ORACLE (src/SandboxLimitOrderBook.sol#26) is not in mixedCase
Variable SandboxLimitOrderBook.SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/SandboxLimitOrderBook.sol#28) is not in mixedCase
Variable SandboxLimitOrderBook.WETH (src/SandboxLimitOrderBook.sol#30) is not in mixedCase
Variable SandboxLimitOrderBook.USDC (src/SandboxLimitOrderBook.sol#32) is not in mixedCase
Function ILimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32) (src/interfaces/ILimitOrderSwapRouter.sol#19-30) is not in mixedCase
Parameter ILimitOrderSwapRouter.getAllPrices(address,address,uint24).FEE (src/interfaces/ILimitOrderSwapRouter.sol#41) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV3Call(address,address,address,bool,uint256,address)._lp (src/test/ConveyorSwapAggregator.t.sol#216) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV3Call(address,address,address,bool,uint256,address)._sender (src/test/ConveyorSwapAggregator.t.sol#217) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV3Call(address,address,address,bool,uint256,address)._receiver (src/test/ConveyorSwapAggregator.t.sol#218) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV3Call(address,address,address,bool,uint256,address)._zeroForOne (src/test/ConveyorSwapAggregator.t.sol#219) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV3Call(address,address,address,bool,uint256,address)._amountIn (src/test/ConveyorSwapAggregator.t.sol#220) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV3Call(address,address,address,bool,uint256,address)._tokenIn (src/test/ConveyorSwapAggregator.t.sol#221) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV2Call(address,uint256,uint256,address)._lp (src/test/ConveyorSwapAggregator.t.sol#242) is not in mixedCase
Parameter ConveyorSwapAggregatorTest.newUniV2Call(address,uint256,uint256,address)._receiver (src/test/ConveyorSwapAggregator.t.sol#245) is not in mixedCase
Function SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_FillAmountSpecifiedGreaterThanAmountRemaining() (src/test/SandboxLimitOrderRouter.t.sol#726-794) is not in mixedCase
Function SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_SandboxAmountOutRequiredNotSatisfied() (src/test/SandboxLimitOrderRouter.t.sol#796-865) is not in mixedCase
Function SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_ConveyorFeesNotPaid() (src/test/SandboxLimitOrderRouter.t.sol#867-934) is not in mixedCase
Function SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_InvalidTransferAddressArray() (src/test/SandboxLimitOrderRouter.t.sol#936-1006) is not in mixedCase
Function SandboxLimitOrderRouterTest._requireConveyorFeeIsPaid(uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1277-1317) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV2Call(address,uint256,uint256,address)._lp (src/test/SandboxLimitOrderRouter.t.sol#1682) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV2Call(address,uint256,uint256,address)._receiver (src/test/SandboxLimitOrderRouter.t.sol#1685) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV3Call(address,address,address,bool,uint256,address)._lp (src/test/SandboxLimitOrderRouter.t.sol#1699) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV3Call(address,address,address,bool,uint256,address)._sender (src/test/SandboxLimitOrderRouter.t.sol#1700) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV3Call(address,address,address,bool,uint256,address)._receiver (src/test/SandboxLimitOrderRouter.t.sol#1701) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV3Call(address,address,address,bool,uint256,address)._zeroForOne (src/test/SandboxLimitOrderRouter.t.sol#1702) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV3Call(address,address,address,bool,uint256,address)._amountIn (src/test/SandboxLimitOrderRouter.t.sol#1703) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newUniV3Call(address,address,address,bool,uint256,address)._tokenIn (src/test/SandboxLimitOrderRouter.t.sol#1704) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.newMockMulticall(bytes32[][],uint128[],address[],SandboxLimitOrderRouter.Call[])._calls (src/test/SandboxLimitOrderRouter.t.sol#1728) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.depositGasCreditsForMockOrders(uint256)._amount (src/test/SandboxLimitOrderRouter.t.sol#1768) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.depositGasCreditsForMockOrdersWrapper(uint256)._amount (src/test/SandboxLimitOrderRouter.t.sol#1776) is not in mixedCase
Parameter SandboxLimitOrderRouterTest.depositGasCreditsForMockOrdersCustomOwner(uint256,address)._amount (src/test/SandboxLimitOrderRouter.t.sol#1786) is not in mixedCase
Variable SandboxLimitOrderRouterTest.WETH (src/test/SandboxLimitOrderRouter.t.sol#78) is not in mixedCase
Variable SandboxLimitOrderRouterTest.LINK (src/test/SandboxLimitOrderRouter.t.sol#79) is not in mixedCase
Variable SandboxLimitOrderRouterTest.UNI (src/test/SandboxLimitOrderRouter.t.sol#80) is not in mixedCase
Variable SandboxLimitOrderRouterTest.USDC (src/test/SandboxLimitOrderRouter.t.sol#81) is not in mixedCase
Variable SandboxLimitOrderRouterTest.DAI (src/test/SandboxLimitOrderRouter.t.sol#82) is not in mixedCase
Variable SandboxLimitOrderRouterTest._sushiSwapRouterAddress (src/test/SandboxLimitOrderRouter.t.sol#85-86) is not in mixedCase
Variable SandboxLimitOrderRouterTest._uniV2FactoryAddress (src/test/SandboxLimitOrderRouter.t.sol#87) is not in mixedCase
Variable SandboxLimitOrderRouterTest._uniV3FactoryAddress (src/test/SandboxLimitOrderRouter.t.sol#89) is not in mixedCase
Variable SandboxLimitOrderRouterTest._uniswapV2HexDem (src/test/SandboxLimitOrderRouter.t.sol#92-93) is not in mixedCase
Variable SandboxLimitOrderRouterTest._hexDems (src/test/SandboxLimitOrderRouter.t.sol#96) is not in mixedCase
Variable SandboxLimitOrderRouterTest._dexFactories (src/test/SandboxLimitOrderRouter.t.sol#97) is not in mixedCase
Variable SandboxLimitOrderRouterTest._isUniV2 (src/test/SandboxLimitOrderRouter.t.sol#98) is not in mixedCase
Variable SandboxLimitOrderRouterTest.SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#99) is not in mixedCase
Function SandboxLimitOrderBookWrapper._getSandboxLimitOrderById(bytes32) (src/test/SandboxLimitOrderRouter.t.sol#2092-2098) is not in mixedCase
Variable ConveyorSwapAggregator.CONVEYOR_SWAP_EXECUTOR (src/ConveyorSwapAggregator.sol#16) is not in mixedCase
Variable LimitOrderQuoter.WETH (src/LimitOrderQuoter.sol#11) is not in mixedCase
Variable LimitOrderExecutor.WETH (src/LimitOrderExecutor.sol#19) is not in mixedCase
Variable LimitOrderExecutor.USDC (src/LimitOrderExecutor.sol#20) is not in mixedCase
Variable LimitOrderExecutor.LIMIT_ORDER_QUOTER (src/LimitOrderExecutor.sol#21) is not in mixedCase
Variable LimitOrderExecutor.LIMIT_ORDER_ROUTER (src/LimitOrderExecutor.sol#22) is not in mixedCase
Variable LimitOrderExecutor.SANDBOX_LIMIT_ORDER_BOOK (src/LimitOrderExecutor.sol#23) is not in mixedCase
Variable LimitOrderExecutor.SANDBOX_LIMIT_ORDER_ROUTER (src/LimitOrderExecutor.sol#24) is not in mixedCase
Variable LimitOrderExecutor.LIMIT_ORDER_EXECUTION_GAS_COST (src/LimitOrderExecutor.sol#25) is not in mixedCase
Variable LimitOrderExecutor.SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/LimitOrderExecutor.sol#26) is not in mixedCase
Parameter ConveyorFeeMathTest.uint2str(uint256)._i (src/test/ConveyorFeeMath.t.sol#157) is not in mixedCase
Variable ConveyorFeeMathTest._uniV2Address (src/test/ConveyorFeeMath.t.sol#35) is not in mixedCase
Variable ConveyorFeeMathTest._uniV2FactoryAddress (src/test/ConveyorFeeMath.t.sol#36) is not in mixedCase
Variable ConveyorFeeMathTest._sushiFactoryAddress (src/test/ConveyorFeeMath.t.sol#37) is not in mixedCase
Variable ConveyorFeeMathTest._uniV3FactoryAddress (src/test/ConveyorFeeMath.t.sol#38) is not in mixedCase
Variable ConveyorFeeMathTest.WETH (src/test/ConveyorFeeMath.t.sol#47) is not in mixedCase
Variable ConveyorFeeMathTest._sushiHexDem (src/test/ConveyorFeeMath.t.sol#50-51) is not in mixedCase
Variable ConveyorFeeMathTest._uniswapV2HexDem (src/test/ConveyorFeeMath.t.sol#52-53) is not in mixedCase
Variable ConveyorFeeMathTest._hexDems (src/test/ConveyorFeeMath.t.sol#59) is not in mixedCase
Variable ConveyorFeeMathTest._dexFactories (src/test/ConveyorFeeMath.t.sol#60-64) is not in mixedCase
Variable ConveyorFeeMathTest._isUniV2 (src/test/ConveyorFeeMath.t.sol#65) is not in mixedCase
Function ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) is not in mixedCase
Constant ConveyorMath.MAX_64x64 (src/lib/ConveyorMath.sol#8) is not in UPPER_CASE_WITH_UNDERSCORES
Constant ConveyorMath.MIN_64x64 (src/lib/ConveyorMath.sol#13) is not in UPPER_CASE_WITH_UNDERSCORES
Constant ConveyorMath.MAX_128x128 (src/lib/ConveyorMath.sol#16-17) is not in UPPER_CASE_WITH_UNDERSCORES
Function QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) is not in mixedCase
Constant QuadruplePrecision.NaN (lib/libraries/QuadruplePrecision.sol#29) is not in UPPER_CASE_WITH_UNDERSCORES
Variable LimitOrderBook.LIMIT_ORDER_EXECUTOR (src/LimitOrderBook.sol#16) is not in mixedCase
Variable LimitOrderBook.CONVEYOR_GAS_ORACLE (src/LimitOrderBook.sol#21) is not in mixedCase
Variable LimitOrderBook.LIMIT_ORDER_EXECUTION_GAS_COST (src/LimitOrderBook.sol#24) is not in mixedCase
Variable LimitOrderBook.WETH (src/LimitOrderBook.sol#26) is not in mixedCase
Variable LimitOrderBook.USDC (src/LimitOrderBook.sol#27) is not in mixedCase
Function IConveyorSwapAggregator.CONVEYOR_SWAP_EXECUTOR() (src/interfaces/IConveyorSwapAggregator.sol#15) is not in mixedCase
Function IUniswapV2Router01.WETH() (lib/interfaces/uniswap-v2/IUniswapV2Router01.sol#6) is not in mixedCase
Function IUniswapV2Pair.DOMAIN_SEPARATOR() (lib/interfaces/uniswap-v2/IUniswapV2Pair.sol#19) is not in mixedCase
Function IUniswapV2Pair.PERMIT_TYPEHASH() (lib/interfaces/uniswap-v2/IUniswapV2Pair.sol#20) is not in mixedCase
Function IUniswapV2Pair.MINIMUM_LIQUIDITY() (lib/interfaces/uniswap-v2/IUniswapV2Pair.sol#37) is not in mixedCase
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions

Redundant expression "i (src/test/utils/Utils.sol#16)" inutils (src/test/utils/Utils.sol#4-92)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements

Variable LimitOrderRouterTest.TAXED_TOKEN_1 (src/test/LimitOrderRouter.t.sol#59) is too similar to LimitOrderRouterTest.TAXED_TOKEN_2 (src/test/LimitOrderRouter.t.sol#60)
Variable LimitOrderRouterTest.TAXED_TOKEN_1 (src/test/LimitOrderRouter.t.sol#59) is too similar to LimitOrderRouterTest.TAXED_TOKEN_3 (src/test/LimitOrderRouter.t.sol#61)
Variable LimitOrderRouterTest.TAXED_TOKEN_2 (src/test/LimitOrderRouter.t.sol#60) is too similar to LimitOrderRouterTest.TAXED_TOKEN_3 (src/test/LimitOrderRouter.t.sol#61)
Variable LimitOrderRouterTest._uniV2FactoryAddress (src/test/LimitOrderRouter.t.sol#71) is too similar to LimitOrderRouterTest._uniV3FactoryAddress (src/test/LimitOrderRouter.t.sol#73)
Variable LimitOrderRouter._calculateExecutionGasCompensation(uint256,address[],LimitOrderBook.OrderType).gasExecutionCompensation (src/LimitOrderRouter.sol#487) is too similar to LimitOrderRouter._calculateExecutionGasConsumed(uint256,uint256,LimitOrderBook.OrderType).maxExecutionCompensation (src/LimitOrderRouter.sol#471-473)
Variable IUniswapV3PoolState.positions(bytes32).feeGrowthInside0LastX128 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#93) is too similar to IUniswapV3PoolState.positions(bytes32).feeGrowthInside1LastX128 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#94)
Variable IUniswapV3PoolState.ticks(int24).feeGrowthOutside0X128 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#70) is too similar to IUniswapV3PoolState.ticks(int24).feeGrowthOutside1X128 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#71)
Variable IUniswapV3PoolState.positions(bytes32).tokensOwed0 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#95) is too similar to IUniswapV3PoolState.positions(bytes32).tokensOwed1 (lib/interfaces/uniswap-v3/IUniswapV3PoolState.sol#96)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#156) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#157)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#156) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#209)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#226) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#227)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#226) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#157)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#226) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#209)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#156) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#227)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#208) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#209)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#156) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#188)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#187) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#188)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#187) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#209)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#208) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#188)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#187) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#227)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#187) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#157)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#208) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#227)
Variable SqrtPriceMath.getAmount0Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#208) is too similar to SqrtPriceMath.getAmount0Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#157)
Variable SqrtPriceMath.getAmount1Delta(uint160,uint160,int128).sqrtRatioAX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#226) is too similar to SqrtPriceMath.getAmount1Delta(uint160,uint160,uint128,bool).sqrtRatioBX96 (lib/libraries/Uniswap/SqrtPriceMath.sol#188)
Variable SandboxLimitOrderRouter.uniswapV3SwapCallback(int256,int256,bytes).amount0Delta (src/SandboxLimitOrderRouter.sol#90) is too similar to SandboxLimitOrderRouter.uniswapV3SwapCallback(int256,int256,bytes).amount1Delta (src/SandboxLimitOrderRouter.sol#91)
Variable SandboxLimitOrderBookTest._uniV2FactoryAddress (src/test/SandboxLimitOrderBook.t.sol#66) is too similar to SandboxLimitOrderBookTest._uniV3FactoryAddress (src/test/SandboxLimitOrderBook.t.sol#67)
Variable SandboxLimitOrderBook._calculateExecutionGasCompensation(uint256,address[],SandboxLimitOrderBook.OrderType).gasExecutionCompensation (src/SandboxLimitOrderBook.sol#1134) is too similar to SandboxLimitOrderBook._calculateExecutionGasConsumed(uint256,uint256,SandboxLimitOrderBook.OrderType).maxExecutionCompensation (src/SandboxLimitOrderBook.sol#1118-1120)
Variable LimitOrderBookTest._uniV2FactoryAddress (src/test/LimitOrderBook.t.sol#54) is too similar to LimitOrderBookTest._uniV3FactoryAddress (src/test/LimitOrderBook.t.sol#55)
Variable LimitOrderSwapRouter.uniswapV3SwapCallback(int256,int256,bytes).amount0Delta (src/LimitOrderSwapRouter.sol#448) is too similar to LimitOrderSwapRouter.uniswapV3SwapCallback(int256,int256,bytes).amount1Delta (src/LimitOrderSwapRouter.sol#449)
Variable LimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32).commonReserve0 (src/LimitOrderSwapRouter.sol#552) is too similar to LimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32).commonReserve1 (src/LimitOrderSwapRouter.sol#553)
Variable LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128).commonReserve0 (src/LimitOrderSwapRouter.sol#593-595) is too similar to LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128).commonReserve1 (src/LimitOrderSwapRouter.sol#596-598)
Variable LimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32).commonReserve0 (src/LimitOrderSwapRouter.sol#552) is too similar to LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128).commonReserve1 (src/LimitOrderSwapRouter.sol#596-598)
Variable LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128).commonReserve0 (src/LimitOrderSwapRouter.sol#593-595) is too similar to LimitOrderSwapRouter._calculateV2SpotPrice(address,address,address,bytes32).commonReserve1 (src/LimitOrderSwapRouter.sol#553)
Variable LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128).token0Decimals (src/LimitOrderSwapRouter.sol#589) is too similar to LimitOrderSwapRouter._getReservesCommonDecimals(address,address,uint128,uint128).token1Decimals (src/LimitOrderSwapRouter.sol#590)
Variable SwapRouterTest._uniV2FactoryAddress (src/test/SwapRouter.t.sol#53) is too similar to SwapRouterTest._uniV3FactoryAddress (src/test/SwapRouter.t.sol#56)
Variable SwapRouterTest.testLPIsNotUniv3().uniV2LPAddress (src/test/SwapRouter.t.sol#108) is too similar to SwapRouterTest.testLPIsNotUniv3().uniV3LPAddress (src/test/SwapRouter.t.sol#109)
Variable LimitOrderQuoterTest.TAXED_TOKEN_1 (src/test/LimitOrderQuoter.t.sol#65) is too similar to LimitOrderQuoterTest.TAXED_TOKEN_2 (src/test/LimitOrderQuoter.t.sol#66)
Variable LimitOrderQuoterTest.TAXED_TOKEN_1 (src/test/LimitOrderQuoter.t.sol#65) is too similar to LimitOrderQuoterTest.TAXED_TOKEN_3 (src/test/LimitOrderQuoter.t.sol#67)
Variable LimitOrderQuoterTest.TAXED_TOKEN_2 (src/test/LimitOrderQuoter.t.sol#66) is too similar to LimitOrderQuoterTest.TAXED_TOKEN_3 (src/test/LimitOrderQuoter.t.sol#67)
Variable LimitOrderQuoterTest._uniV2FactoryAddress (src/test/LimitOrderQuoter.t.sol#77) is too similar to LimitOrderQuoterTest._uniV3FactoryAddress (src/test/LimitOrderQuoter.t.sol#79)
Variable LimitOrderQuoterTest.testSimulateAToBPriceChangeV2ReserveOutputs(uint112).expectedReserveA (src/test/LimitOrderQuoter.t.sol#205) is too similar to LimitOrderQuoterTest.testSimulateAToBPriceChangeV2ReserveOutputs(uint112).expectedReserveB (src/test/LimitOrderQuoter.t.sol#203)
Variable LimitOrderQuoterTest.testSimulateAToWethPriceChangeV2().newSpotPriceA (src/test/LimitOrderQuoter.t.sol#377) is too similar to LimitOrderQuoterTest.testSimulateWethToBPriceChangeV2().newSpotPriceB (src/test/LimitOrderQuoter.t.sol#350)
Variable LimitOrderQuoter.calculateAmountOutMinAToWeth(address,uint256,uint16,uint24,address).amountInBuffer_scope_0 (src/LimitOrderQuoter.sol#812) is too similar to LimitOrderQuoter.calculateAmountOutMinAToWeth(address,uint256,uint16,uint24,address).amountInBuffer_scope_2 (src/LimitOrderQuoter.sol#821)
Variable LimitOrderQuoter.calculateAmountOutMinAToWeth(address,uint256,uint16,uint24,address).amountIn_scope_1 (src/LimitOrderQuoter.sol#814) is too similar to LimitOrderQuoter.calculateAmountOutMinAToWeth(address,uint256,uint16,uint24,address).amountIn_scope_3 (src/LimitOrderQuoter.sol#823)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/test/LimitOrderQuoter.t.sol#455) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#451)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#332) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/test/LimitOrderQuoter.t.sol#471)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#374) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#420)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#332) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#341)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/test/LimitOrderQuoter.t.sol#455) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/test/LimitOrderQuoter.t.sol#471)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#374) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#451)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#332) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#420)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/test/LimitOrderQuoter.t.sol#455) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#420)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#374) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/test/LimitOrderQuoter.t.sol#471)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#332) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#451)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#375) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/test/LimitOrderQuoter.t.sol#470)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#375) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#419)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/test/LimitOrderQuoter.t.sol#456) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#450)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#375) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#342)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#333) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#450)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/test/LimitOrderQuoter.t.sol#456) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/test/LimitOrderQuoter.t.sol#470)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/test/LimitOrderQuoter.t.sol#456) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#419)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#333) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/test/LimitOrderQuoter.t.sol#470)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/test/LimitOrderQuoter.t.sol#456) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#342)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#375) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#450)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#333) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#419)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAWeth (src/LimitOrderQuoter.sol#333) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBWeth (src/LimitOrderQuoter.sol#342)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/test/LimitOrderQuoter.t.sol#455) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#341)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveAToken (src/LimitOrderQuoter.sol#374) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newReserveBToken (src/LimitOrderQuoter.sol#341)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/test/LimitOrderQuoter.t.sol#454) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/test/LimitOrderQuoter.t.sol#469)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#331) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#449)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#373) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#449)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#331) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/test/LimitOrderQuoter.t.sol#469)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#373) is too similar to ExecutionWrapper.simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/test/LimitOrderQuoter.t.sol#469)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#331) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#418)
Variable LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#331) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#340)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/test/LimitOrderQuoter.t.sol#454) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#449)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/test/LimitOrderQuoter.t.sol#454) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#340)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#373) is too similar to LimitOrderQuoter._simulateTokenToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#340)
Variable ExecutionWrapper.simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/test/LimitOrderQuoter.t.sol#454) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#418)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceA (src/LimitOrderQuoter.sol#373) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).newSpotPriceB (src/LimitOrderQuoter.sol#418)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveAToken (src/LimitOrderQuoter.sol#380) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveBToken (src/LimitOrderQuoter.sol#456)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveAToken (src/LimitOrderQuoter.sol#380) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveBToken (src/LimitOrderQuoter.sol#411)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveAWeth (src/LimitOrderQuoter.sol#381) is too similar to LimitOrderQuoter._simulateWethToBPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveBWeth (src/LimitOrderQuoter.sol#455)
Variable LimitOrderQuoter._simulateAToWethPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveAWeth (src/LimitOrderQuoter.sol#381) is too similar to LimitOrderQuoter._simulateWethToTokenPriceChange(uint128,LimitOrderSwapRouter.TokenToTokenExecutionPrice).reserveBWeth (src/LimitOrderQuoter.sol#410)
Variable LimitOrderQuoter.calculateNextSqrtPriceX96(bool,address,uint256).sqrtSpotPrice128x128_scope_0 (src/LimitOrderQuoter.sol#708-713) is too similar to LimitOrderQuoter.calculateNextSqrtPriceX96(bool,address,uint256).sqrtSpotPrice128x128_scope_1 (src/LimitOrderQuoter.sol#730-735)
Variable LimitOrderQuoter.calculateNextSqrtPriceX96(bool,address,uint256).sqrtSpotPrice128x128_scope_0 (src/LimitOrderQuoter.sol#708-713) is too similar to LimitOrderQuoter.calculateNextSqrtPriceX96(bool,address,uint256).sqrtSpotPrice128x128_scope_2 (src/LimitOrderQuoter.sol#749-754)
Variable LimitOrderQuoter.calculateNextSqrtPriceX96(bool,address,uint256).sqrtSpotPrice128x128_scope_1 (src/LimitOrderQuoter.sol#730-735) is too similar to LimitOrderQuoter.calculateNextSqrtPriceX96(bool,address,uint256).sqrtSpotPrice128x128_scope_2 (src/LimitOrderQuoter.sol#749-754)
Variable Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthAbove0X128 (lib/libraries/Uniswap/Tick.sol#85) is too similar to Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthAbove1X128 (lib/libraries/Uniswap/Tick.sol#86)
Variable Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthBelow0X128 (lib/libraries/Uniswap/Tick.sol#74) is too similar to Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthBelow1X128 (lib/libraries/Uniswap/Tick.sol#75)
Variable Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthGlobal0X128 (lib/libraries/Uniswap/Tick.sol#66) is too similar to Tick.update(mapping(int24 => Tick.Info),int24,int24,int128,uint256,uint256,uint160,int56,uint32,bool,uint128).feeGrowthGlobal1X128 (lib/libraries/Uniswap/Tick.sol#119)
Variable Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthGlobal0X128 (lib/libraries/Uniswap/Tick.sol#66) is too similar to Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthGlobal1X128 (lib/libraries/Uniswap/Tick.sol#67)
Variable Tick.update(mapping(int24 => Tick.Info),int24,int24,int128,uint256,uint256,uint160,int56,uint32,bool,uint128).feeGrowthGlobal0X128 (lib/libraries/Uniswap/Tick.sol#118) is too similar to Tick.update(mapping(int24 => Tick.Info),int24,int24,int128,uint256,uint256,uint160,int56,uint32,bool,uint128).feeGrowthGlobal1X128 (lib/libraries/Uniswap/Tick.sol#119)
Variable Tick.update(mapping(int24 => Tick.Info),int24,int24,int128,uint256,uint256,uint160,int56,uint32,bool,uint128).feeGrowthGlobal0X128 (lib/libraries/Uniswap/Tick.sol#118) is too similar to Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthGlobal1X128 (lib/libraries/Uniswap/Tick.sol#67)
Variable Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthInside0X128 (lib/libraries/Uniswap/Tick.sol#68) is too similar to Tick.getFeeGrowthInside(mapping(int24 => Tick.Info),int24,int24,int24,uint256,uint256).feeGrowthInside1X128 (lib/libraries/Uniswap/Tick.sol#68)
Variable IUniswapV3SwapCallback.uniswapV3SwapCallback(int256,int256,bytes).amount0Delta (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#17) is too similar to IUniswapV3SwapCallback.uniswapV3SwapCallback(int256,int256,bytes).amount1Delta (lib/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol#18)
Variable LimitOrderExecutorTest.TAXED_TOKEN_1 (src/test/LimitOrderExecutor.t.sol#56) is too similar to LimitOrderExecutorTest.TAXED_TOKEN_2 (src/test/LimitOrderExecutor.t.sol#57)
Variable LimitOrderExecutorTest.TAXED_TOKEN_1 (src/test/LimitOrderExecutor.t.sol#56) is too similar to LimitOrderExecutorTest.TAXED_TOKEN_3 (src/test/LimitOrderExecutor.t.sol#58)
Variable LimitOrderExecutorTest.TAXED_TOKEN_2 (src/test/LimitOrderExecutor.t.sol#57) is too similar to LimitOrderExecutorTest.TAXED_TOKEN_3 (src/test/LimitOrderExecutor.t.sol#58)
Variable LimitOrderExecutorTest._uniV2FactoryAddress (src/test/LimitOrderExecutor.t.sol#68) is too similar to LimitOrderExecutorTest._uniV3FactoryAddress (src/test/LimitOrderExecutor.t.sol#70)
Variable LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112).order0_scope_1 (src/test/LimitOrderExecutor.t.sol#824-825) is too similar to LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80).order0_scope_3 (src/test/LimitOrderExecutor.t.sol#655-656)
Variable LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112).order0_scope_1 (src/test/LimitOrderExecutor.t.sol#473-474) is too similar to LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80).order0_scope_3 (src/test/LimitOrderExecutor.t.sol#655-656)
Variable LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle().order0_scope_1 (src/test/LimitOrderExecutor.t.sol#951-952) is too similar to LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80).order0_scope_3 (src/test/LimitOrderExecutor.t.sol#655-656)
Variable LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80).order0_scope_1 (src/test/LimitOrderExecutor.t.sol#644-645) is too similar to LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80).order0_scope_3 (src/test/LimitOrderExecutor.t.sol#655-656)
Variable LimitOrderExecutor._executeTokenToTokenOrder(LimitOrderBook.LimitOrder,LimitOrderSwapRouter.TokenToTokenExecutionPrice).amountOutInB (src/LimitOrderExecutor.sol#633-642) is too similar to LimitOrderSwapRouter.uniswapV3SwapCallback(int256,int256,bytes).amountOutMin (src/LimitOrderSwapRouter.sol#454)
Variable ConveyorTickMathTest._uniV2FactoryAddress (src/test/ConveyorTickMath.t.sol#67) is too similar to ConveyorTickMathTest._uniV3FactoryAddress (src/test/ConveyorTickMath.t.sol#69)
Variable ConveyorSwapAggregatorTest.uniswapV3SwapCallback(int256,int256,bytes).amount0Delta (src/test/ConveyorSwapAggregator.t.sol#191) is too similar to ConveyorSwapAggregatorTest.uniswapV3SwapCallback(int256,int256,bytes).amount1Delta (src/test/ConveyorSwapAggregator.t.sol#192)
Variable SandboxLimitOrderRouterTest._uniV2FactoryAddress (src/test/SandboxLimitOrderRouter.t.sol#87) is too similar to SandboxLimitOrderRouterTest._uniV3FactoryAddress (src/test/SandboxLimitOrderRouter.t.sol#89)
Variable ConveyorSwapExecutor.uniswapV3SwapCallback(int256,int256,bytes).amount0Delta (src/ConveyorSwapAggregator.sol#84) is too similar to ConveyorSwapExecutor.uniswapV3SwapCallback(int256,int256,bytes).amount1Delta (src/ConveyorSwapAggregator.sol#85)
Variable ConveyorFeeMathTest._uniV2FactoryAddress (src/test/ConveyorFeeMath.t.sol#36) is too similar to ConveyorFeeMathTest._uniV3FactoryAddress (src/test/ConveyorFeeMath.t.sol#38)
Variable IUniswapV2Router01.addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256).amountADesired (lib/interfaces/uniswap-v2/IUniswapV2Router01.sol#11) is too similar to IUniswapV2Router01.addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256).amountBDesired (lib/interfaces/uniswap-v2/IUniswapV2Router01.sol#12)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar

LimitOrderRouterTest.setUp() (src/test/LimitOrderRouter.t.sol#90-126) uses literals with too many digits:
	- limitOrderExecutor = new LimitOrderExecutor(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,250000) (src/test/LimitOrderRouter.t.sol#100-110)
LimitOrderRouterTest.setUp() (src/test/LimitOrderRouter.t.sol#90-126) uses literals with too many digits:
	- limitOrderRouterWrapper = new LimitOrderRouterWrapper(aggregatorV3Address,0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderExecutor),300000) (src/test/LimitOrderRouter.t.sol#119-125)
LimitOrderRouterTest.testValidateAndCancelOrder() (src/test/LimitOrderRouter.t.sol#242-275) uses literals with too many digits:
	- IWETH(WETH).withdraw(100000) (src/test/LimitOrderRouter.t.sol#264)
LimitOrderRouterTest.testRefreshOrder() (src/test/LimitOrderRouter.t.sol#309-360) uses literals with too many digits:
	- order = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#316-329)
LimitOrderRouterTest.testRefreshOrder_CancelOrderOrderExpired() (src/test/LimitOrderRouter.t.sol#363-410) uses literals with too many digits:
	- order = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,0) (src/test/LimitOrderRouter.t.sol#371-384)
LimitOrderRouterTest.testFailRefreshOrder_OrderNotEligibleForRefresh() (src/test/LimitOrderRouter.t.sol#414-449) uses literals with too many digits:
	- order1 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,1659049037,MAX_U32) (src/test/LimitOrderRouter.t.sol#421-434)
LimitOrderRouterTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderRouter.t.sol#559-629) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000000,3000,300,500,MAX_U32) (src/test/LimitOrderRouter.t.sol#565-578)
LimitOrderRouterTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderRouter.t.sol#559-629) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000001,3000,300,500,MAX_U32) (src/test/LimitOrderRouter.t.sol#580-593)
LimitOrderRouterTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderRouter.t.sol#559-629) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000002,3000,300,500,MAX_U32) (src/test/LimitOrderRouter.t.sol#594-607)
LimitOrderRouterTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderRouter.t.sol#559-629) uses literals with too many digits:
	- order4 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000003,3000,300,500,MAX_U32) (src/test/LimitOrderRouter.t.sol#608-621)
LimitOrderRouterTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#631-708) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#637-650)
LimitOrderRouterTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#631-708) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000001,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#652-665)
LimitOrderRouterTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#631-708) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000002,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#666-679)
LimitOrderRouterTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#631-708) uses literals with too many digits:
	- order4 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000003,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#680-693)
LimitOrderRouterTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderRouter.t.sol#710-781) uses literals with too many digits:
	- order1 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#716-729)
LimitOrderRouterTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderRouter.t.sol#710-781) uses literals with too many digits:
	- order2 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#731-744)
LimitOrderRouterTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderRouter.t.sol#710-781) uses literals with too many digits:
	- order3 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#745-758)
LimitOrderRouterTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderRouter.t.sol#710-781) uses literals with too many digits:
	- order4 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#759-772)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#783-840) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#789-802)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#783-840) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000003,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#804-817)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#783-840) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#818-831)
LimitOrderRouterTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#842-899) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#848-861)
LimitOrderRouterTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#842-899) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000003,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#863-876)
LimitOrderRouterTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderRouter.t.sol#842-899) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#877-890)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#908-921)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) uses literals with too many digits:
	- order2 = newMockOrder(USDC,WETH,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#923-936)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#901-965) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#937-950)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderRouter.t.sol#967-1027) uses literals with too many digits:
	- order1 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#974-988)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderRouter.t.sol#967-1027) uses literals with too many digits:
	- order2 = newMockStoplossOrder(USDC,WETH,1,false,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#990-1004)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderRouter.t.sol#967-1027) uses literals with too many digits:
	- order3 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1005-1019)
LimitOrderRouterTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderRouter.t.sol#1029-1094) uses literals with too many digits:
	- order1 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1036-1050)
LimitOrderRouterTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderRouter.t.sol#1029-1094) uses literals with too many digits:
	- order2 = newMockStoplossOrder(USDC,WETH,1,false,true,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1052-1066)
LimitOrderRouterTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderRouter.t.sol#1029-1094) uses literals with too many digits:
	- order3 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1067-1081)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#1096-1154) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1103-1116)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#1096-1154) uses literals with too many digits:
	- order2 = newMockOrder(USDC,WETH,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1118-1131)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderRouter.t.sol#1096-1154) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1132-1145)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1156-1213) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1162-1175)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1156-1213) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,true,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1177-1190)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1156-1213) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1191-1204)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1215-1272) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1221-1234)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1215-1272) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,true,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1236-1249)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderRouter.t.sol#1215-1272) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1250-1263)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1274-1331) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1280-1293)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1274-1331) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1295-1308)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1274-1331) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1309-1322)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1333-1390) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1339-1352)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1333-1390) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1354-1367)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderRouter.t.sol#1333-1390) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1368-1381)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderRouter.t.sol#1392-1434) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,300,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1398-1411)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderRouter.t.sol#1392-1434) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1413-1426)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderRouter.t.sol#1436-1478) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,300,300,MAX_U32) (src/test/LimitOrderRouter.t.sol#1442-1455)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderRouter.t.sol#1436-1478) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,300,500,MAX_U32) (src/test/LimitOrderRouter.t.sol#1457-1470)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1480-1537) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1486-1499)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1480-1537) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,true,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1501-1514)
LimitOrderRouterTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1480-1537) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1515-1528)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1539-1595) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1544-1557)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1539-1595) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,true,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1559-1572)
LimitOrderRouterTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderRouter.t.sol#1539-1595) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1573-1586)
LimitOrderRouterTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderRouter.t.sol#1597-1641) uses literals with too many digits:
	- order1 = newMockStoplossOrder(USDC,UNI,1,false,true,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1603-1617)
LimitOrderRouterTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderRouter.t.sol#1597-1641) uses literals with too many digits:
	- order2 = newMockStoplossOrder(USDC,UNI,1,false,true,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1619-1633)
LimitOrderRouterTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#1643-1690) uses literals with too many digits:
	- order1 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1649-1662)
LimitOrderRouterTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderRouter.t.sol#1643-1690) uses literals with too many digits:
	- order2 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1664-1677)
LimitOrderRouterTest.newMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1692-1750) uses literals with too many digits:
	- order1 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1698-1711)
LimitOrderRouterTest.newMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1692-1750) uses literals with too many digits:
	- order2 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1713-1726)
LimitOrderRouterTest.newMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1692-1750) uses literals with too many digits:
	- order3 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1728-1741)
LimitOrderRouterTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1752-1858) uses literals with too many digits:
	- order1 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1758-1771)
LimitOrderRouterTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderRouter.t.sol#1752-1858) uses literals with too many digits:
	- order2 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderRouter.t.sol#1773-1786)
LimitOrderRouterTest.slitherConstructorVariables() (src/test/LimitOrderRouter.t.sol#34-1886) uses literals with too many digits:
	- REFRESH_FEE = 20000000000000000 (src/test/LimitOrderRouter.t.sol#46)
LimitOrderRouterTest.slitherConstructorVariables() (src/test/LimitOrderRouter.t.sol#34-1886) uses literals with too many digits:
	- alphaXDivergenceThreshold = 3402823669209385000000000000000000 (src/test/LimitOrderRouter.t.sol#86)
LimitOrderRouterWrapper.slitherConstructorConstantVariables() (src/test/LimitOrderRouter.t.sol#1888-1912) uses literals with too many digits:
	- REFRESH_FEE = 20000000000000000 (src/LimitOrderRouter.sol#63)
SandboxLimitOrderBookTest.setUp() (src/test/SandboxLimitOrderBook.t.sol#84-123) uses literals with too many digits:
	- limitOrderExecutor = new LimitOrderExecutor(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,250000) (src/test/SandboxLimitOrderBook.t.sol#94-104)
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientWalletBalance(uint112) (src/test/SandboxLimitOrderBook.t.sol#459-486) uses literals with too many digits:
	- amountInRemaining = 1000000000000000000 (src/test/SandboxLimitOrderBook.t.sol#462)
SandboxLimitOrderBookTest.testFailPlaceSandboxLimitOrder_InsufficientAllowanceForOrderPlacement(uint256) (src/test/SandboxLimitOrderBook.t.sol#488-517) uses literals with too many digits:
	- amountInRemaining = 1000000000000000000 (src/test/SandboxLimitOrderBook.t.sol#491)
SandboxLimitOrderBookTest.testCancelSandboxLimitOrder(uint256) (src/test/SandboxLimitOrderBook.t.sol#519-586) uses literals with too many digits:
	- amountInRemaining = 1000000000000000000 (src/test/SandboxLimitOrderBook.t.sol#520)
SandboxLimitOrderBookTest.testUpdateSandboxOrder(uint128,uint128) (src/test/SandboxLimitOrderBook.t.sol#589-636) uses literals with too many digits:
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/SandboxLimitOrderBook.t.sol#597)
SandboxLimitOrderBookTest.testUpdateSandboxOrder(uint128,uint128) (src/test/SandboxLimitOrderBook.t.sol#589-636) uses literals with too many digits:
	- order = newSandboxLimitOrder(swapToken,WETH,10e21,1000000000000000000) (src/test/SandboxLimitOrderBook.t.sol#604-610)
SandboxLimitOrderBookTest.testValidateAndCancelOrder() (src/test/SandboxLimitOrderBook.t.sol#638-666) uses literals with too many digits:
	- IWETH(WETH).withdraw(100000) (src/test/SandboxLimitOrderBook.t.sol#654)
SandboxLimitOrderBookTest.slitherConstructorVariables() (src/test/SandboxLimitOrderBook.t.sol#43-754) uses literals with too many digits:
	- alphaXDivergenceThreshold = 3402823669209385000000000000000000000 (src/test/SandboxLimitOrderBook.t.sol#81)
SandboxLimitOrderBookTest.slitherConstructorVariables() (src/test/SandboxLimitOrderBook.t.sol#43-754) uses literals with too many digits:
	- REFRESH_FEE = 20000000000000000 (src/test/SandboxLimitOrderBook.t.sol#82)
SandboxLimitOrderBookWrapper.slitherConstructorConstantVariables() (src/test/SandboxLimitOrderBook.t.sol#756-780) uses literals with too many digits:
	- REFRESH_FEE = 20000000000000000 (src/SandboxLimitOrderBook.sol#47)
LimitOrderBookTest.setUp() (src/test/LimitOrderBook.t.sol#71-98) uses literals with too many digits:
	- limitOrderExecutor = new LimitOrderExecutor(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,250000) (src/test/LimitOrderBook.t.sol#81-91)
LimitOrderBookTest.testGetLimitOrderById() (src/test/LimitOrderBook.t.sol#101-127) uses literals with too many digits:
	- order = newOrder(swapToken,WETH,245000000000000000000,5,5) (src/test/LimitOrderBook.t.sol#107-113)
LimitOrderBookTest.testFailPlaceOrder_InsufficientWalletBalance() (src/test/LimitOrderBook.t.sol#265-284) uses literals with too many digits:
	- order = newOrder(swapToken,WETH,245000000000000000000,5,5) (src/test/LimitOrderBook.t.sol#268-274)
LimitOrderBookTest.testUpdateOrder(uint128,uint64,uint128,uint128,uint64) (src/test/LimitOrderBook.t.sol#338-386) uses literals with too many digits:
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#356)
LimitOrderBookTest.testFailUpdateOrder_InsufficientAllowanceForOrderUpdate(uint128,uint64,uint128,uint128) (src/test/LimitOrderBook.t.sol#389-415) uses literals with too many digits:
	- swapHelper.swapEthForTokenWithUniV2(100000000000000000000000000000,swapToken) (src/test/LimitOrderBook.t.sol#399)
LimitOrderBookTest.testCancelOrder() (src/test/LimitOrderBook.t.sol#447-467) uses literals with too many digits:
	- amountOut = swapHelper.swapEthForTokenWithUniV2(100000,swapToken) (src/test/LimitOrderBook.t.sol#450-453)
LimitOrderBookTest.testCancelOrders() (src/test/LimitOrderBook.t.sol#476-512) uses literals with too many digits:
	- amountOut = swapHelper.swapEthForTokenWithUniV2(100000,swapToken) (src/test/LimitOrderBook.t.sol#479-482)
LimitOrderBookTest.testGetTotalOrdersValue() (src/test/LimitOrderBook.t.sol#529-547) uses literals with too many digits:
	- order = newOrder(swapToken,WETH,245000000000000000000,5,5) (src/test/LimitOrderBook.t.sol#534-540)
LimitOrderBookTest.slitherConstructorVariables() (src/test/LimitOrderBook.t.sol#30-602) uses literals with too many digits:
	- alphaXDivergenceThreshold = 3402823669209385000000000000000000000 (src/test/LimitOrderBook.t.sol#69)
SwapRouterTest.testSwapV2_1() (src/test/SwapRouter.t.sol#522-547) uses literals with too many digits:
	- amountReceived = swapHelper.swapEthForTokenWithUniV2(10000000000000000,tokenIn) (src/test/SwapRouter.t.sol#527-530)
SwapRouterTest.testSwapV2_2() (src/test/SwapRouter.t.sol#549-574) uses literals with too many digits:
	- amountReceived = swapHelper.swapEthForTokenWithUniV2(10000000000000000,tokenIn) (src/test/SwapRouter.t.sol#554-557)
SwapRouterTest.testSwapV2_3() (src/test/SwapRouter.t.sol#576-602) uses literals with too many digits:
	- amountReceived = swapHelper.swapEthForTokenWithUniV2(10000000000000000,tokenIn) (src/test/SwapRouter.t.sol#581-584)
SwapRouterTest.testFailSwapV2_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#604-631) uses literals with too many digits:
	- amountReceived = swapHelper.swapEthForTokenWithUniV2(10000000000000000,tokenIn) (src/test/SwapRouter.t.sol#609-612)
SwapRouterTest.testFailSwapV2_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#604-631) uses literals with too many digits:
	- amountOutMin = 10000000000000000 (src/test/SwapRouter.t.sol#617)
SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664) uses literals with too many digits:
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SwapRouter.t.sol#640-642)
SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664) uses literals with too many digits:
	- IERC20(tokenIn).approve(address(limitOrderExecutor),1000000000000000000) (src/test/SwapRouter.t.sol#644-647)
SwapRouterTest.testSwapV3_1() (src/test/SwapRouter.t.sol#634-664) uses literals with too many digits:
	- limitOrderExecutor.swapV3(_lp,tokenIn,tokenOut,500,1000000000000000000,1,receiver,address(this)) (src/test/SwapRouter.t.sol#654-663)
SwapRouterTest.testSwap() (src/test/SwapRouter.t.sol#694-723) uses literals with too many digits:
	- amountReceived = swapHelper.swapEthForTokenWithUniV2(1000000000000000,tokenIn) (src/test/SwapRouter.t.sol#699-702)
SwapRouterTest.testFailSwap_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#725-755) uses literals with too many digits:
	- amountReceived = swapHelper.swapEthForTokenWithUniV2(1000000000000000,tokenIn) (src/test/SwapRouter.t.sol#730-733)
SwapRouterTest.testFailSwap_InsufficientOutputAmount() (src/test/SwapRouter.t.sol#725-755) uses literals with too many digits:
	- amountOut = limitOrderExecutor.swap(tokenIn,tokenOut,lp,300,amountReceived,1000000000000000,receiver,address(this)) (src/test/SwapRouter.t.sol#743-752)
SwapRouterTest.slitherConstructorVariables() (src/test/SwapRouter.t.sol#39-758) uses literals with too many digits:
	- alphaXDivergenceThreshold = 3402823669209385000000000000000000 (src/test/SwapRouter.t.sol#84)
LimitOrderSwapRouter.calculateFee(uint128,address,address) (src/LimitOrderSwapRouter.sol#184-251) uses literals with too many digits:
	- amountInUSDCDollarValue >= 1000000 (src/LimitOrderSwapRouter.sol#212)
LimitOrderSwapRouter.calculateFee(uint128,address,address) (src/LimitOrderSwapRouter.sol#184-251) uses literals with too many digits:
	- exponent >= 0x400000000000000000 (src/LimitOrderSwapRouter.sol#225)
LimitOrderSwapRouter._lpIsNotUniV3(address) (src/LimitOrderSwapRouter.sol#695-717) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,0xddca3f4300000000000000000000000000000000000000000000000000000000) (src/LimitOrderSwapRouter.sol#699-702)
LimitOrderExecutorWrapper.slitherConstructorConstantVariables() (src/test/SwapRouter.t.sol#761-866) uses literals with too many digits:
	- Q96 = 0x1000000000000000000000000 (src/lib/ConveyorTickMath.sol#33)
LimitOrderQuoterTest.testFindBestTokenToTokenExecutionPrice() (src/test/LimitOrderQuoter.t.sol#126-169) uses literals with too many digits:
	- tokenToTokenExecutionPrice = LimitOrderSwapRouter.TokenToTokenExecutionPrice(8014835235973799779324680,4595913824638810919416,1414776373420924126438282,7545889283955278550784,36584244663945024000000000000000000000,0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11,0xd3d2E2692501A5c9Ca623199D38826e513033a17) (src/test/LimitOrderQuoter.t.sol#131-141)
LimitOrderQuoterTest.testFindBestTokenToTokenExecutionPrice() (src/test/LimitOrderQuoter.t.sol#126-169) uses literals with too many digits:
	- tokenToTokenExecutionPrice1 = LimitOrderSwapRouter.TokenToTokenExecutionPrice(8014835235973799779324680,4595913824638810919416,1414776373420924126438282,7545889283955278550784,36584244663945024000000000000000000001,0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11,0xd3d2E2692501A5c9Ca623199D38826e513033a17) (src/test/LimitOrderQuoter.t.sol#143-153)
LimitOrderQuoterTest.testSimulateWethToBPriceChangeV2() (src/test/LimitOrderQuoter.t.sol#333-356) uses literals with too many digits:
	- (newSpotPriceB) = limitOrderQuoter.simulateWethToBPriceChange(5000000000000000000,tokenToTokenExecutionPrice) (src/test/LimitOrderQuoter.t.sol#350-354)
LimitOrderQuoterTest.testSimulateAToWethPriceChangeV2() (src/test/LimitOrderQuoter.t.sol#360-384) uses literals with too many digits:
	- (newSpotPriceA,amountOut) = limitOrderQuoter.simulateAToWethPriceChange(50000000000000000000000,tokenToTokenExecutionPrice) (src/test/LimitOrderQuoter.t.sol#377-381)
LimitOrderQuoterTest.slitherConstructorVariables() (src/test/LimitOrderQuoter.t.sol#39-418) uses literals with too many digits:
	- alphaXDivergenceThreshold = 3402823669209385000000000000000000 (src/test/LimitOrderQuoter.t.sol#105)
LimitOrderQuoter._lpIsNotUniV3(address) (src/LimitOrderQuoter.sol#23-45) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,0xddca3f4300000000000000000000000000000000000000000000000000000000) (src/LimitOrderQuoter.sol#27-30)
ExecutionWrapper.slitherConstructorConstantVariables() (src/test/LimitOrderQuoter.t.sol#420-476) uses literals with too many digits:
	- Q96 = 0x1000000000000000000000000 (src/lib/ConveyorTickMath.sol#33)
LimitOrderExecutorTest.setUp() (src/test/LimitOrderExecutor.t.sol#89-128) uses literals with too many digits:
	- limitOrderExecutor = new LimitOrderExecutorWrapper(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,250000) (src/test/LimitOrderExecutor.t.sol#99-109)
LimitOrderExecutorTest.setUp() (src/test/LimitOrderExecutor.t.sol#89-128) uses literals with too many digits:
	- limitOrderRouterWrapper = new LimitOrderRouter(aggregatorV3Address,0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderExecutor),300000) (src/test/LimitOrderExecutor.t.sol#119-125)
LimitOrderExecutorTest.testMinGasCredits() (src/test/LimitOrderExecutor.t.sol#131-167) uses literals with too many digits:
	- order = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#139-152)
LimitOrderExecutorTest.testMinGasCredits() (src/test/LimitOrderExecutor.t.sol#131-167) uses literals with too many digits:
	- hasMinGasCredits = limitOrderExecutor.hasMinGasCredits(50000000000,address(this),type()(uint128).max,150) (src/test/LimitOrderExecutor.t.sol#159-164)
LimitOrderExecutorTest.testFailMinGasCredits() (src/test/LimitOrderExecutor.t.sol#169-205) uses literals with too many digits:
	- order = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#177-190)
LimitOrderExecutorTest.testFailMinGasCredits() (src/test/LimitOrderExecutor.t.sol#169-205) uses literals with too many digits:
	- hasMinGasCredits = limitOrderExecutor.hasMinGasCredits(50000000000,address(this),1,150) (src/test/LimitOrderExecutor.t.sol#197-202)
LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271) uses literals with too many digits:
	- order = newOrder(swapToken,WETH,245000000000000000000,5,5) (src/test/LimitOrderExecutor.t.sol#214-220)
LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271) uses literals with too many digits:
	- order1 = newOrder(swapToken,WETH,245000000000000000000,5,5) (src/test/LimitOrderExecutor.t.sol#223-229)
LimitOrderExecutorTest.testCalculateMinGasCredits(uint128) (src/test/LimitOrderExecutor.t.sol#208-271) uses literals with too many digits:
	- executionCost = 300000 (src/test/LimitOrderExecutor.t.sol#242)
LimitOrderExecutorTest.testExecuteWethToTokenSingle() (src/test/LimitOrderExecutor.t.sol#332-382) uses literals with too many digits:
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#337-339)
LimitOrderExecutorTest.testExecuteWethToTokenSingle() (src/test/LimitOrderExecutor.t.sol#332-382) uses literals with too many digits:
	- order = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#345-358)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) uses literals with too many digits:
	- amountIn < 1000000000000000000 (src/test/LimitOrderExecutor.t.sol#387)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) uses literals with too many digits:
	- _95_PERCENT = 970000000000000000 (src/test/LimitOrderExecutor.t.sol#407)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) uses literals with too many digits:
	- order = newMockOrder(DAI,WETH,1,false,false,0,amountOutMin,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#417-430)
LimitOrderExecutorTest.testExecuteTokenToWethSingle(uint112) (src/test/LimitOrderExecutor.t.sol#385-501) uses literals with too many digits:
	- executionCostUpper = 300000 (src/test/LimitOrderExecutor.t.sol#457)
LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559) uses literals with too many digits:
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#512-514)
LimitOrderExecutorTest.testExecuteWethToTokenOrderBatch() (src/test/LimitOrderExecutor.t.sol#504-559) uses literals with too many digits:
	- IERC20(WETH).approve(address(limitOrderExecutor),5000000000000000000000000000) (src/test/LimitOrderExecutor.t.sol#519)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) uses literals with too many digits:
	- amountIn < 1000000000000000000 (src/test/LimitOrderExecutor.t.sol#564)
LimitOrderExecutorTest.testExecuteTokenToTokenSingle(uint80) (src/test/LimitOrderExecutor.t.sol#562-680) uses literals with too many digits:
	- _95_PERCENT = 970000000000000000 (src/test/LimitOrderExecutor.t.sol#583)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) uses literals with too many digits:
	- amountIn < 1000000000000000000 (src/test/LimitOrderExecutor.t.sol#735)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenSingle(uint112) (src/test/LimitOrderExecutor.t.sol#733-849) uses literals with too many digits:
	- _95_PERCENT = 970000000000000000 (src/test/LimitOrderExecutor.t.sol#759)
LimitOrderExecutorTest.testExecuteWethToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#852-903) uses literals with too many digits:
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/LimitOrderExecutor.t.sol#857-859)
LimitOrderExecutorTest.testExecuteTaxedTokenToWethSingle() (src/test/LimitOrderExecutor.t.sol#906-977) uses literals with too many digits:
	- order = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#915-928)
LimitOrderExecutorTest.testExecuteTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1028-1091) uses literals with too many digits:
	- order = newMockOrder(DAI,TAXED_TOKEN,1,false,true,0,1,20000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1035-1048)
LimitOrderExecutorTest.testExecuteTaxedTokenToTokenSingle() (src/test/LimitOrderExecutor.t.sol#1094-1159) uses literals with too many digits:
	- order = newMockOrder(TAXED_TOKEN,DAI,1,false,true,4000,1,20000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1102-1115)
LimitOrderExecutorTest.testExecuteTaxedTokenToTaxedTokenSingle() (src/test/LimitOrderExecutor.t.sol#1258-1323) uses literals with too many digits:
	- order = newMockOrder(TAXED_TOKEN,TAXED_TOKEN_1,1,false,true,3000,1,2000000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1266-1279)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#1547-1617) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000000,3000,300,500,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1553-1566)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#1547-1617) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000001,3000,300,500,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1568-1581)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#1547-1617) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000002,3000,300,500,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1582-1595)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch() (src/test/LimitOrderExecutor.t.sol#1547-1617) uses literals with too many digits:
	- order4 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000003,3000,300,500,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1596-1609)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#1619-1696) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1625-1638)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#1619-1696) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000001,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1640-1653)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#1619-1696) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000002,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1654-1667)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#1619-1696) uses literals with too many digits:
	- order4 = newMockOrder(DAI,WETH,1,false,false,0,1000000000000000000,5000000000000000000003,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1668-1681)
LimitOrderExecutorTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#1698-1769) uses literals with too many digits:
	- order1 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1704-1717)
LimitOrderExecutorTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#1698-1769) uses literals with too many digits:
	- order2 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1719-1732)
LimitOrderExecutorTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#1698-1769) uses literals with too many digits:
	- order3 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1733-1746)
LimitOrderExecutorTest.placeNewMockTokenToWethTaxedBatch() (src/test/LimitOrderExecutor.t.sol#1698-1769) uses literals with too many digits:
	- order4 = newMockOrder(TAXED_TOKEN,WETH,1,false,true,4000,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1747-1760)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1771-1828) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1777-1790)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1771-1828) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000003,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1792-1805)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1771-1828) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1806-1819)
LimitOrderExecutorTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1830-1887) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1836-1849)
LimitOrderExecutorTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1830-1887) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000003,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1851-1864)
LimitOrderExecutorTest.newMockTokenToWethBatch_InvalidBatchOrdering() (src/test/LimitOrderExecutor.t.sol#1830-1887) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1865-1878)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1896-1909)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) uses literals with too many digits:
	- order2 = newMockOrder(USDC,WETH,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1911-1924)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#1889-1953) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1925-1938)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) uses literals with too many digits:
	- order1 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1962-1976)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) uses literals with too many digits:
	- order2 = newMockStoplossOrder(USDC,WETH,1,false,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1978-1992)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentStoploss() (src/test/LimitOrderExecutor.t.sol#1955-2015) uses literals with too many digits:
	- order3 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#1993-2007)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderExecutor.t.sol#2017-2082) uses literals with too many digits:
	- order1 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2024-2038)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderExecutor.t.sol#2017-2082) uses literals with too many digits:
	- order2 = newMockStoplossOrder(USDC,WETH,1,false,true,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2040-2054)
LimitOrderExecutorTest.placeNewMockTokenToWethBatchStoploss() (src/test/LimitOrderExecutor.t.sol#2017-2082) uses literals with too many digits:
	- order3 = newMockStoplossOrder(DAI,WETH,1,false,true,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2055-2069)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2091-2104)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) uses literals with too many digits:
	- order2 = newMockOrder(USDC,WETH,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2106-2119)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenIn() (src/test/LimitOrderExecutor.t.sol#2084-2142) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2120-2133)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2144-2201) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2150-2163)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2144-2201) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,true,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2165-2178)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2144-2201) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2179-2192)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2203-2260) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2209-2222)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2203-2260) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,false,true,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2224-2237)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTaxedTokenInBatch() (src/test/LimitOrderExecutor.t.sol#2203-2260) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2238-2251)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2262-2319) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2268-2281)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2262-2319) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2283-2296)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2262-2319) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2297-2310)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2321-2378) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2327-2340)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2321-2378) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2342-2355)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentTokenOut() (src/test/LimitOrderExecutor.t.sol#2321-2378) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2356-2369)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderExecutor.t.sol#2380-2422) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,300,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2386-2399)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeIn() (src/test/LimitOrderExecutor.t.sol#2380-2422) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2401-2414)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderExecutor.t.sol#2424-2466) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,300,300,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2430-2443)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentFeeOut() (src/test/LimitOrderExecutor.t.sol#2424-2466) uses literals with too many digits:
	- order2 = newMockOrder(DAI,USDC,1,false,false,0,1,5000000000000000000001,3000,300,500,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2445-2458)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2468-2525) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2474-2487)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2468-2525) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,true,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2489-2502)
LimitOrderExecutorTest.placeNewMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2468-2525) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2503-2516)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2527-2583) uses literals with too many digits:
	- order1 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2532-2545)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2527-2583) uses literals with too many digits:
	- order2 = newMockOrder(DAI,WETH,1,true,false,0,1,5000000000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2547-2560)
LimitOrderExecutorTest.newMockTokenToWethBatch_IncongruentBuySellStatus() (src/test/LimitOrderExecutor.t.sol#2527-2583) uses literals with too many digits:
	- order3 = newMockOrder(DAI,WETH,1,false,false,0,1,5000000000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2561-2574)
LimitOrderExecutorTest.placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2585-2684) uses literals with too many digits:
	- order1 = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2589-2602)
LimitOrderExecutorTest.placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2585-2684) uses literals with too many digits:
	- order2 = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2604-2617)
LimitOrderExecutorTest.placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2585-2684) uses literals with too many digits:
	- order3 = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2618-2631)
LimitOrderExecutorTest.placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2585-2684) uses literals with too many digits:
	- order4 = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2632-2645)
LimitOrderExecutorTest.placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2585-2684) uses literals with too many digits:
	- order5 = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2646-2659)
LimitOrderExecutorTest.placeNewMockWethToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2585-2684) uses literals with too many digits:
	- order6 = newMockOrder(WETH,DAI,1,false,false,0,1,5000000000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2660-2673)
LimitOrderExecutorTest.placeNewMockWethToTaxedBatch() (src/test/LimitOrderExecutor.t.sol#2686-2741) uses literals with too many digits:
	- order = newMockOrder(WETH,TAXED_TOKEN,1,false,true,0,1,20000000000000000,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2690-2703)
LimitOrderExecutorTest.placeNewMockWethToTaxedBatch() (src/test/LimitOrderExecutor.t.sol#2686-2741) uses literals with too many digits:
	- order1 = newMockOrder(WETH,TAXED_TOKEN,1,false,true,0,1,20000000000000001,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2705-2718)
LimitOrderExecutorTest.placeNewMockWethToTaxedBatch() (src/test/LimitOrderExecutor.t.sol#2686-2741) uses literals with too many digits:
	- order2 = newMockOrder(WETH,TAXED_TOKEN,1,false,true,0,1,20000000000000002,3000,0,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2719-2732)
LimitOrderExecutorTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2743-2849) uses literals with too many digits:
	- order1 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2749-2762)
LimitOrderExecutorTest.placeNewMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2743-2849) uses literals with too many digits:
	- order2 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2764-2777)
LimitOrderExecutorTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderExecutor.t.sol#2851-2895) uses literals with too many digits:
	- order1 = newMockStoplossOrder(USDC,UNI,1,false,true,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2857-2871)
LimitOrderExecutorTest.placeNewMockTokenToTokenStoplossBatch() (src/test/LimitOrderExecutor.t.sol#2851-2895) uses literals with too many digits:
	- order2 = newMockStoplossOrder(USDC,UNI,1,false,true,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2873-2887)
LimitOrderExecutorTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#2897-2944) uses literals with too many digits:
	- order1 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2903-2916)
LimitOrderExecutorTest.placeNewMockTokenToTokenBatchDuplicateOrderIds() (src/test/LimitOrderExecutor.t.sol#2897-2944) uses literals with too many digits:
	- order2 = newMockOrder(USDC,UNI,1,false,false,0,1,5000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2918-2931)
LimitOrderExecutorTest.placeNewMockTaxedToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2946-3002) uses literals with too many digits:
	- order = newMockOrder(TAXED_TOKEN,DAI,1,false,true,9000,1,2000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2950-2963)
LimitOrderExecutorTest.placeNewMockTaxedToTokenBatch() (src/test/LimitOrderExecutor.t.sol#2946-3002) uses literals with too many digits:
	- order1 = newMockOrder(TAXED_TOKEN,DAI,1,false,true,9000,1,2000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#2965-2978)
LimitOrderExecutorTest.placeNewMockTaxedToTaxedTokenBatch() (src/test/LimitOrderExecutor.t.sol#3004-3028) uses literals with too many digits:
	- order = newMockOrder(TAXED_TOKEN,TAXED_TOKEN_1,1,false,true,9000,1,2000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#3008-3021)
LimitOrderExecutorTest.newMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#3030-3088) uses literals with too many digits:
	- order1 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#3036-3049)
LimitOrderExecutorTest.newMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#3030-3088) uses literals with too many digits:
	- order2 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#3051-3064)
LimitOrderExecutorTest.newMockTokenToTokenBatch() (src/test/LimitOrderExecutor.t.sol#3030-3088) uses literals with too many digits:
	- order3 = newMockOrder(DAI,UNI,1,false,false,0,1,5000000000000000000000,3000,3000,0,MAX_U32) (src/test/LimitOrderExecutor.t.sol#3066-3079)
LimitOrderExecutorTest.slitherConstructorVariables() (src/test/LimitOrderExecutor.t.sol#32-3116) uses literals with too many digits:
	- alphaXDivergenceThreshold = 3402823669209385000000000000000000 (src/test/LimitOrderExecutor.t.sol#85)
LimitOrderExecutorWrapper.slitherConstructorConstantVariables() (src/test/LimitOrderExecutor.t.sol#3119-3265) uses literals with too many digits:
	- STOP_LOSS_MAX_BEACON_REWARD = 50000000000000000 (src/LimitOrderExecutor.sol#34)
ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneFalse(uint64) (src/test/ConveyorTickMath.t.sol#111-155) uses literals with too many digits:
	- _alphaX < 10000000000000000 (src/test/ConveyorTickMath.t.sol#116)
ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96__ZeroForOneTrue(uint72) (src/test/ConveyorTickMath.t.sol#159-199) uses literals with too many digits:
	- _alphaX < 100000000000000000000 (src/test/ConveyorTickMath.t.sol#164)
ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96CrossTick(uint112) (src/test/ConveyorTickMath.t.sol#203-252) uses literals with too many digits:
	- MAX_INPUT = 100000000000000000000 (src/test/ConveyorTickMath.t.sol#209)
ConveyorTickMathTest.testSimulateAmountOutOnSqrtPriceX96CrossTick(uint112) (src/test/ConveyorTickMath.t.sol#203-252) uses literals with too many digits:
	- _alphaX == 0 || _alphaX > MAX_INPUT || _alphaX < 100000000000000000000 (src/test/ConveyorTickMath.t.sol#212-214)
ConveyorTickMathWrapper.slitherConstructorConstantVariables() (src/test/ConveyorTickMath.t.sol#286-316) uses literals with too many digits:
	- Q96 = 0x1000000000000000000000000 (src/lib/ConveyorTickMath.sol#33)
SwapRouterWrapper.slitherConstructorConstantVariables() (src/test/ConveyorTickMath.t.sol#318-347) uses literals with too many digits:
	- Q96 = 0x1000000000000000000000000 (src/lib/ConveyorTickMath.sol#33)
ConveyorSwapAggregatorTest.testSwapUniv2SingleLP() (src/test/ConveyorSwapAggregator.t.sol#54-88) uses literals with too many digits:
	- amountIn = 1900000000000000000000 (src/test/ConveyorSwapAggregator.t.sol#59)
ConveyorSwapAggregatorTest.testSwapUniv2MultiLP() (src/test/ConveyorSwapAggregator.t.sol#90-131) uses literals with too many digits:
	- amountIn = 825000000 (src/test/ConveyorSwapAggregator.t.sol#95)
ConveyorSwapAggregatorTest.testSwapUniv3SingleLP() (src/test/ConveyorSwapAggregator.t.sol#133-188) uses literals with too many digits:
	- amountIn = 5678000000000000000000 (src/test/ConveyorSwapAggregator.t.sol#136)
ConveyorSwapAggregatorTest.testSwapUniv3SingleLP() (src/test/ConveyorSwapAggregator.t.sol#133-188) uses literals with too many digits:
	- (depositSuccess) = address(tokenOut).call{value: 500000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/ConveyorSwapAggregator.t.sol#142-144)
SandboxLimitOrderRouterTest.setUp() (src/test/SandboxLimitOrderRouter.t.sol#114-205) uses literals with too many digits:
	- limitOrderExecutor = new LimitOrderExecutorWrapper(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,address(limitOrderQuoter),_hexDems,_dexFactories,_isUniV2,aggregatorV3Address,300000,SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST) (src/test/SandboxLimitOrderRouter.t.sol#124-134)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329) uses literals with too many digits:
	- order = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#227-233)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV2() (src/test/SandboxLimitOrderRouter.t.sol#214-329) uses literals with too many digits:
	- calls[0] = newUniV2Call(daiWethV2,0,10000000000000000,address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#263-268)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454) uses literals with too many digits:
	- order = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#346-353)
SandboxLimitOrderRouterTest.testExecuteMulticallOrderSingleV3() (src/test/SandboxLimitOrderRouter.t.sol#332-454) uses literals with too many digits:
	- calls[0] = newUniV3Call(daiWethV3,address(sandboxRouter),address(sandboxRouter),true,100000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#381-388)
SandboxLimitOrderRouterTest.testExecuteMulticallOrdersSameOwnerBundleInputToken() (src/test/SandboxLimitOrderRouter.t.sol#541-679) uses literals with too many digits:
	- calls[0] = newUniV3Call(daiWethV3,address(sandboxRouter),address(sandboxRouter),true,200000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#593-600)
SandboxLimitOrderRouterTest.createMockOrdersSameInputToken() (src/test/SandboxLimitOrderRouter.t.sol#681-710) uses literals with too many digits:
	- order0 = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#688-695)
SandboxLimitOrderRouterTest.createMockOrdersSameInputToken() (src/test/SandboxLimitOrderRouter.t.sol#681-710) uses literals with too many digits:
	- order1 = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#698-705)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_FillAmountSpecifiedGreaterThanAmountRemaining() (src/test/SandboxLimitOrderRouter.t.sol#726-794) uses literals with too many digits:
	- order = newMockSandboxOrder(false,10000000000000000000,1,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#741-748)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_SandboxAmountOutRequiredNotSatisfied() (src/test/SandboxLimitOrderRouter.t.sol#796-865) uses literals with too many digits:
	- order = newMockSandboxOrder(false,10000000000000000000,100000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#811-818)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_ConveyorFeesNotPaid() (src/test/SandboxLimitOrderRouter.t.sol#867-934) uses literals with too many digits:
	- order = newMockSandboxOrder(false,10000000000000000000,1,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#880-887)
SandboxLimitOrderRouterTest.testFailExecuteMulticallOrder_InvalidTransferAddressArray() (src/test/SandboxLimitOrderRouter.t.sol#936-1006) uses literals with too many digits:
	- order = newMockSandboxOrder(false,10000000000000000000,1,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#951-958)
SandboxLimitOrderRouterTest.testInitializeSandboxExecutionState(uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1012-1101) uses literals with too many digits:
	- run = minWethQuantity < wethQuantity & wethQuantity < 10000000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1019-1022)
SandboxLimitOrderRouterTest.testValidateSandboxExecutionAndFillOrders(uint128,uint128,uint128,uint128,uint128) (src/test/SandboxLimitOrderRouter.t.sol#1103-1176) uses literals with too many digits:
	- wethQuantity < 1000000000000000 || daiQuantity < 1000000000000000 || wethQuantity > 10000000000000000000000 || daiQuantity > 10000000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1113-1116)
SandboxLimitOrderRouterTest.dealSandboxRouterExecutionFee() (src/test/SandboxLimitOrderRouter.t.sol#1442-1451) uses literals with too many digits:
	- (depositSuccess) = address(WETH).call{value: 500000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1447-1449)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[0] = 120000000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1479)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[1] = 120000000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1481)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[2] = 5000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1483)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[3] = 100000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1485)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[4] = 5000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1487)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[5] = 2000000000 (src/test/SandboxLimitOrderRouter.t.sol#1489)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[6] = 10000000000 (src/test/SandboxLimitOrderRouter.t.sol#1491)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[7] = 10000000000 (src/test/SandboxLimitOrderRouter.t.sol#1493)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[8] = 100000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1495)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- fillAmounts[9] = 100000000000000000000 (src/test/SandboxLimitOrderRouter.t.sol#1497)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- calls[0] = newUniV3Call(daiWethV3,address(sandboxRouter),address(sandboxRouter),true,110000000000000000000,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1519-1526)
SandboxLimitOrderRouterTest.createSandboxCallMultiOrderMulticall() (src/test/SandboxLimitOrderRouter.t.sol#1453-1646) uses literals with too many digits:
	- calls[1] = newUniV2Call(usdcWethV2,0,30000000000000000,address(sandboxRouter)) (src/test/SandboxLimitOrderRouter.t.sol#1527-1532)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order1 = newMockSandboxOrder(false,120000000000000000000000,100000000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1859-1866)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order2 = newMockSandboxOrder(false,120000000000000000000000,100000000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1873-1880)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order3 = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1887-1894)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order4 = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1901-1908)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order5 = newMockSandboxOrder(false,100000000000000000000,10000000000000000,DAI,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1915-1922)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order6 = newMockSandboxOrder(false,10000000000,10000000000000000,USDC,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1930-1937)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order7 = newMockSandboxOrder(false,10000000000,10000000000000000,USDC,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1944-1951)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order8 = newMockSandboxOrder(false,10000000000,10000000000000000,USDC,WETH) (src/test/SandboxLimitOrderRouter.t.sol#1960-1967)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- cheatCodes.deal(address(mockOwner9),1000000000000000000000000) (src/test/SandboxLimitOrderRouter.t.sol#1968)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- (success) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1975-1977)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order9 = newMockSandboxOrder(true,100000000000000000000,120000000000000000000000,WETH,DAI) (src/test/SandboxLimitOrderRouter.t.sol#1982-1989)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- cheatCodes.deal(address(mockOwner10),1000000000000000000000000) (src/test/SandboxLimitOrderRouter.t.sol#1990)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- (depositSuccess) = address(WETH).call{value: 1000000000000000000000000}(abi.encodeWithSignature(deposit())) (src/test/SandboxLimitOrderRouter.t.sol#1997-1999)
SandboxLimitOrderRouterTest.placeNewMockMultiOrderMultiCall() (src/test/SandboxLimitOrderRouter.t.sol#1848-2035) uses literals with too many digits:
	- order10 = newMockSandboxOrder(true,100000000000000000000,120000000000000000000000,WETH,DAI) (src/test/SandboxLimitOrderRouter.t.sol#2004-2011)
FixedPoint96.slitherConstructorConstantVariables() (lib/libraries/Uniswap/FixedPoint96.sol#7-11) uses literals with too many digits:
	- Q96 = 0x1000000000000000000000000 (lib/libraries/Uniswap/FixedPoint96.sol#9)
ConveyorMath.divuu(uint256,uint256) (src/lib/ConveyorMath.sol#232-294) uses literals with too many digits:
	- xc >= 0x100000000 (src/lib/ConveyorMath.sol#243)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- require(bool)(x < 0x400000000000000000) (src/lib/ConveyorMath.sol#308)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = 0x80000000000000000000000000000000 (src/lib/ConveyorMath.sol#310)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x8000000000000000 > 0 (src/lib/ConveyorMath.sol#312)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x4000000000000000 > 0 (src/lib/ConveyorMath.sol#314)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x2000000000000000 > 0 (src/lib/ConveyorMath.sol#316)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x1000000000000000 > 0 (src/lib/ConveyorMath.sol#318)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x800000000000000 > 0 (src/lib/ConveyorMath.sol#320)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x400000000000000 > 0 (src/lib/ConveyorMath.sol#322)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x200000000000000 > 0 (src/lib/ConveyorMath.sol#324)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x100000000000000 > 0 (src/lib/ConveyorMath.sol#326)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x80000000000000 > 0 (src/lib/ConveyorMath.sol#328)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x40000000000000 > 0 (src/lib/ConveyorMath.sol#330)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x20000000000000 > 0 (src/lib/ConveyorMath.sol#332)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x10000000000000 > 0 (src/lib/ConveyorMath.sol#334)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x8000000000000 > 0 (src/lib/ConveyorMath.sol#336)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x4000000000000 > 0 (src/lib/ConveyorMath.sol#338)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x2000000000000 > 0 (src/lib/ConveyorMath.sol#340)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x1000000000000 > 0 (src/lib/ConveyorMath.sol#342)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x800000000000 > 0 (src/lib/ConveyorMath.sol#344)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x400000000000 > 0 (src/lib/ConveyorMath.sol#346)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x200000000000 > 0 (src/lib/ConveyorMath.sol#348)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x100000000000 > 0 (src/lib/ConveyorMath.sol#350)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000B1721BCFC99D9F890EA06911763) >> 128 (src/lib/ConveyorMath.sol#351)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x80000000000 > 0 (src/lib/ConveyorMath.sol#352)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128 (src/lib/ConveyorMath.sol#353)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x40000000000 > 0 (src/lib/ConveyorMath.sol#354)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128 (src/lib/ConveyorMath.sol#355)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x20000000000 > 0 (src/lib/ConveyorMath.sol#356)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000162E430E5A18F6119E3C02282A5) >> 128 (src/lib/ConveyorMath.sol#357)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x10000000000 > 0 (src/lib/ConveyorMath.sol#358)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128 (src/lib/ConveyorMath.sol#359)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x8000000000 > 0 (src/lib/ConveyorMath.sol#360)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128 (src/lib/ConveyorMath.sol#361)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x4000000000 > 0 (src/lib/ConveyorMath.sol#362)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000002C5C8601CC6B9E94213C72737A) >> 128 (src/lib/ConveyorMath.sol#363)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x2000000000 > 0 (src/lib/ConveyorMath.sol#364)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000162E42FFF037DF38AA2B219F06) >> 128 (src/lib/ConveyorMath.sol#365)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x1000000000 > 0 (src/lib/ConveyorMath.sol#366)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000B17217FBA9C739AA5819F44F9) >> 128 (src/lib/ConveyorMath.sol#367)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x800000000 > 0 (src/lib/ConveyorMath.sol#368)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128 (src/lib/ConveyorMath.sol#369)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x400000000 > 0 (src/lib/ConveyorMath.sol#370)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128 (src/lib/ConveyorMath.sol#371)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x200000000 > 0 (src/lib/ConveyorMath.sol#372)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128 (src/lib/ConveyorMath.sol#373)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x100000000 > 0 (src/lib/ConveyorMath.sol#374)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000B17217F80F4EF5AADDA45554) >> 128 (src/lib/ConveyorMath.sol#375)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x80000000 > 0 (src/lib/ConveyorMath.sol#376)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128 (src/lib/ConveyorMath.sol#377)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x40000000 > 0 (src/lib/ConveyorMath.sol#378)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128 (src/lib/ConveyorMath.sol#379)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x20000000 > 0 (src/lib/ConveyorMath.sol#380)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000162E42FEFB2FED257559BDAA) >> 128 (src/lib/ConveyorMath.sol#381)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x10000000 > 0 (src/lib/ConveyorMath.sol#382)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128 (src/lib/ConveyorMath.sol#383)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x8000000 > 0 (src/lib/ConveyorMath.sol#384)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128 (src/lib/ConveyorMath.sol#385)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x4000000 > 0 (src/lib/ConveyorMath.sol#386)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128 (src/lib/ConveyorMath.sol#387)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x2000000 > 0 (src/lib/ConveyorMath.sol#388)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000162E42FEFA494F1478FDE05) >> 128 (src/lib/ConveyorMath.sol#389)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x1000000 > 0 (src/lib/ConveyorMath.sol#390)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000B17217F7D20CF927C8E94C) >> 128 (src/lib/ConveyorMath.sol#391)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x800000 > 0 (src/lib/ConveyorMath.sol#392)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128 (src/lib/ConveyorMath.sol#393)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x400000 > 0 (src/lib/ConveyorMath.sol#394)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000002C5C85FDF477B662B26945) >> 128 (src/lib/ConveyorMath.sol#395)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x200000 > 0 (src/lib/ConveyorMath.sol#396)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000162E42FEFA3AE53369388C) >> 128 (src/lib/ConveyorMath.sol#397)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- x & 0x100000 > 0 (src/lib/ConveyorMath.sol#398)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000B17217F7D1D351A389D40) >> 128 (src/lib/ConveyorMath.sol#399)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128 (src/lib/ConveyorMath.sol#401)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128 (src/lib/ConveyorMath.sol#403)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000162E42FEFA39FE95583C2) >> 128 (src/lib/ConveyorMath.sol#405)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000000B17217F7D1CFB72B45E1) >> 128 (src/lib/ConveyorMath.sol#407)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128 (src/lib/ConveyorMath.sol#409)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000002C5C85FDF473E242EA38) >> 128 (src/lib/ConveyorMath.sol#411)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000000162E42FEFA39F02B772C) >> 128 (src/lib/ConveyorMath.sol#413)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000000B17217F7D1CF7D83C1A) >> 128 (src/lib/ConveyorMath.sol#415)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128 (src/lib/ConveyorMath.sol#417)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000002C5C85FDF473DEA871F) >> 128 (src/lib/ConveyorMath.sol#419)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000000162E42FEFA39EF44D91) >> 128 (src/lib/ConveyorMath.sol#421)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000000B17217F7D1CF79E949) >> 128 (src/lib/ConveyorMath.sol#423)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000000058B90BFBE8E7BCE544) >> 128 (src/lib/ConveyorMath.sol#425)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000000002C5C85FDF473DE6ECA) >> 128 (src/lib/ConveyorMath.sol#427)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000000162E42FEFA39EF366F) >> 128 (src/lib/ConveyorMath.sol#429)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000000000B17217F7D1CF79AFA) >> 128 (src/lib/ConveyorMath.sol#431)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x100000000000000058B90BFBE8E7BCD6D) >> 128 (src/lib/ConveyorMath.sol#433)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000000002C5C85FDF473DE6B2) >> 128 (src/lib/ConveyorMath.sol#435)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x1000000000000000162E42FEFA39EF358) >> 128 (src/lib/ConveyorMath.sol#437)
ConveyorMath.exp_2(uint128) (src/lib/ConveyorMath.sol#306-446) uses literals with too many digits:
	- answer = (answer * 0x10000000000000000B17217F7D1CF79AB) >> 128 (src/lib/ConveyorMath.sol#439)
ConveyorMath.exp(uint128) (src/lib/ConveyorMath.sol#451-463) uses literals with too many digits:
	- require(bool,string)(x < 0x400000000000000000,Exponential overflow) (src/lib/ConveyorMath.sol#453)
ConveyorMath.sqrtu(uint256) (src/lib/ConveyorMath.sol#468-512) uses literals with too many digits:
	- xx >= 0x100000000000000000000000000000000 (src/lib/ConveyorMath.sol#474)
ConveyorMath.sqrtu(uint256) (src/lib/ConveyorMath.sol#468-512) uses literals with too many digits:
	- xx >= 0x10000000000000000 (src/lib/ConveyorMath.sol#478)
ConveyorMath.sqrtu(uint256) (src/lib/ConveyorMath.sol#468-512) uses literals with too many digits:
	- xx >= 0x100000000 (src/lib/ConveyorMath.sol#482)
ConveyorMath.slitherConstructorConstantVariables() (src/lib/ConveyorMath.sol#6-513) uses literals with too many digits:
	- MIN_64x64 = - 0x80000000000000000000000000000000 (src/lib/ConveyorMath.sol#13)
QuadruplePrecision.fromInt(int256) (lib/libraries/QuadruplePrecision.sol#31-50) uses literals with too many digits:
	- result |= 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#45)
QuadruplePrecision.toUInt(bytes16) (lib/libraries/QuadruplePrecision.sol#52-70) uses literals with too many digits:
	- require(bool)(uint128(x) < 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#58)
QuadruplePrecision.toUInt(bytes16) (lib/libraries/QuadruplePrecision.sol#52-70) uses literals with too many digits:
	- result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#61-63)
QuadruplePrecision.from128x128(int256) (lib/libraries/QuadruplePrecision.sol#91-110) uses literals with too many digits:
	- result |= 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#105)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- xSign = uint128(x) >= 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#138)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- xSignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#142)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- ySign = uint128(y) >= 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#144)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- ySignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#148)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- xSignifier >= 0x20000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#168)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- xSignifier < 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#177)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- bytes16(uint128((0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)) (lib/libraries/QuadruplePrecision.sol#181-192)
QuadruplePrecision.add(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#126-262) uses literals with too many digits:
	- bytes16(uint128((0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)) (lib/libraries/QuadruplePrecision.sol#246-257)
QuadruplePrecision.sub(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#278-282) uses literals with too many digits:
	- add(x,y ^ 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#280)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- x ^ (y & 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#311)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- x ^ y == 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#312)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- x ^ (y & 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#317)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- y ^ (x & 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#321)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- xSignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#326)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- ySignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#331)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- bytes16(uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)) (lib/libraries/QuadruplePrecision.sol#372-381)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- (x ^ y) & 0x80000000000000000000000000000000 > 0 (lib/libraries/QuadruplePrecision.sol#335-338)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#342-348)
QuadruplePrecision.mul(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#303-384) uses literals with too many digits:
	- xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#342-348)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- x ^ (y & 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#427)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#431-433)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#437-439)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- ySignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#444)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114 (lib/libraries/QuadruplePrecision.sol#458-460)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- assert(bool)(xSignifier >= 0x1000000000000000000000000000) (lib/libraries/QuadruplePrecision.sol#470)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- bytes16(uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)) (lib/libraries/QuadruplePrecision.sol#505-514)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- (x ^ y) & 0x80000000000000000000000000000000 > 0 (lib/libraries/QuadruplePrecision.sol#465-468)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- xSignifier >= 0x80000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#472-478)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- xSignifier >= 0x40000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#472-478)
QuadruplePrecision.div(bytes16,bytes16) (lib/libraries/QuadruplePrecision.sol#420-517) uses literals with too many digits:
	- xSignifier >= 0x20000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#472-478)
QuadruplePrecision.sqrt(bytes16) (lib/libraries/QuadruplePrecision.sol#537-595) uses literals with too many digits:
	- uint128(x) > 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#539)
QuadruplePrecision.sqrt(bytes16) (lib/libraries/QuadruplePrecision.sol#537-595) uses literals with too many digits:
	- xSignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#547)
QuadruplePrecision.sqrt(bytes16) (lib/libraries/QuadruplePrecision.sol#537-595) uses literals with too many digits:
	- xSignifier >= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#555)
QuadruplePrecision.sqrt(bytes16) (lib/libraries/QuadruplePrecision.sol#537-595) uses literals with too many digits:
	- xSignifier >= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#564)
QuadruplePrecision.sqrt(bytes16) (lib/libraries/QuadruplePrecision.sol#537-595) uses literals with too many digits:
	- r = 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#574)
QuadruplePrecision.mostSignificantBit(uint256) (lib/libraries/QuadruplePrecision.sol#604-642) uses literals with too many digits:
	- x >= 0x100000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#610)
QuadruplePrecision.mostSignificantBit(uint256) (lib/libraries/QuadruplePrecision.sol#604-642) uses literals with too many digits:
	- x >= 0x10000000000000000 (lib/libraries/QuadruplePrecision.sol#614)
QuadruplePrecision.mostSignificantBit(uint256) (lib/libraries/QuadruplePrecision.sol#604-642) uses literals with too many digits:
	- x >= 0x100000000 (lib/libraries/QuadruplePrecision.sol#618)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- uint128(x) > 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#652)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- x == 0x3FFF0000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#653)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- xSignifier |= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#662)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- xSignifier >= 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#676)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- xSignifier == 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#686)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- resultSignifier < 0x10000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#695)
QuadruplePrecision.log_2(bytes16) (lib/libraries/QuadruplePrecision.sol#650-723) uses literals with too many digits:
	- bytes16(uint128((0x80000000000000000000000000000000) | (resultExponent << 112) | (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF))) (lib/libraries/QuadruplePrecision.sol#707-719)
QuadruplePrecision.slitherConstructorConstantVariables() (lib/libraries/QuadruplePrecision.sol#6-736) uses literals with too many digits:
	- POSITIVE_ZERO = 0x00000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#7)
QuadruplePrecision.slitherConstructorConstantVariables() (lib/libraries/QuadruplePrecision.sol#6-736) uses literals with too many digits:
	- NEGATIVE_ZERO = 0x80000000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#12)
QuadruplePrecision.slitherConstructorConstantVariables() (lib/libraries/QuadruplePrecision.sol#6-736) uses literals with too many digits:
	- POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#17-18)
QuadruplePrecision.slitherConstructorConstantVariables() (lib/libraries/QuadruplePrecision.sol#6-736) uses literals with too many digits:
	- NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#23-24)
QuadruplePrecision.slitherConstructorConstantVariables() (lib/libraries/QuadruplePrecision.sol#6-736) uses literals with too many digits:
	- NaN = 0x7FFF8000000000000000000000000000 (lib/libraries/QuadruplePrecision.sol#29)
TickMath.getSqrtRatioAtTick(int24) (lib/libraries/Uniswap/TickMath.sol#26-61) uses literals with too many digits:
	- ratio = 0x100000000000000000000000000000000 (lib/libraries/Uniswap/TickMath.sol#31-33)
BitMath.mostSignificantBit(uint256) (lib/libraries/Uniswap/BitMath.sol#13-45) uses literals with too many digits:
	- x >= 0x100000000000000000000000000000000 (lib/libraries/Uniswap/BitMath.sol#16)
BitMath.mostSignificantBit(uint256) (lib/libraries/Uniswap/BitMath.sol#13-45) uses literals with too many digits:
	- x >= 0x10000000000000000 (lib/libraries/Uniswap/BitMath.sol#20)
BitMath.mostSignificantBit(uint256) (lib/libraries/Uniswap/BitMath.sol#13-45) uses literals with too many digits:
	- x >= 0x100000000 (lib/libraries/Uniswap/BitMath.sol#24)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits

LimitOrderRouterTest.LINK (src/test/LimitOrderRouter.t.sol#54) is never used in LimitOrderRouterTest (src/test/LimitOrderRouter.t.sol#34-1886)
LimitOrderRouterTest.TAXED_TOKEN_1 (src/test/LimitOrderRouter.t.sol#59) is never used in LimitOrderRouterTest (src/test/LimitOrderRouter.t.sol#34-1886)
LimitOrderRouterTest.TAXED_TOKEN_2 (src/test/LimitOrderRouter.t.sol#60) is never used in LimitOrderRouterTest (src/test/LimitOrderRouter.t.sol#34-1886)
LimitOrderRouterTest.TAXED_TOKEN_3 (src/test/LimitOrderRouter.t.sol#61) is never used in LimitOrderRouterTest (src/test/LimitOrderRouter.t.sol#34-1886)
LimitOrderRouterTest.swapToken (src/test/LimitOrderRouter.t.sol#76) is never used in LimitOrderRouterTest (src/test/LimitOrderRouter.t.sol#34-1886)
LimitOrderRouterTest.alphaXDivergenceThreshold (src/test/LimitOrderRouter.t.sol#86) is never used in LimitOrderRouterTest (src/test/LimitOrderRouter.t.sol#34-1886)
LimitOrderRouterWrapper.limitorderRouter (src/test/LimitOrderRouter.t.sol#1889) is never used in LimitOrderRouterWrapper (src/test/LimitOrderRouter.t.sol#1888-1912)
SandboxLimitOrderBookTest.uniV2Addr (src/test/SandboxLimitOrderBook.t.sol#56) is never used in SandboxLimitOrderBookTest (src/test/SandboxLimitOrderBook.t.sol#43-754)
SandboxLimitOrderBookTest.swapToken1 (src/test/SandboxLimitOrderBook.t.sol#60) is never used in SandboxLimitOrderBookTest (src/test/SandboxLimitOrderBook.t.sol#43-754)
SandboxLimitOrderBookTest.swapRouter (src/test/SandboxLimitOrderBook.t.sol#76) is never used in SandboxLimitOrderBookTest (src/test/SandboxLimitOrderBook.t.sol#43-754)
SandboxLimitOrderBookTest.alphaXDivergenceThreshold (src/test/SandboxLimitOrderBook.t.sol#81) is never used in SandboxLimitOrderBookTest (src/test/SandboxLimitOrderBook.t.sol#43-754)
LimitOrderBookTest.uniV2Addr (src/test/LimitOrderBook.t.sol#44) is never used in LimitOrderBookTest (src/test/LimitOrderBook.t.sol#30-602)
LimitOrderBookTest.swapRouter (src/test/LimitOrderBook.t.sol#64) is never used in LimitOrderBookTest (src/test/LimitOrderBook.t.sol#30-602)
LimitOrderBookTest.alphaXDivergenceThreshold (src/test/LimitOrderBook.t.sol#69) is never used in LimitOrderBookTest (src/test/LimitOrderBook.t.sol#30-602)
SwapRouterTest._pancakeFactoryAddress (src/test/SwapRouter.t.sol#55) is never used in SwapRouterTest (src/test/SwapRouter.t.sol#39-758)
SwapRouterTest.swapToken (src/test/SwapRouter.t.sol#59) is never used in SwapRouterTest (src/test/SwapRouter.t.sol#39-758)
SwapRouterTest.swapRouter (src/test/SwapRouter.t.sol#62) is never used in SwapRouterTest (src/test/SwapRouter.t.sol#39-758)
SwapRouterTest.alphaXDivergenceThreshold (src/test/SwapRouter.t.sol#84) is never used in SwapRouterTest (src/test/SwapRouter.t.sol#39-758)
SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) is never used in SwapRouterTest (src/test/SwapRouter.t.sol#39-758)
ConveyorTickMath.MAX_64x64 (src/lib/ConveyorTickMath.sol#32) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.dexToIndex (src/LimitOrderSwapRouter.sol#93) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.BASE_SWAP_FEE (src/LimitOrderSwapRouter.sol#103) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.MAX_UINT_128 (src/LimitOrderSwapRouter.sol#104) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.MAX_UINT_256 (src/LimitOrderSwapRouter.sol#105-106) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.ONE_128x128 (src/LimitOrderSwapRouter.sol#107) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.ZERO_UINT24 (src/LimitOrderSwapRouter.sol#108) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.ZERO_POINT_ZERO_ZERO_FIVE (src/LimitOrderSwapRouter.sol#112) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderSwapRouter.ZERO_POINT_ZERO_ZERO_ONE (src/LimitOrderSwapRouter.sol#113) is never used in LimitOrderExecutorWrapper (src/test/SwapRouter.t.sol#761-866)
LimitOrderQuoterTest.limitOrderRouter (src/test/LimitOrderQuoter.t.sol#41) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.orderRouter (src/test/LimitOrderQuoter.t.sol#44) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.orderBook (src/test/LimitOrderQuoter.t.sol#46) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.LINK (src/test/LimitOrderQuoter.t.sol#60) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.UNI (src/test/LimitOrderQuoter.t.sol#61) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.USDC (src/test/LimitOrderQuoter.t.sol#62) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.DAI (src/test/LimitOrderQuoter.t.sol#63) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.TAXED_TOKEN (src/test/LimitOrderQuoter.t.sol#64) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.TAXED_TOKEN_1 (src/test/LimitOrderQuoter.t.sol#65) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.TAXED_TOKEN_2 (src/test/LimitOrderQuoter.t.sol#66) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.TAXED_TOKEN_3 (src/test/LimitOrderQuoter.t.sol#67) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.MAX_UINT (src/test/LimitOrderQuoter.t.sol#70) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.MAX_U32 (src/test/LimitOrderQuoter.t.sol#72) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.swapToken (src/test/LimitOrderQuoter.t.sol#82) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest._hexDems (src/test/LimitOrderQuoter.t.sol#89-93) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest._dexFactories (src/test/LimitOrderQuoter.t.sol#94-98) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest._isUniV2 (src/test/LimitOrderQuoter.t.sol#99-103) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.alphaXDivergenceThreshold (src/test/LimitOrderQuoter.t.sol#105) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.swapRouter (src/test/LimitOrderQuoter.t.sol#106) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.aggregatorV3Address (src/test/LimitOrderQuoter.t.sol#107) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
LimitOrderQuoterTest.forkId (src/test/LimitOrderQuoter.t.sol#108) is never used in LimitOrderQuoterTest (src/test/LimitOrderQuoter.t.sol#39-418)
ConveyorTickMath.MAX_64x64 (src/lib/ConveyorTickMath.sol#32) is never used in ExecutionWrapper (src/test/LimitOrderQuoter.t.sol#420-476)
LimitOrderExecutorTest.LINK (src/test/LimitOrderExecutor.t.sol#51) is never used in LimitOrderExecutorTest (src/test/LimitOrderExecutor.t.sol#32-3116)
LimitOrderExecutorTest.TAXED_TOKEN_2 (src/test/LimitOrderExecutor.t.sol#57) is never used in LimitOrderExecutorTest (src/test/LimitOrderExecutor.t.sol#32-3116)
LimitOrderExecutorTest.TAXED_TOKEN_3 (src/test/LimitOrderExecutor.t.sol#58) is never used in LimitOrderExecutorTest (src/test/LimitOrderExecutor.t.sol#32-3116)
LimitOrderExecutorTest.alphaXDivergenceThreshold (src/test/LimitOrderExecutor.t.sol#85) is never used in LimitOrderExecutorTest (src/test/LimitOrderExecutor.t.sol#32-3116)
ConveyorTickMathTest.MAX_UINT (src/test/ConveyorTickMath.t.sol#60) is never used in ConveyorTickMathTest (src/test/ConveyorTickMath.t.sol#40-284)
ConveyorTickMathTest.MAX_U32 (src/test/ConveyorTickMath.t.sol#62) is never used in ConveyorTickMathTest (src/test/ConveyorTickMath.t.sol#40-284)
ConveyorTickMathTest._sushiSwapRouterAddress (src/test/ConveyorTickMath.t.sol#65-66) is never used in ConveyorTickMathTest (src/test/ConveyorTickMath.t.sol#40-284)
ConveyorTickMath.MAX_64x64 (src/lib/ConveyorTickMath.sol#32) is never used in ConveyorTickMathWrapper (src/test/ConveyorTickMath.t.sol#286-316)
ConveyorTickMath.MAX_64x64 (src/lib/ConveyorTickMath.sol#32) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.dexToIndex (src/LimitOrderSwapRouter.sol#93) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.BASE_SWAP_FEE (src/LimitOrderSwapRouter.sol#103) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.MAX_UINT_128 (src/LimitOrderSwapRouter.sol#104) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.MAX_UINT_256 (src/LimitOrderSwapRouter.sol#105-106) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.ONE_128x128 (src/LimitOrderSwapRouter.sol#107) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.ZERO_UINT24 (src/LimitOrderSwapRouter.sol#108) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.ZERO_POINT_ZERO_ZERO_FIVE (src/LimitOrderSwapRouter.sol#112) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
LimitOrderSwapRouter.ZERO_POINT_ZERO_ZERO_ONE (src/LimitOrderSwapRouter.sol#113) is never used in SwapRouterWrapper (src/test/ConveyorTickMath.t.sol#318-347)
SandboxLimitOrderRouterTest.LINK (src/test/SandboxLimitOrderRouter.t.sol#79) is never used in SandboxLimitOrderRouterTest (src/test/SandboxLimitOrderRouter.t.sol#59-2036)
SandboxLimitOrderRouterTest.UNI (src/test/SandboxLimitOrderRouter.t.sol#80) is never used in SandboxLimitOrderRouterTest (src/test/SandboxLimitOrderRouter.t.sol#59-2036)
ConveyorFeeMathTest._uniV2Address (src/test/ConveyorFeeMath.t.sol#35) is never used in ConveyorFeeMathTest (src/test/ConveyorFeeMath.t.sol#27-176)
ConveyorFeeMathTest.swapToken (src/test/ConveyorFeeMath.t.sol#41) is never used in ConveyorFeeMathTest (src/test/ConveyorFeeMath.t.sol#27-176)
ConveyorFeeMathTest.swapRouter (src/test/ConveyorFeeMath.t.sol#44) is never used in ConveyorFeeMathTest (src/test/ConveyorFeeMath.t.sol#27-176)
ConveyorFeeMathTest.WETH (src/test/ConveyorFeeMath.t.sol#47) is never used in ConveyorFeeMathTest (src/test/ConveyorFeeMath.t.sol#27-176)
ConveyorFeeMathTest.MAX_UINT (src/test/ConveyorFeeMath.t.sol#56) is never used in ConveyorFeeMathTest (src/test/ConveyorFeeMath.t.sol#27-176)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable

ConveyorFeeMathTest.WETH (src/test/ConveyorFeeMath.t.sol#47) should be constant
ConveyorFeeMathTest._sushiFactoryAddress (src/test/ConveyorFeeMath.t.sol#37) should be constant
ConveyorFeeMathTest._sushiHexDem (src/test/ConveyorFeeMath.t.sol#50-51) should be constant
ConveyorFeeMathTest._uniV2Address (src/test/ConveyorFeeMath.t.sol#35) should be constant
ConveyorFeeMathTest._uniV2FactoryAddress (src/test/ConveyorFeeMath.t.sol#36) should be constant
ConveyorFeeMathTest._uniV3FactoryAddress (src/test/ConveyorFeeMath.t.sol#38) should be constant
ConveyorFeeMathTest._uniswapV2HexDem (src/test/ConveyorFeeMath.t.sol#52-53) should be constant
ConveyorFeeMathTest.swapRouter (src/test/ConveyorFeeMath.t.sol#44) should be constant
ConveyorFeeMathTest.swapToken (src/test/ConveyorFeeMath.t.sol#41) should be constant
ConveyorTickMathTest.DAI (src/test/ConveyorTickMath.t.sol#53) should be constant
ConveyorTickMathTest.USDC (src/test/ConveyorTickMath.t.sol#52) should be constant
ConveyorTickMathTest.WETH (src/test/ConveyorTickMath.t.sol#51) should be constant
ConveyorTickMathTest._sushiSwapRouterAddress (src/test/ConveyorTickMath.t.sol#65-66) should be constant
ConveyorTickMathTest._uniV2Address (src/test/ConveyorTickMath.t.sol#92) should be constant
ConveyorTickMathTest._uniV2FactoryAddress (src/test/ConveyorTickMath.t.sol#67) should be constant
ConveyorTickMathTest._uniV3FactoryAddress (src/test/ConveyorTickMath.t.sol#69) should be constant
ConveyorTickMathTest._uniswapV2HexDem (src/test/ConveyorTickMath.t.sol#73-74) should be constant
ConveyorTickMathTest.daiWethPoolV3 (src/test/ConveyorTickMath.t.sol#56) should be constant
ConveyorTickMathTest.poolAddress (src/test/ConveyorTickMath.t.sol#54) should be constant
ConveyorTickMathTest.usdcWethPoolV3 (src/test/ConveyorTickMath.t.sol#57) should be constant
DSTest.IS_TEST (src/test/utils/test.sol#38) should be constant
LimitOrderBookTest.WETH (src/test/LimitOrderBook.t.sol#45) should be constant
LimitOrderBookTest._sushiSwapRouterAddress (src/test/LimitOrderBook.t.sol#52-53) should be constant
LimitOrderBookTest._uniV2FactoryAddress (src/test/LimitOrderBook.t.sol#54) should be constant
LimitOrderBookTest._uniV3FactoryAddress (src/test/LimitOrderBook.t.sol#55) should be constant
LimitOrderBookTest._uniswapV2HexDem (src/test/LimitOrderBook.t.sol#59-60) should be constant
LimitOrderBookTest.aggregatorV3Address (src/test/LimitOrderBook.t.sol#62) should be constant
LimitOrderBookTest.alphaXDivergenceThreshold (src/test/LimitOrderBook.t.sol#69) should be constant
LimitOrderBookTest.swapRouter (src/test/LimitOrderBook.t.sol#64) should be constant
LimitOrderBookTest.swapToken (src/test/LimitOrderBook.t.sol#47) should be constant
LimitOrderBookTest.swapToken1 (src/test/LimitOrderBook.t.sol#48) should be constant
LimitOrderBookTest.uniV2Addr (src/test/LimitOrderBook.t.sol#44) should be constant
LimitOrderExecutorTest.DAI (src/test/LimitOrderExecutor.t.sol#54) should be constant
LimitOrderExecutorTest.LINK (src/test/LimitOrderExecutor.t.sol#51) should be constant
LimitOrderExecutorTest.TAXED_TOKEN (src/test/LimitOrderExecutor.t.sol#55) should be constant
LimitOrderExecutorTest.TAXED_TOKEN_1 (src/test/LimitOrderExecutor.t.sol#56) should be constant
LimitOrderExecutorTest.TAXED_TOKEN_2 (src/test/LimitOrderExecutor.t.sol#57) should be constant
LimitOrderExecutorTest.TAXED_TOKEN_3 (src/test/LimitOrderExecutor.t.sol#58) should be constant
LimitOrderExecutorTest.UNI (src/test/LimitOrderExecutor.t.sol#52) should be constant
LimitOrderExecutorTest.USDC (src/test/LimitOrderExecutor.t.sol#53) should be constant
LimitOrderExecutorTest.WETH (src/test/LimitOrderExecutor.t.sol#50) should be constant
LimitOrderExecutorTest._sushiSwapRouterAddress (src/test/LimitOrderExecutor.t.sol#66-67) should be constant
LimitOrderExecutorTest._uniV2FactoryAddress (src/test/LimitOrderExecutor.t.sol#68) should be constant
LimitOrderExecutorTest._uniV3FactoryAddress (src/test/LimitOrderExecutor.t.sol#70) should be constant
LimitOrderExecutorTest._uniswapV2HexDem (src/test/LimitOrderExecutor.t.sol#75-76) should be constant
LimitOrderExecutorTest.aggregatorV3Address (src/test/LimitOrderExecutor.t.sol#87) should be constant
LimitOrderExecutorTest.alphaXDivergenceThreshold (src/test/LimitOrderExecutor.t.sol#85) should be constant
LimitOrderExecutorTest.swapToken (src/test/LimitOrderExecutor.t.sol#73) should be constant
LimitOrderExecutorTest.uniV2Addr (src/test/LimitOrderExecutor.t.sol#44) should be constant
LimitOrderQuoterTest.DAI (src/test/LimitOrderQuoter.t.sol#63) should be constant
LimitOrderQuoterTest.LINK (src/test/LimitOrderQuoter.t.sol#60) should be constant
LimitOrderQuoterTest.TAXED_TOKEN (src/test/LimitOrderQuoter.t.sol#64) should be constant
LimitOrderQuoterTest.TAXED_TOKEN_1 (src/test/LimitOrderQuoter.t.sol#65) should be constant
LimitOrderQuoterTest.TAXED_TOKEN_2 (src/test/LimitOrderQuoter.t.sol#66) should be constant
LimitOrderQuoterTest.TAXED_TOKEN_3 (src/test/LimitOrderQuoter.t.sol#67) should be constant
LimitOrderQuoterTest.UNI (src/test/LimitOrderQuoter.t.sol#61) should be constant
LimitOrderQuoterTest.USDC (src/test/LimitOrderQuoter.t.sol#62) should be constant
LimitOrderQuoterTest.WETH (src/test/LimitOrderQuoter.t.sol#59) should be constant
LimitOrderQuoterTest._sushiSwapRouterAddress (src/test/LimitOrderQuoter.t.sol#75-76) should be constant
LimitOrderQuoterTest._uniV2FactoryAddress (src/test/LimitOrderQuoter.t.sol#77) should be constant
LimitOrderQuoterTest._uniV3FactoryAddress (src/test/LimitOrderQuoter.t.sol#79) should be constant
LimitOrderQuoterTest._uniswapV2HexDem (src/test/LimitOrderQuoter.t.sol#85-86) should be constant
LimitOrderQuoterTest.aggregatorV3Address (src/test/LimitOrderQuoter.t.sol#107) should be constant
LimitOrderQuoterTest.alphaXDivergenceThreshold (src/test/LimitOrderQuoter.t.sol#105) should be constant
LimitOrderQuoterTest.forkId (src/test/LimitOrderQuoter.t.sol#108) should be constant
LimitOrderQuoterTest.limitOrderRouter (src/test/LimitOrderQuoter.t.sol#41) should be constant
LimitOrderQuoterTest.orderBook (src/test/LimitOrderQuoter.t.sol#46) should be constant
LimitOrderQuoterTest.orderRouter (src/test/LimitOrderQuoter.t.sol#44) should be constant
LimitOrderQuoterTest.swapRouter (src/test/LimitOrderQuoter.t.sol#106) should be constant
LimitOrderQuoterTest.swapToken (src/test/LimitOrderQuoter.t.sol#82) should be constant
LimitOrderQuoterTest.uniV2Addr (src/test/LimitOrderQuoter.t.sol#53) should be constant
LimitOrderRouter.initialTxGas (src/LimitOrderRouter.sol#71) should be constant
LimitOrderRouterTest.DAI (src/test/LimitOrderRouter.t.sol#57) should be constant
LimitOrderRouterTest.LINK (src/test/LimitOrderRouter.t.sol#54) should be constant
LimitOrderRouterTest.REFRESH_FEE (src/test/LimitOrderRouter.t.sol#46) should be constant
LimitOrderRouterTest.TAXED_TOKEN (src/test/LimitOrderRouter.t.sol#58) should be constant
LimitOrderRouterTest.TAXED_TOKEN_1 (src/test/LimitOrderRouter.t.sol#59) should be constant
LimitOrderRouterTest.TAXED_TOKEN_2 (src/test/LimitOrderRouter.t.sol#60) should be constant
LimitOrderRouterTest.TAXED_TOKEN_3 (src/test/LimitOrderRouter.t.sol#61) should be constant
LimitOrderRouterTest.UNI (src/test/LimitOrderRouter.t.sol#55) should be constant
LimitOrderRouterTest.USDC (src/test/LimitOrderRouter.t.sol#56) should be constant
LimitOrderRouterTest.WETH (src/test/LimitOrderRouter.t.sol#53) should be constant
LimitOrderRouterTest._sushiSwapRouterAddress (src/test/LimitOrderRouter.t.sol#69-70) should be constant
LimitOrderRouterTest._uniV2FactoryAddress (src/test/LimitOrderRouter.t.sol#71) should be constant
LimitOrderRouterTest._uniV3FactoryAddress (src/test/LimitOrderRouter.t.sol#73) should be constant
LimitOrderRouterTest._uniswapV2HexDem (src/test/LimitOrderRouter.t.sol#78-79) should be constant
LimitOrderRouterTest.aggregatorV3Address (src/test/LimitOrderRouter.t.sol#88) should be constant
LimitOrderRouterTest.alphaXDivergenceThreshold (src/test/LimitOrderRouter.t.sol#86) should be constant
LimitOrderRouterTest.swapToken (src/test/LimitOrderRouter.t.sol#76) should be constant
LimitOrderRouterTest.uniV2Addr (src/test/LimitOrderRouter.t.sol#47) should be constant
LimitOrderRouterWrapper.limitorderRouter (src/test/LimitOrderRouter.t.sol#1889) should be constant
SandboxLimitOrderBook.initialTxGas (src/SandboxLimitOrderBook.sol#52) should be constant
SandboxLimitOrderBookTest.REFRESH_FEE (src/test/SandboxLimitOrderBook.t.sol#82) should be constant
SandboxLimitOrderBookTest.WETH (src/test/SandboxLimitOrderBook.t.sol#57) should be constant
SandboxLimitOrderBookTest._sushiSwapRouterAddress (src/test/SandboxLimitOrderBook.t.sol#64-65) should be constant
SandboxLimitOrderBookTest._uniV2FactoryAddress (src/test/SandboxLimitOrderBook.t.sol#66) should be constant
SandboxLimitOrderBookTest._uniV3FactoryAddress (src/test/SandboxLimitOrderBook.t.sol#67) should be constant
SandboxLimitOrderBookTest._uniswapV2HexDem (src/test/SandboxLimitOrderBook.t.sol#71-72) should be constant
SandboxLimitOrderBookTest.aggregatorV3Address (src/test/SandboxLimitOrderBook.t.sol#74) should be constant
SandboxLimitOrderBookTest.alphaXDivergenceThreshold (src/test/SandboxLimitOrderBook.t.sol#81) should be constant
SandboxLimitOrderBookTest.swapRouter (src/test/SandboxLimitOrderBook.t.sol#76) should be constant
SandboxLimitOrderBookTest.swapToken (src/test/SandboxLimitOrderBook.t.sol#59) should be constant
SandboxLimitOrderBookTest.swapToken1 (src/test/SandboxLimitOrderBook.t.sol#60) should be constant
SandboxLimitOrderBookTest.uniV2Addr (src/test/SandboxLimitOrderBook.t.sol#56) should be constant
SandboxLimitOrderRouterTest.DAI (src/test/SandboxLimitOrderRouter.t.sol#82) should be constant
SandboxLimitOrderRouterTest.LINK (src/test/SandboxLimitOrderRouter.t.sol#79) should be constant
SandboxLimitOrderRouterTest.SANDBOX_LIMIT_ORDER_EXECUTION_GAS_COST (src/test/SandboxLimitOrderRouter.t.sol#99) should be constant
SandboxLimitOrderRouterTest.UNI (src/test/SandboxLimitOrderRouter.t.sol#80) should be constant
SandboxLimitOrderRouterTest.USDC (src/test/SandboxLimitOrderRouter.t.sol#81) should be constant
SandboxLimitOrderRouterTest.WETH (src/test/SandboxLimitOrderRouter.t.sol#78) should be constant
SandboxLimitOrderRouterTest._sushiSwapRouterAddress (src/test/SandboxLimitOrderRouter.t.sol#85-86) should be constant
SandboxLimitOrderRouterTest._uniV2FactoryAddress (src/test/SandboxLimitOrderRouter.t.sol#87) should be constant
SandboxLimitOrderRouterTest._uniV3FactoryAddress (src/test/SandboxLimitOrderRouter.t.sol#89) should be constant
SandboxLimitOrderRouterTest._uniswapV2HexDem (src/test/SandboxLimitOrderRouter.t.sol#92-93) should be constant
SandboxLimitOrderRouterTest.aggregatorV3Address (src/test/SandboxLimitOrderRouter.t.sol#101) should be constant
SandboxLimitOrderRouterTest.limitOrderRouter (src/test/SandboxLimitOrderRouter.t.sol#61) should be constant
SandboxLimitOrderRouterTest.mockOwner1 (src/test/SandboxLimitOrderRouter.t.sol#103) should be constant
SandboxLimitOrderRouterTest.mockOwner10 (src/test/SandboxLimitOrderRouter.t.sol#112) should be constant
SandboxLimitOrderRouterTest.mockOwner2 (src/test/SandboxLimitOrderRouter.t.sol#104) should be constant
SandboxLimitOrderRouterTest.mockOwner3 (src/test/SandboxLimitOrderRouter.t.sol#105) should be constant
SandboxLimitOrderRouterTest.mockOwner4 (src/test/SandboxLimitOrderRouter.t.sol#106) should be constant
SandboxLimitOrderRouterTest.mockOwner5 (src/test/SandboxLimitOrderRouter.t.sol#107) should be constant
SandboxLimitOrderRouterTest.mockOwner6 (src/test/SandboxLimitOrderRouter.t.sol#108) should be constant
SandboxLimitOrderRouterTest.mockOwner7 (src/test/SandboxLimitOrderRouter.t.sol#109) should be constant
SandboxLimitOrderRouterTest.mockOwner8 (src/test/SandboxLimitOrderRouter.t.sol#110) should be constant
SandboxLimitOrderRouterTest.mockOwner9 (src/test/SandboxLimitOrderRouter.t.sol#111) should be constant
SandboxLimitOrderRouterTest.uniV2Addr (src/test/SandboxLimitOrderRouter.t.sol#72) should be constant
ScriptRunner.cheatCodes (src/test/utils/ScriptRunner.sol#13) should be constant
SwapRouterTest.WETH (src/test/SwapRouter.t.sol#65) should be constant
SwapRouterTest._pancakeFactoryAddress (src/test/SwapRouter.t.sol#55) should be constant
SwapRouterTest._sushiFactoryAddress (src/test/SwapRouter.t.sol#54) should be constant
SwapRouterTest._sushiHexDem (src/test/SwapRouter.t.sol#68-69) should be constant
SwapRouterTest._uniV2Address (src/test/SwapRouter.t.sol#52) should be constant
SwapRouterTest._uniV2FactoryAddress (src/test/SwapRouter.t.sol#53) should be constant
SwapRouterTest._uniV3FactoryAddress (src/test/SwapRouter.t.sol#56) should be constant
SwapRouterTest._uniswapV2HexDem (src/test/SwapRouter.t.sol#70-71) should be constant
SwapRouterTest.alphaXDivergenceThreshold (src/test/SwapRouter.t.sol#84) should be constant
SwapRouterTest.forkId (src/test/SwapRouter.t.sol#85) should be constant
SwapRouterTest.swapRouter (src/test/SwapRouter.t.sol#62) should be constant
SwapRouterTest.swapToken (src/test/SwapRouter.t.sol#59) should be constant
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant
